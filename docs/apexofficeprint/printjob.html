<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>apexofficeprint.printjob API documentation</title>
<meta name="description" content="Module containing the PrintJob class, which is also exposed at package level." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>apexofficeprint.printjob</code></h1>
</header>
<section id="section-intro">
<p>Module containing the PrintJob class, which is also exposed at package level.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Module containing the PrintJob class, which is also exposed at package level.
&#34;&#34;&#34;

from apexofficeprint.elements.rest_source import RESTSource
import requests
import asyncio
import json
from .config import OutputConfig, Server
from .exceptions import AOPError
from .response import Response
from .resource import Resource
from .elements import Element, ElementCollection
from typing import Union, List, Dict, Mapping
from functools import partial
import sys
from pprint import pprint

STATIC_OPTS = {
    &#34;tool&#34;: &#34;python&#34;,
    # &#34;version&#34;: &#34;18.2&#34;, # optional: version of AOP JSON format
    &#34;python_sdk_version&#34;: &#34;21.1&#34;,
}


class PrintJob:
    &#34;&#34;&#34;A print job for a AOP server.

    This class contains all configuration options, resources, render elements ...
    and the `PrintJob.execute` method to combine all these and send a request to the AOP server.
    &#34;&#34;&#34;

    def __init__(self,
                 template: Resource,
                 data: Union[Element, Mapping[str, Element], RESTSource],
                 server: Server,
                 output_config: OutputConfig = OutputConfig(),
                 subtemplates: Dict[str, Resource] = {},
                 prepend_files: List[Resource] = [],
                 append_files: List[Resource] = [],
                 aop_verbose: bool = False):
        &#34;&#34;&#34;
        Args:
            template (Resource): Template to use for this print job.
            data (Union[Element, Mapping[str, Element], RESTSource]): This is either: An `Element` (e.g. an `ElementCollection`); A mapping, containing file names as keys and an `Element` as data. Multiple files will be produced from the different datas, the result is a zip file containing them. In the first case, no output file name is specified and the server will name it &#34;file0&#34;.
            server (Server): Server to be used for this print job.
            output_config (OutputConfig, optional): Output configuration to be used for this print job. Defaults to `OutputConfig`().
            subtemplates (Dict[str, Resource], optional): Subtemplates for this print job, accessible (in docx) through `{?include subtemplate_dict_key}`. Defaults to {}.
            prepend_files (List[Resource], optional): Files to prepend to the output file. Defaults to [].
            append_files (List[Resource], optional): Files to append to the output file. Defaults to [].
            aop_verbose (bool, optional): Whether or not verbose mode should be activated. Defaults to False.
        &#34;&#34;&#34;
        
        self.data: Union[Element, Mapping[str, Element], RESTSource] = data
        self.server: Server = server
        self.output_config: OutputConfig = output_config
        self.template: Resource = template
        self.subtemplates: Dict[str, Resource] = subtemplates
        self.prepend_files: List[Resource] = prepend_files
        self.append_files: List[Resource] = append_files
        self.aop_verbose: bool = aop_verbose

    def execute(self) -&gt; Response:
        &#34;&#34;&#34;Execute this print job.

        Returns:
            Response: `Response`-object
        &#34;&#34;&#34;
        self.server._raise_if_unreachable()
        return self._handle_response(requests.post(self.server.url, proxies=self.server.config.proxies if self.server.config is not None else None, json=self.as_dict))

    async def execute_async(self) -&gt; Response:
        &#34;&#34;&#34;Async version of `PrintJob.execute`

        Returns:
            Response: `Response`-object
        &#34;&#34;&#34;
        self.server._raise_if_unreachable()
        return PrintJob._handle_response(
            await asyncio.get_event_loop().run_in_executor(
                None, partial(
                    requests.post,
                    self.server.url,
                    proxies=self.server.config.proxies if self.server.config is not None else None,
                    json=self.as_dict
                )
            )
        )

    @staticmethod
    def execute_full_json(json_data: str, server: Server) -&gt; Response:
        &#34;&#34;&#34;If you already have the JSON to be sent to the server (not just the data, but the entire JSON body including your API key and template), this package will wrap the request to the server.

        Args:
            json_data (str): full JSON data that needs to be sent to an AOP server
            server (Server): `Server`-object

        Returns:
            Response: `Response`-object
        &#34;&#34;&#34;
        server._raise_if_unreachable()
        return PrintJob._handle_response(requests.post(server.url, proxies=server.config.proxies if server.config is not None else None, data=json_data, headers={&#34;Content-type&#34;: &#34;application/json&#34;}))

    @staticmethod
    async def execute_full_json_async(json_data: str, server: Server) -&gt; Response:
        &#34;&#34;&#34;Async version of `Printjob.execute_full_json`

        Args:
            json_data (str): full JSON data that needs to be sent to an AOP server
            server (Server): `Server`-object

        Returns:
            Response: `Response`-object
        &#34;&#34;&#34;
        server._raise_if_unreachable()
        return PrintJob._handle_response(
            await asyncio.get_event_loop().run_in_executor(
                None, partial(
                    requests.post,
                    server.url,
                    proxies=server.config.proxies if server.config is not None else None,
                    data=json_data,
                    headers={&#34;Content-type&#34;: &#34;application/json&#34;}
                )
            )
        )

    @staticmethod
    def _handle_response(res: requests.Response) -&gt; Response:
        &#34;&#34;&#34;Converts the HTML response to a `Response`-object

        Args:
            res (requests.Response): HTML response from the AOP server

        Raises:
            AOPError: Error when the HTML status code is not 200

        Returns:
            Response: `Response`-object of HTML response
        &#34;&#34;&#34;
        if res.status_code != 200:
            raise AOPError(res.text)
        else:
            return Response(res)

    @property
    def json(self) -&gt; str:
        &#34;&#34;&#34;JSON equivalent of the dict representation of this print job.
        This representation is isomorphic to the dict representation `Printjob.as_dict`.

        Returns:
            str: JSON equivalent of the dict representation of this print job
        &#34;&#34;&#34;
        return json.dumps(self.as_dict)

    @property
    def as_dict(self) -&gt; Dict:
        &#34;&#34;&#34;Return the dict representation of this print job.

        Returns:
            Dict: dict representation of this print job
        &#34;&#34;&#34;
        result = dict(STATIC_OPTS) # Copy of STATIC_OPTS! Otherwise everything we add to &#39;result&#39; will also be added to &#39;STATIC_OPTS&#39;
        # server config goes in the upper level
        if self.server.config:
            result.update(self.server.config.as_dict)

        # output config goes in &#34;output&#34;
        # and decides where its sub-configs go through its as_dict property
        # (e.g. PDFConfigs are just appended at this &#34;output&#34; level)
        result[&#34;output&#34;] = self.output_config.as_dict

        result[&#34;template&#34;] = self.template.template_dict

        # If output_type is not specified, set this to the template filetype
        if &#39;output_type&#39; not in self.output_config.as_dict.keys():
            result[&#39;output&#39;][&#39;output_type&#39;] = result[&#39;template&#39;][&#39;template_type&#39;]

        if isinstance(self.data, Mapping):
            result[&#34;files&#34;] = [{
                &#34;filename&#34;: name,
                &#34;data&#34;: data.as_dict
            } for name, data in self.data.items()]
        elif isinstance(self.data, RESTSource):
            result[&#39;files&#39;] = [self.data.as_dict]
        else:
            result[&#34;files&#34;] = [{&#34;data&#34;: self.data.as_dict}]

        if len(self.prepend_files) &gt; 0:
            result[&#34;prepend_files&#34;] = [
                res.secondary_file_dict for res in self.prepend_files
            ]

        if len(self.append_files) &gt; 0:
            result[&#34;append_files&#34;] = [
                res.secondary_file_dict for res in self.append_files
            ]

        if len(self.subtemplates) &gt; 0:
            templates_list = []
            for name, res in self.subtemplates.items():
                to_add = res.secondary_file_dict
                to_add[&#34;name&#34;] = name
                templates_list.append(to_add)
            result[&#34;templates&#34;] = templates_list

        # If verbose mode is activated, print the result to the terminal
        if self.aop_verbose == True:
            print(&#39;The JSON data that is sent to the AOP server:\n&#39;)
            pprint(result)

        return result</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="apexofficeprint.printjob.PrintJob"><code class="flex name class">
<span>class <span class="ident">PrintJob</span></span>
<span>(</span><span>template: <a title="apexofficeprint.resource.Resource" href="resource.html#apexofficeprint.resource.Resource">Resource</a>, data: Union[<a title="apexofficeprint.elements.elements.Element" href="elements/elements.html#apexofficeprint.elements.elements.Element">Element</a>, Mapping[str, <a title="apexofficeprint.elements.elements.Element" href="elements/elements.html#apexofficeprint.elements.elements.Element">Element</a>], <a title="apexofficeprint.elements.rest_source.RESTSource" href="elements/rest_source.html#apexofficeprint.elements.rest_source.RESTSource">RESTSource</a>], server: <a title="apexofficeprint.config.server.Server" href="config/server.html#apexofficeprint.config.server.Server">Server</a>, output_config: <a title="apexofficeprint.config.output.OutputConfig" href="config/output.html#apexofficeprint.config.output.OutputConfig">OutputConfig</a> = &lt;apexofficeprint.config.output.OutputConfig object&gt;, subtemplates: Dict[str, <a title="apexofficeprint.resource.Resource" href="resource.html#apexofficeprint.resource.Resource">Resource</a>] = {}, prepend_files: List[<a title="apexofficeprint.resource.Resource" href="resource.html#apexofficeprint.resource.Resource">Resource</a>] = [], append_files: List[<a title="apexofficeprint.resource.Resource" href="resource.html#apexofficeprint.resource.Resource">Resource</a>] = [], aop_verbose: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>A print job for a AOP server.</p>
<p>This class contains all configuration options, resources, render elements &hellip;
and the <code><a title="apexofficeprint.printjob.PrintJob.execute" href="#apexofficeprint.printjob.PrintJob.execute">PrintJob.execute()</a></code> method to combine all these and send a request to the AOP server.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>template</code></strong> :&ensp;<code>Resource</code></dt>
<dd>Template to use for this print job.</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>Union[Element, Mapping[str, Element], RESTSource]</code></dt>
<dd>This is either: An <code>Element</code> (e.g. an <code>ElementCollection</code>); A mapping, containing file names as keys and an <code>Element</code> as data. Multiple files will be produced from the different datas, the result is a zip file containing them. In the first case, no output file name is specified and the server will name it "file0".</dd>
<dt><strong><code>server</code></strong> :&ensp;<code>Server</code></dt>
<dd>Server to be used for this print job.</dd>
<dt><strong><code>output_config</code></strong> :&ensp;<code>OutputConfig</code>, optional</dt>
<dd>Output configuration to be used for this print job. Defaults to <code>OutputConfig</code>().</dd>
<dt><strong><code>subtemplates</code></strong> :&ensp;<code>Dict[str, Resource]</code>, optional</dt>
<dd>Subtemplates for this print job, accessible (in docx) through <code>{?include subtemplate_dict_key}</code>. Defaults to {}.</dd>
<dt><strong><code>prepend_files</code></strong> :&ensp;<code>List[Resource]</code>, optional</dt>
<dd>Files to prepend to the output file. Defaults to [].</dd>
<dt><strong><code>append_files</code></strong> :&ensp;<code>List[Resource]</code>, optional</dt>
<dd>Files to append to the output file. Defaults to [].</dd>
<dt><strong><code>aop_verbose</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether or not verbose mode should be activated. Defaults to False.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PrintJob:
    &#34;&#34;&#34;A print job for a AOP server.

    This class contains all configuration options, resources, render elements ...
    and the `PrintJob.execute` method to combine all these and send a request to the AOP server.
    &#34;&#34;&#34;

    def __init__(self,
                 template: Resource,
                 data: Union[Element, Mapping[str, Element], RESTSource],
                 server: Server,
                 output_config: OutputConfig = OutputConfig(),
                 subtemplates: Dict[str, Resource] = {},
                 prepend_files: List[Resource] = [],
                 append_files: List[Resource] = [],
                 aop_verbose: bool = False):
        &#34;&#34;&#34;
        Args:
            template (Resource): Template to use for this print job.
            data (Union[Element, Mapping[str, Element], RESTSource]): This is either: An `Element` (e.g. an `ElementCollection`); A mapping, containing file names as keys and an `Element` as data. Multiple files will be produced from the different datas, the result is a zip file containing them. In the first case, no output file name is specified and the server will name it &#34;file0&#34;.
            server (Server): Server to be used for this print job.
            output_config (OutputConfig, optional): Output configuration to be used for this print job. Defaults to `OutputConfig`().
            subtemplates (Dict[str, Resource], optional): Subtemplates for this print job, accessible (in docx) through `{?include subtemplate_dict_key}`. Defaults to {}.
            prepend_files (List[Resource], optional): Files to prepend to the output file. Defaults to [].
            append_files (List[Resource], optional): Files to append to the output file. Defaults to [].
            aop_verbose (bool, optional): Whether or not verbose mode should be activated. Defaults to False.
        &#34;&#34;&#34;
        
        self.data: Union[Element, Mapping[str, Element], RESTSource] = data
        self.server: Server = server
        self.output_config: OutputConfig = output_config
        self.template: Resource = template
        self.subtemplates: Dict[str, Resource] = subtemplates
        self.prepend_files: List[Resource] = prepend_files
        self.append_files: List[Resource] = append_files
        self.aop_verbose: bool = aop_verbose

    def execute(self) -&gt; Response:
        &#34;&#34;&#34;Execute this print job.

        Returns:
            Response: `Response`-object
        &#34;&#34;&#34;
        self.server._raise_if_unreachable()
        return self._handle_response(requests.post(self.server.url, proxies=self.server.config.proxies if self.server.config is not None else None, json=self.as_dict))

    async def execute_async(self) -&gt; Response:
        &#34;&#34;&#34;Async version of `PrintJob.execute`

        Returns:
            Response: `Response`-object
        &#34;&#34;&#34;
        self.server._raise_if_unreachable()
        return PrintJob._handle_response(
            await asyncio.get_event_loop().run_in_executor(
                None, partial(
                    requests.post,
                    self.server.url,
                    proxies=self.server.config.proxies if self.server.config is not None else None,
                    json=self.as_dict
                )
            )
        )

    @staticmethod
    def execute_full_json(json_data: str, server: Server) -&gt; Response:
        &#34;&#34;&#34;If you already have the JSON to be sent to the server (not just the data, but the entire JSON body including your API key and template), this package will wrap the request to the server.

        Args:
            json_data (str): full JSON data that needs to be sent to an AOP server
            server (Server): `Server`-object

        Returns:
            Response: `Response`-object
        &#34;&#34;&#34;
        server._raise_if_unreachable()
        return PrintJob._handle_response(requests.post(server.url, proxies=server.config.proxies if server.config is not None else None, data=json_data, headers={&#34;Content-type&#34;: &#34;application/json&#34;}))

    @staticmethod
    async def execute_full_json_async(json_data: str, server: Server) -&gt; Response:
        &#34;&#34;&#34;Async version of `Printjob.execute_full_json`

        Args:
            json_data (str): full JSON data that needs to be sent to an AOP server
            server (Server): `Server`-object

        Returns:
            Response: `Response`-object
        &#34;&#34;&#34;
        server._raise_if_unreachable()
        return PrintJob._handle_response(
            await asyncio.get_event_loop().run_in_executor(
                None, partial(
                    requests.post,
                    server.url,
                    proxies=server.config.proxies if server.config is not None else None,
                    data=json_data,
                    headers={&#34;Content-type&#34;: &#34;application/json&#34;}
                )
            )
        )

    @staticmethod
    def _handle_response(res: requests.Response) -&gt; Response:
        &#34;&#34;&#34;Converts the HTML response to a `Response`-object

        Args:
            res (requests.Response): HTML response from the AOP server

        Raises:
            AOPError: Error when the HTML status code is not 200

        Returns:
            Response: `Response`-object of HTML response
        &#34;&#34;&#34;
        if res.status_code != 200:
            raise AOPError(res.text)
        else:
            return Response(res)

    @property
    def json(self) -&gt; str:
        &#34;&#34;&#34;JSON equivalent of the dict representation of this print job.
        This representation is isomorphic to the dict representation `Printjob.as_dict`.

        Returns:
            str: JSON equivalent of the dict representation of this print job
        &#34;&#34;&#34;
        return json.dumps(self.as_dict)

    @property
    def as_dict(self) -&gt; Dict:
        &#34;&#34;&#34;Return the dict representation of this print job.

        Returns:
            Dict: dict representation of this print job
        &#34;&#34;&#34;
        result = dict(STATIC_OPTS) # Copy of STATIC_OPTS! Otherwise everything we add to &#39;result&#39; will also be added to &#39;STATIC_OPTS&#39;
        # server config goes in the upper level
        if self.server.config:
            result.update(self.server.config.as_dict)

        # output config goes in &#34;output&#34;
        # and decides where its sub-configs go through its as_dict property
        # (e.g. PDFConfigs are just appended at this &#34;output&#34; level)
        result[&#34;output&#34;] = self.output_config.as_dict

        result[&#34;template&#34;] = self.template.template_dict

        # If output_type is not specified, set this to the template filetype
        if &#39;output_type&#39; not in self.output_config.as_dict.keys():
            result[&#39;output&#39;][&#39;output_type&#39;] = result[&#39;template&#39;][&#39;template_type&#39;]

        if isinstance(self.data, Mapping):
            result[&#34;files&#34;] = [{
                &#34;filename&#34;: name,
                &#34;data&#34;: data.as_dict
            } for name, data in self.data.items()]
        elif isinstance(self.data, RESTSource):
            result[&#39;files&#39;] = [self.data.as_dict]
        else:
            result[&#34;files&#34;] = [{&#34;data&#34;: self.data.as_dict}]

        if len(self.prepend_files) &gt; 0:
            result[&#34;prepend_files&#34;] = [
                res.secondary_file_dict for res in self.prepend_files
            ]

        if len(self.append_files) &gt; 0:
            result[&#34;append_files&#34;] = [
                res.secondary_file_dict for res in self.append_files
            ]

        if len(self.subtemplates) &gt; 0:
            templates_list = []
            for name, res in self.subtemplates.items():
                to_add = res.secondary_file_dict
                to_add[&#34;name&#34;] = name
                templates_list.append(to_add)
            result[&#34;templates&#34;] = templates_list

        # If verbose mode is activated, print the result to the terminal
        if self.aop_verbose == True:
            print(&#39;The JSON data that is sent to the AOP server:\n&#39;)
            pprint(result)

        return result</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="apexofficeprint.printjob.PrintJob.execute_full_json"><code class="name flex">
<span>def <span class="ident">execute_full_json</span></span>(<span>json_data: str, server: <a title="apexofficeprint.config.server.Server" href="config/server.html#apexofficeprint.config.server.Server">Server</a>) ‑> <a title="apexofficeprint.response.Response" href="response.html#apexofficeprint.response.Response">Response</a></span>
</code></dt>
<dd>
<div class="desc"><p>If you already have the JSON to be sent to the server (not just the data, but the entire JSON body including your API key and template), this package will wrap the request to the server.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>json_data</code></strong> :&ensp;<code>str</code></dt>
<dd>full JSON data that needs to be sent to an AOP server</dd>
<dt><strong><code>server</code></strong> :&ensp;<code>Server</code></dt>
<dd><code>Server</code>-object</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Response</code></dt>
<dd><code>Response</code>-object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def execute_full_json(json_data: str, server: Server) -&gt; Response:
    &#34;&#34;&#34;If you already have the JSON to be sent to the server (not just the data, but the entire JSON body including your API key and template), this package will wrap the request to the server.

    Args:
        json_data (str): full JSON data that needs to be sent to an AOP server
        server (Server): `Server`-object

    Returns:
        Response: `Response`-object
    &#34;&#34;&#34;
    server._raise_if_unreachable()
    return PrintJob._handle_response(requests.post(server.url, proxies=server.config.proxies if server.config is not None else None, data=json_data, headers={&#34;Content-type&#34;: &#34;application/json&#34;}))</code></pre>
</details>
</dd>
<dt id="apexofficeprint.printjob.PrintJob.execute_full_json_async"><code class="name flex">
<span>async def <span class="ident">execute_full_json_async</span></span>(<span>json_data: str, server: <a title="apexofficeprint.config.server.Server" href="config/server.html#apexofficeprint.config.server.Server">Server</a>) ‑> <a title="apexofficeprint.response.Response" href="response.html#apexofficeprint.response.Response">Response</a></span>
</code></dt>
<dd>
<div class="desc"><p>Async version of <code>Printjob.execute_full_json</code></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>json_data</code></strong> :&ensp;<code>str</code></dt>
<dd>full JSON data that needs to be sent to an AOP server</dd>
<dt><strong><code>server</code></strong> :&ensp;<code>Server</code></dt>
<dd><code>Server</code>-object</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Response</code></dt>
<dd><code>Response</code>-object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
async def execute_full_json_async(json_data: str, server: Server) -&gt; Response:
    &#34;&#34;&#34;Async version of `Printjob.execute_full_json`

    Args:
        json_data (str): full JSON data that needs to be sent to an AOP server
        server (Server): `Server`-object

    Returns:
        Response: `Response`-object
    &#34;&#34;&#34;
    server._raise_if_unreachable()
    return PrintJob._handle_response(
        await asyncio.get_event_loop().run_in_executor(
            None, partial(
                requests.post,
                server.url,
                proxies=server.config.proxies if server.config is not None else None,
                data=json_data,
                headers={&#34;Content-type&#34;: &#34;application/json&#34;}
            )
        )
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="apexofficeprint.printjob.PrintJob.as_dict"><code class="name">var <span class="ident">as_dict</span> : Dict</code></dt>
<dd>
<div class="desc"><p>Return the dict representation of this print job.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict</code></dt>
<dd>dict representation of this print job</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def as_dict(self) -&gt; Dict:
    &#34;&#34;&#34;Return the dict representation of this print job.

    Returns:
        Dict: dict representation of this print job
    &#34;&#34;&#34;
    result = dict(STATIC_OPTS) # Copy of STATIC_OPTS! Otherwise everything we add to &#39;result&#39; will also be added to &#39;STATIC_OPTS&#39;
    # server config goes in the upper level
    if self.server.config:
        result.update(self.server.config.as_dict)

    # output config goes in &#34;output&#34;
    # and decides where its sub-configs go through its as_dict property
    # (e.g. PDFConfigs are just appended at this &#34;output&#34; level)
    result[&#34;output&#34;] = self.output_config.as_dict

    result[&#34;template&#34;] = self.template.template_dict

    # If output_type is not specified, set this to the template filetype
    if &#39;output_type&#39; not in self.output_config.as_dict.keys():
        result[&#39;output&#39;][&#39;output_type&#39;] = result[&#39;template&#39;][&#39;template_type&#39;]

    if isinstance(self.data, Mapping):
        result[&#34;files&#34;] = [{
            &#34;filename&#34;: name,
            &#34;data&#34;: data.as_dict
        } for name, data in self.data.items()]
    elif isinstance(self.data, RESTSource):
        result[&#39;files&#39;] = [self.data.as_dict]
    else:
        result[&#34;files&#34;] = [{&#34;data&#34;: self.data.as_dict}]

    if len(self.prepend_files) &gt; 0:
        result[&#34;prepend_files&#34;] = [
            res.secondary_file_dict for res in self.prepend_files
        ]

    if len(self.append_files) &gt; 0:
        result[&#34;append_files&#34;] = [
            res.secondary_file_dict for res in self.append_files
        ]

    if len(self.subtemplates) &gt; 0:
        templates_list = []
        for name, res in self.subtemplates.items():
            to_add = res.secondary_file_dict
            to_add[&#34;name&#34;] = name
            templates_list.append(to_add)
        result[&#34;templates&#34;] = templates_list

    # If verbose mode is activated, print the result to the terminal
    if self.aop_verbose == True:
        print(&#39;The JSON data that is sent to the AOP server:\n&#39;)
        pprint(result)

    return result</code></pre>
</details>
</dd>
<dt id="apexofficeprint.printjob.PrintJob.json"><code class="name">var <span class="ident">json</span> : str</code></dt>
<dd>
<div class="desc"><p>JSON equivalent of the dict representation of this print job.
This representation is isomorphic to the dict representation <code>Printjob.as_dict</code>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>JSON equivalent of the dict representation of this print job</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def json(self) -&gt; str:
    &#34;&#34;&#34;JSON equivalent of the dict representation of this print job.
    This representation is isomorphic to the dict representation `Printjob.as_dict`.

    Returns:
        str: JSON equivalent of the dict representation of this print job
    &#34;&#34;&#34;
    return json.dumps(self.as_dict)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="apexofficeprint.printjob.PrintJob.execute"><code class="name flex">
<span>def <span class="ident">execute</span></span>(<span>self) ‑> <a title="apexofficeprint.response.Response" href="response.html#apexofficeprint.response.Response">Response</a></span>
</code></dt>
<dd>
<div class="desc"><p>Execute this print job.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Response</code></dt>
<dd><code>Response</code>-object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute(self) -&gt; Response:
    &#34;&#34;&#34;Execute this print job.

    Returns:
        Response: `Response`-object
    &#34;&#34;&#34;
    self.server._raise_if_unreachable()
    return self._handle_response(requests.post(self.server.url, proxies=self.server.config.proxies if self.server.config is not None else None, json=self.as_dict))</code></pre>
</details>
</dd>
<dt id="apexofficeprint.printjob.PrintJob.execute_async"><code class="name flex">
<span>async def <span class="ident">execute_async</span></span>(<span>self) ‑> <a title="apexofficeprint.response.Response" href="response.html#apexofficeprint.response.Response">Response</a></span>
</code></dt>
<dd>
<div class="desc"><p>Async version of <code><a title="apexofficeprint.printjob.PrintJob.execute" href="#apexofficeprint.printjob.PrintJob.execute">PrintJob.execute()</a></code></p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Response</code></dt>
<dd><code>Response</code>-object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def execute_async(self) -&gt; Response:
    &#34;&#34;&#34;Async version of `PrintJob.execute`

    Returns:
        Response: `Response`-object
    &#34;&#34;&#34;
    self.server._raise_if_unreachable()
    return PrintJob._handle_response(
        await asyncio.get_event_loop().run_in_executor(
            None, partial(
                requests.post,
                self.server.url,
                proxies=self.server.config.proxies if self.server.config is not None else None,
                json=self.as_dict
            )
        )
    )</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="apexofficeprint" href="index.html">apexofficeprint</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="apexofficeprint.printjob.PrintJob" href="#apexofficeprint.printjob.PrintJob">PrintJob</a></code></h4>
<ul class="">
<li><code><a title="apexofficeprint.printjob.PrintJob.as_dict" href="#apexofficeprint.printjob.PrintJob.as_dict">as_dict</a></code></li>
<li><code><a title="apexofficeprint.printjob.PrintJob.execute" href="#apexofficeprint.printjob.PrintJob.execute">execute</a></code></li>
<li><code><a title="apexofficeprint.printjob.PrintJob.execute_async" href="#apexofficeprint.printjob.PrintJob.execute_async">execute_async</a></code></li>
<li><code><a title="apexofficeprint.printjob.PrintJob.execute_full_json" href="#apexofficeprint.printjob.PrintJob.execute_full_json">execute_full_json</a></code></li>
<li><code><a title="apexofficeprint.printjob.PrintJob.execute_full_json_async" href="#apexofficeprint.printjob.PrintJob.execute_full_json_async">execute_full_json_async</a></code></li>
<li><code><a title="apexofficeprint.printjob.PrintJob.json" href="#apexofficeprint.printjob.PrintJob.json">json</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>