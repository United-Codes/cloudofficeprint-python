<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>apexofficeprint.elements.charts API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>apexofficeprint.elements.charts</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from typing import Any, Dict, Iterable, List, Tuple, FrozenSet, Union
from abc import ABC, abstractmethod
from .elements import Element


class ChartTextStyle:
    &#34;&#34;&#34;Class for defining the styling of the text for a chart.&#34;&#34;&#34;
    def __init__(self,
                 italic: bool = None,
                 bold: bool = None,
                 color: str = None,
                 font: str = None):
        &#34;&#34;&#34;
        Args:
            italic (bool, optional): Whether or not the text should be in italic. Defaults to None.
            bold (bool, optional): Whether or not the text should be in bold. Defaults to None.
            color (str, optional): The color of the text. Defaults to None.
            font (str, optional): The font of the text. Defaults to None.
        &#34;&#34;&#34;
        self.italic: bool = italic
        self.bold: bool = bold
        self.color: str = color
        self.font: str = font

    @property
    def as_dict(self) -&gt; Dict:
        &#34;&#34;&#34;The dict representation of this ChartTextStyle object.

        Returns:
            Dict: dict representation of this ChartTextStyle object
        &#34;&#34;&#34;
        result = {}

        if self.italic is not None:
            result[&#34;italic&#34;] = self.italic
        if self.bold is not None:
            result[&#34;bold&#34;] = self.bold
        if self.color is not None:
            result[&#34;color&#34;] = self.color
        if self.font is not None:
            result[&#34;font&#34;] = self.font

        return result


class ChartDateOptions:
    &#34;&#34;&#34;Class for defining the date options for a chart.&#34;&#34;&#34;
    def __init__(self,
                 format: str = None,
                 code: str = None,
                 unit: str = None,
                 step: Union[int, str] = None):
        &#34;&#34;&#34;
        Args:
            format (str, optional): The format to display the date on the chart&#39;s axis (e.g. unix). Defaults to None.
            code (str, optional): The code for the date (e.g. dd/mm/yyyy). Defaults to None.
            unit (str, optional): The unit to be used for spacing the axis values (e.g. months). Defaults to None.
            step (Union[int, str], optional): How many of the above unit should be used for spacing the axis values (automatic if undefined).
                This option is not supported in LibreOffice. Defaults to None.
        &#34;&#34;&#34;
        self.format: str = format
        self.code: str = code
        self.unit: str = unit
        self.step: Union[int, str] = step

    @property
    def as_dict(self) -&gt; Dict:
        &#34;&#34;&#34;The dict representation for this ChartDateOptions object.

        Returns:
            Dict: dict representation for this ChartDateOptions object
        &#34;&#34;&#34;
        result = {}

        if self.format is not None:
            result[&#34;format&#34;] = self.format
        if self.code is not None:
            result[&#34;code&#34;] = self.code
        if self.unit is not None:
            result[&#34;unit&#34;] = self.unit
        if self.step is not None:
            result[&#34;step&#34;] = self.step

        return result


class ChartAxisOptions:
    &#34;&#34;&#34;Class for defining the axis options for a chart.&#34;&#34;&#34;
    def __init__(self,
                 orientation: str = None,
                 min: Union[int, float] = None,
                 max: Union[int, float] = None,
                 date: ChartDateOptions = None,
                 title: str = None,
                 values: bool = None,
                 values_style: ChartTextStyle = None,
                 title_style: ChartTextStyle = None,
                 title_rotation: int = None,
                 major_grid_lines: bool = None,
                 major_unit: Union[int, float] = None,
                 minor_grid_lines: bool = None,
                 minor_unit: Union[int, float] = None,
                 formatCode: str = None):
        &#34;&#34;&#34;
        Args:
            orientation (str, optional): The orientation of the axis, &#39;minMax&#39; or &#39;maxMin&#39;. Defaults to None.
            min (Union[int, float], optional): Minimum of the axis. Defaults to None.
            max (Union[int, float], optional): Maximum of the axis. Defaults to None.
            date (ChartDateOptions, optional): Date options, only for stock charts. Defaults to None.
            title (str, optional): Title of the axis. Defaults to None.
            values (bool, optional): Whether or not to show the values on the axis. Defaults to None.
            values_style (ChartTextStyle, optional): Styling for the values. Defaults to None.
            title_style (ChartTextStyle, optional): Styling for the title. Defaults to None.
            title_rotation (int, optional): Title rotation in degrees, clockwise from horizontal axis. Defaults to None.
            major_grid_lines (bool, optional): Whether or not to show the major grid lines. Defaults to None.
            major_unit (Union[int, float], optional): Automatic when undefined, spacing between major grid lines and axis values. Defaults to None.
            minor_grid_lines (bool, optional): Whether or not to show the minor grid lines. Defaults to None.
            minor_unit (Union[int, float], optional): Automatic when undefined, spacing between minor grid lines and axis values. Defaults to None.
            formatCode (str, optional): Format code for axis data, &#34;General&#34;, &#34;Number&#34; ... Defaults to None.
        &#34;&#34;&#34;
        self.orientation: str = orientation
        self.min: Union[int, float] = min
        self.max: Union[int, float] = max
        self.date: ChartDateOptions = date
        self.title: str = title
        self.values: bool = values
        self.values_style: ChartTextStyle = values_style
        self.title_style: ChartTextStyle = title_style
        self.title_rotation: int = title_rotation
        self.major_grid_lines: bool = major_grid_lines
        self.major_unit: Union[int, float] = major_unit
        self.minor_grid_lines: bool = minor_grid_lines
        self.minor_unit: Union[int, float] = minor_unit
        self.format_code: str = formatCode

    @property
    def as_dict(self) -&gt; Dict:
        &#34;&#34;&#34;The dict representation of these chart axis options.

        Returns:
            Dict: dict representation of these chart axis options
        &#34;&#34;&#34;
        result = {}

        if self.orientation is not None:
            result[&#34;orientation&#34;] = self.orientation
        if self.min is not None:
            result[&#34;min&#34;] = self.min
        if self.max is not None:
            result[&#34;max&#34;] = self.max
        if self.date is not None:
            result[&#34;type&#34;] = &#34;date&#34;
            result[&#34;date&#34;] = self.date.as_dict
        if self.title is not None:
            result[&#34;title&#34;] = self.title
        if self.values is not None:
            result[&#34;showValues&#34;] = self.values
        if self.values_style is not None:
            result[&#34;valuesStyle&#34;] = self.values_style.as_dict
        if self.title_style is not None:
            result[&#34;titleStyle&#34;] = self.title_style.as_dict
        if self.title_rotation is not None:
            result[&#34;titleRotation&#34;] = self.title_rotation
        if self.major_grid_lines is not None:
            result[&#34;majorGridlines&#34;] = self.major_grid_lines
        if self.major_unit is not None:
            result[&#34;majorUnit&#34;] = self.major_unit
        if self.minor_grid_lines is not None:
            result[&#34;minorGridlines&#34;] = self.minor_grid_lines
        if self.minor_unit is not None:
            result[&#34;minorUnit&#34;] = self.minor_unit
        if self.format_code is not None:
            result[&#34;formatCode&#34;] = self.format_code

        return result


class ChartOptions():
    &#34;&#34;&#34;Options object for a `Chart`.&#34;&#34;&#34;
    def __init__(self,
                 x_axis: ChartAxisOptions=None,
                 y_axis: ChartAxisOptions=None,
                 y2_axis: ChartAxisOptions=None,
                 width: int=None,
                 height: int=None,
                 border: bool=None,
                 rounded_corners: bool=None,
                 background_color: str=None,
                 background_opacity: int=None,
                 title: str=None,
                 title_style: ChartTextStyle=None,
                 grid: bool=None):
        &#34;&#34;&#34;
        Args:
            x_axis (ChartAxisOptions, optional): The options for the x-axis. Defaults to None.
            y_axis (ChartAxisOptions, optional): The options for the y-axis. Note: date options for the y axis are ignored by the AOP server. Defaults to None.
            y2_axis (ChartAxisOptions, optional): The options for the y2-axis. Note: date options for the y2 axis are ignored by the AOP server. Defaults to None.
            width (int, optional): Width of the chart. Defaults to None.
            height (int, optional): Height of the chart. Defaults to None.
            border (bool, optional): Whether or not the chart should have a border. Defaults to None.
            rounded_corners (bool, optional): Whether or not the chart should have rounded corners. Note: displaying rounded corners is not supported by LibreOffice. Defaults to None.
            background_color (str, optional): Background color for the entire chart. Defaults to None.
            background_opacity (int, optional): The opacity of the background color for the entire chart.
                Note: backgroundOpacity is ignored if backgroundColor is not specified or if backgroundColor is specified in a color space which includes an alpha channel (e.g. rgba(0,191,255,0.5)).
                In the latter case, the alpha channel in backgroundColor is used. Defaults to None.
            title (str, optional): The title of the chart. Defaults to None.
            title_style (ChartTextStyle, optional): The styling for the title of the chart. Defaults to None.
            grid (bool, optional): Whether or not the chart should have a grid. Defaults to None.
        &#34;&#34;&#34;
        self._legend_options: dict = None
        self._data_labels_options: dict = None

        self.x_axis: ChartAxisOptions = x_axis
        self.y_axis: ChartAxisOptions = y_axis
        self.y2_axis: ChartAxisOptions = y2_axis
        self.width: int = width
        self.height: int = height
        self.border: bool = border
        self.rounded_corners: bool = rounded_corners
        self.background_color: str = background_color
        self.background_opacity: int = background_opacity
        self.title: str = title
        self.title_style: ChartTextStyle = title_style
        self.grid: bool = grid

    def set_legend(self, position: str = &#39;r&#39;, style: ChartTextStyle = None):
        &#34;&#34;&#34;Setter for the legend of the chart.

        Args:
            position (str, optional): Position of the legend.  &#39;l&#39;: left, &#39;r&#39;: right, &#39;b&#39;: bottom, &#39;t&#39;: top. Defaults to &#39;r&#39;.
            style (ChartTextStyle, optional): The styling for the text of the legend. Defaults to None.
        &#34;&#34;&#34;
        self._legend_options = {
            &#34;showLegend&#34;: True
        }
        self._legend_options[&#34;position&#34;] = position
        if style is not None:
            self._legend_options[&#34;style&#34;] = style.as_dict

    def remove_legend(self):
        &#34;&#34;&#34;Setter for removing the legend from the chart.&#34;&#34;&#34;
        self._legend_options = None

    def set_data_labels(self,
                        separator: str = None,
                        series_name: bool = None,
                        category_name: bool = None,
                        legend_key: bool = None,
                        value: bool = None,
                        percentage: bool = None,
                        position: str = None):
        &#34;&#34;&#34;Setter for the data labels for the chart.

        Args:
            separator (str, optional): Seperator : can be either false or anything else for example \n or \t or ; or (, if false). Defaults to None.
            series_name (bool, optional): Whether or not to include the series name in the data label. Defaults to None.
            category_name (bool, optional): Whether or not to include the series category name in the data label. Defaults to None.
            legend_key (bool, optional): Whether or not to include the legend key (i.e. the color of the series) in the data label. Defaults to None.
            value (bool, optional): Whether or not to include the actual value in the data label. Defaults to None.
            percentage (bool, optional): Whether or not to include the percentage in the data label. By default True for pie/pie3d and doughnut. Defaults to None.
            position (str, optional): The position of the data label.
                Can be &#39;center&#39;, &#39;left&#39;, &#39;right&#39;, &#39;above&#39;, &#39;below&#39;, &#39;insideBase&#39;, &#39;bestFit&#39;, &#39;outsideEnd&#39;, &#39;insideEnd&#39;.
                Note that not all options might be available for specific charts. Defaults to None.
        &#34;&#34;&#34;
        self._data_labels_options = {
            &#34;showDataLabels&#34;: True
        }

        if separator is not None:
            self._data_labels_options[&#34;separator&#34;] = separator
        if series_name is not None:
            self._data_labels_options[&#34;showSeriesName&#34;] = series_name
        if category_name is not None:
            self._data_labels_options[&#34;showCategoryName&#34;] = category_name
        if legend_key is not None:
            self._data_labels_options[&#34;showLegendKey&#34;] = legend_key
        if value is not None:
            self._data_labels_options[&#34;showValue&#34;] = value
        if percentage is not None:
            self._data_labels_options[&#34;showPercentage&#34;] = percentage
        if position is not None:
            self._data_labels_options[&#34;position&#34;] = position

    def remove_data_labels(self):
        &#34;&#34;&#34;Setter to remove the data labels from the chart.&#34;&#34;&#34;
        self._data_labels_options = None

    @property
    def as_dict(self) -&gt; Dict:
        &#34;&#34;&#34;The dict representation of this ChartOptions object.

        Returns:
            Dict: dict representation of this ChartOptions object
        &#34;&#34;&#34;
        result = {
            &#34;axis&#34;: {
            }
        }

        if self.x_axis is not None:
            result[&#39;axis&#39;][&#39;x&#39;] = self.x_axis.as_dict
        if self.y_axis is not None:
            result[&#39;axis&#39;][&#39;y&#39;] = self.y_axis.as_dict
        if self.y2_axis is not None:
            result[&#34;axis&#34;][&#34;y2&#34;] = self.y2_axis.as_dict
        if self.width is not None:
            result[&#34;width&#34;] = self.width
        if self.height is not None:
            result[&#34;height&#34;] = self.height
        if self.border is not None:
            result[&#34;border&#34;] = self.border
        if self.rounded_corners is not None:
            result[&#34;roundedCorners&#34;] = self.rounded_corners
        if self.background_color is not None:
            result[&#34;backgroundColor&#34;] = self.background_color
        if self.background_opacity is not None:
            result[&#34;backgroundOpacity&#34;] = self.background_opacity
        if self.title is not None:
            result[&#34;title&#34;] = self.title
        if self.title_style is not None:
            result[&#34;titleStyle&#34;] = self.title_style.as_dict
        if self.grid is not None:
            result[&#34;grid&#34;] = self.grid
        if self._legend_options is not None:
            result[&#34;legend&#34;] = self._legend_options
        if self._data_labels_options is not None:
            result[&#34;dataLabels&#34;] = self._data_labels_options

        return result


class Series(ABC):
    &#34;&#34;&#34;Abstract base class for a series.&#34;&#34;&#34;
    def __init__(self, name: str = None):
        self.name: str = name

    @property
    @abstractmethod
    def data(self):
        &#34;&#34;&#34;Get the data used in the series. E.g. x-values, y-values, ...&#34;&#34;&#34;
        pass

    @property
    def as_dict(self) -&gt; Dict:
        &#34;&#34;&#34;The dict representation of this Series object.

        Returns:
            Dict: dict representation of this Series object
        &#34;&#34;&#34;
        result = {
            &#34;data&#34;: self.data
        }

        if self.name is not None:
            result[&#34;name&#34;] = self.name

        return result


class XYSeries(Series):
    &#34;&#34;&#34;A series for the case where the data consists of x-values and y-values.&#34;&#34;&#34;
    def __init__(self,
                 x: Iterable[Union[int, float, str]],
                 y: Iterable[Union[int, float]],
                 name: str = None,
                 color: str = None):
        &#34;&#34;&#34;
        Args:
            x (Iterable[Union[int, float, str]]): The data for the x-axis.
            y (Iterable[Union[int, float]]): The data for the y-axis.
            name (str, optional): The name of the series. Defaults to None.
            color (str, optional): The color in which the series should be shown on a chart.
                Can be html/css colors or hex values. Defaults to None.
        &#34;&#34;&#34;
        super().__init__(name)
        self.x: Iterable[Union[int, float, str]] = x
        self.y: Iterable[Union[int, float]] = y
        self.color: str = color

    @property
    def data(self):
        return [{
            &#34;x&#34;: x,
            &#34;y&#34;: y
        } for x, y in zip(self.x, self.y)]

    @classmethod
    def from_dataframe(cls, data: &#39;pandas.DataFrame&#39;, name: str = None) -&gt; &#39;XYSeries&#39;:
        &#34;&#34;&#34;Generate an XYSeries from a [Pandas dataframe](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html).

        Args:
            data (pandas.DataFrame): Pandas dataframe containing the data for the x- and y-axis.
            name (str): The name for the series.

        Returns:
            XYSeries: XYSeries generated from a Pandas dataframe
        &#34;&#34;&#34;
        x = list(data.iloc[:, 0])
        y = list(data.iloc[:, 1])
        return cls(x, y, name=name)
    
    @property
    def as_dict(self) -&gt; Dict:
        result = super().as_dict

        if self.color is not None:
            result[&#39;color&#39;] = self.color
        
        return result


class PieSeries(XYSeries):
    &#34;&#34;&#34;A series for pie charts.&#34;&#34;&#34;
    def __init__(self,
                 x: Iterable[Union[int, float, str]],
                 y: Iterable[Union[int, float]],
                 name: str = None,
                 colors: Iterable[str] = None):
        &#34;&#34;&#34;
        Args:
            x (Iterable[Union[int, float, str]]): The data for the x-axis.
            y (Iterable[Union[int, float]]): The data for the y-axis.
            name (str, optional): The name of the series. Defaults to None.
            colors (Iterable[str], optional): Should be an iterable that contains the color for each specific pie slice.
                If no colors are specified, the document&#39;s theme color is used.
                If some colors are specified, but not for all data points, random colors will fill the gaps.
                The value for non-specified colors must be None.
                Warning: this is not the same as self.color of XYSeries, which is the color for the entire series, but this is not applicable to PieSeries.
                Defaults to None.
        &#34;&#34;&#34;
        super().__init__(x, y, name)
        self.colors = colors

    @property
    def as_dict(self) -&gt; Dict:
        result = super().as_dict

        if self.colors is not None:
            # Add the color for each slice to &#39;data&#39;
            for i in range(len(tuple(self.colors))):
                if self.colors[i] is not None:
                    result[&#34;data&#34;][i][&#39;color&#39;] = self.colors[i]

        return result


class AreaSeries(XYSeries):
    &#34;&#34;&#34;A series for an area chart.&#34;&#34;&#34;
    def __init__(self,
                 x: Iterable[Union[int, float, str]],
                 y: Iterable[Union[int, float]],
                 name: str = None,
                 color: str = None,
                 opacity: float = None):
        &#34;&#34;&#34;
        Args:
            x (Iterable[Union[int, float, str]]): The data for the x-axis.
            y (Iterable[Union[int, float]]): The data for the y-axis.
            name (str, optional): The name of the series. Defaults to None.
            color (str, optional): The color in which the series should be shown on a chart.
                Can be html/css colors or hex values. Defaults to None.
            opacity (float, optional): The opacity for the color of the series. Defaults to None.
        &#34;&#34;&#34;
        super().__init__(x, y, name, color)
        self.opacity: float = opacity

    @property
    def as_dict(self) -&gt; Dict:
        result = super().as_dict

        if self.opacity is not None:
            result[&#34;opacity&#34;] = self.opacity

        return result


class LineSeries(XYSeries):
    &#34;&#34;&#34;A series for a line chart.&#34;&#34;&#34;
    def __init__(self,
                 x: Iterable[Union[int, float, str]],
                 y: Iterable[Union[int, float]],
                 name: str = None,
                 smooth: bool = None,
                 symbol: str = None,
                 symbol_size: Union[str, int] = None,
                 color: str = None,
                 line_width: str = None,
                 line_style: str = None):
        &#34;&#34;&#34;
        Args:
            x (Iterable[Union[int, float, str]]): The data for the x-axis.
            y (Iterable[Union[int, float]]): The data for the y-axis.
            name (str, optional): The name of the series. Defaults to None.
            smooth (bool, optional): Whether or not the corners of the angles formed in the data-points are smoothened. Defaults to None.
            symbol (str, optional): Symbol representing the datapoints. Can be square (default), diamond or triangle. Defaults to None.
            symbol_size (Union[str, int], optional): Size of the symbol representing the data-points in (in em, pt, px, cm or in), by default: automatic. Defaults to None.
            color (str, optional): The color in which the series should be shown on a chart.
                Can be html/css colors or hex values. Defaults to None.
            line_width (str, optional): Thickness of the connecting line in em, pt, px, cm or in. Defaults to None.
            line_style (str, optional): Style of the line. Supported options can be found online on the [AOP documentation](https://www.apexofficeprint.com/docs/#line). Defaults to None.
        &#34;&#34;&#34;
        super().__init__(x, y, name, color)
        self.smooth: bool = smooth
        self.symbol: str = symbol
        self.symbol_size: Union[str, int] = symbol_size
        self.line_width: str = line_width
        self.line_style: str = line_style

    @property
    def as_dict(self) -&gt; Dict:
        result = super().as_dict

        if self.smooth is not None:
            result[&#34;smooth&#34;] = self.smooth
        if self.symbol is not None:
            result[&#34;symbol&#34;] = self.symbol
        if self.symbol_size is not None:
            result[&#34;symbolSize&#34;] = self.symbol_size
        if self.line_width is not None:
            result[&#34;lineWidth&#34;] = self.line_width
        if self.line_style is not None:
            result[&#34;lineStyle&#34;] = self.line_style
        
        return result


class BubbleSeries(XYSeries):
    &#34;&#34;&#34;A series for a bubble chart.&#34;&#34;&#34;
    def __init__(self,
                 x: Iterable[Union[int, float, str]],
                 y: Iterable[Union[int, float]],
                 sizes: Iterable[Union[int, float]],
                 name: str = None,
                 color: str = None):
        &#34;&#34;&#34;
        Args:
            x (Iterable[Union[int, float, str]]): The data for the x-axis.
            y (Iterable[Union[int, float]]): The data for the y-axis.
            sizes (Iterable[Union[int, float]]): An iterable containing the sizes for each bubble of the series.
            name (str, optional): The name of the series. Defaults to None.
            color (str, optional): The color in which the series should be shown on a chart.
                Can be html/css colors or hex values. Defaults to None.
        &#34;&#34;&#34;
        super().__init__(x, y, name, color)
        self.sizes: Iterable[Union[int, float]] = sizes

    @property
    def data(self) -&gt; List[Dict[str, Any]]:
        return [{
            &#34;x&#34;: x,
            &#34;y&#34;: y,
            &#34;size&#34;: size
        } for x, y, size in zip(self.x, self.y, self.sizes)]

    @classmethod
    def from_dataframe(cls, data: &#39;pandas.DataFrame&#39;, name: str = None) -&gt; &#39;BubbleSeries&#39;:
        &#34;&#34;&#34;Generate a BubbleSeries from a [Pandas dataframe](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html).

        Args:
            data (pandas.DataFrame): Pandas dataframe containing the data for the x- and y-axis and the sizes for the bubbles.
            name (str): The name for the series.

        Returns:
            BubbleSeries: BubbleSeries generated from a Pandas dataframe
        &#34;&#34;&#34;
        x = list(data.iloc[:, 0])
        y = list(data.iloc[:, 1])
        sizes = list(data.iloc[:, 2])
        return cls(x, y, sizes, name=name)


class StockSeries(Series):
    &#34;&#34;&#34;A series for candlestick charts.&#34;&#34;&#34;
    def __init__(self,
                 x: Iterable[Union[int, float, str]],
                 high: Iterable[Union[int, float]],
                 low: Iterable[Union[int, float]],
                 close: Iterable[Union[int, float]],
                 open_: Iterable[Union[int, float]] = None,
                 volume: Iterable[Union[int, float]] = None,
                 name: str = None):
        &#34;&#34;&#34;
        Args:
            x (Iterable[Union[int, float, str]]): The data for the x-axis.
            high (Iterable[Union[int, float]]): The data for the hight prices.
            low (Iterable[Union[int, float]]): The data for the low prices.
            close (Iterable[Union[int, float]]): The data for the closing prices.
            open_ (Iterable[Union[int, float]], optional): The data for the opening prices. Defaults to None.
            volume (Iterable[Union[int, float]], optional): The data for the volumes. Defaults to None.
            name (str, optional): The name of the series. Defaults to None.
        &#34;&#34;&#34;
        super().__init__(name)
        self.x: Iterable[Union[int, float, str]] = x
        self.high: Iterable[Union[int, float]] = high
        self.low: Iterable[Union[int, float]] = low
        self.close: Iterable[Union[int, float]] = close
        # open argument gets a trailing _ because open() is a built-in function
        self.open: Iterable[Union[int, float]] = open_
        self.volume: Iterable[Union[int, float]] = volume

    @property
    def data(self):
        result = [{
            &#34;x&#34;: x,
            &#34;high&#34;: high,
            &#34;low&#34;: low,
            &#34;close&#34;: close
        } for x, high, low, close in zip(self.x, self.high, self.low, self.close)]

        for i in range(len(result)):
            if self.open is not None:
                result[i][&#34;open&#34;] = self.open[i]
            if self.volume is not None:
                result[i][&#34;volume&#34;] = self.volume[i]

        return result

    @classmethod
    def from_dataframe(cls, data: &#39;pandas.DataFrame&#39;, name: str = None) -&gt; &#39;StockSeries&#39;:
        &#34;&#34;&#34;Generate a StockSeries from a [Pandas dataframe](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html).

        Args:
            data (pandas.DataFrame): Pandas dataframe containing the x, high, low and possibly volume and open data.
            name (str): The name for the series.

        Returns:
            StockSeries: StockSeries generated from a Pandas dataframe
        &#34;&#34;&#34;
        x = list(data.iloc[:, 0])
        high = list(data[&#34;high&#34;])
        low = list(data[&#34;low&#34;])
        close = list(data[&#34;close&#34;])
        # volume and open are optional
        try:
            open_ = list(data[&#34;open&#34;])
        except KeyError:
            open_ = None
        try:
            volume = list(data[&#34;volume&#34;])
        except KeyError:
            volume = None
        return cls(x, high, low, close, open_, volume, name=name)


# better to have a series for every possible chart for future-proofing, in case their options diverge later
BarSeries = BarStackedSeries = BarStackedPercentSeries = ColumnSeries = ColumnStackedSeries = ColumnStackedPercentSeries = ScatterSeries = XYSeries
RadarSeries = LineSeries


class Chart(Element, ABC):
    &#34;&#34;&#34;The abstract base class for a chart.&#34;&#34;&#34;
    def __init__(self, name: str, options: Union[ChartOptions, dict] = None):
        &#34;&#34;&#34;
        Args:
            name (str): The name of the chart.
            options (Union[ChartOptions, dict], optional): The options for the chart. Defaults to None.
        &#34;&#34;&#34;
        Element.__init__(self, name)
        self.options: Union[ChartOptions, dict] = options

    @property
    @abstractmethod
    def as_dict(self) -&gt; Dict:
        pass

    def _get_dict(self, updates: dict) -&gt; Dict:
        &#34;&#34;&#34;Update the given dict with the chart options and return the result.

        Args:
            updates (dict): the dict that needs to be updated with the chart options

        Returns:
            Dict: the input dict, updated with the chart options
        &#34;&#34;&#34;
        result = {}
        if self.options is not None:
            result[&#34;options&#34;] = self.options if isinstance(
                self.options, dict) else self.options.as_dict
        result.update(updates)
        return {self.name: result}

    @property
    def available_tags(self) -&gt; FrozenSet[str]:
        return frozenset({&#34;{$&#34; + self.name + &#34;}&#34;})


class LineChart(Chart):
    &#34;&#34;&#34;Class for a line chart&#34;&#34;&#34;
    def __init__(self, name: str, lines: Tuple[Union[LineSeries, XYSeries]], options: ChartOptions = None):
        &#34;&#34;&#34;
        Args:
            name (str): The name of the chart.
            lines (Tuple[Union[LineSeries, XYSeries]]): Iterable of line series.
            options (Union[ChartOptions, dict], optional): The options for the chart. Defaults to None.
        &#34;&#34;&#34;
        super().__init__(name, options)
        self.lines: Tuple[Union[LineSeries, XYSeries]] = lines

    @property
    def as_dict(self) -&gt; Dict:
        return self._get_dict({
            &#34;lines&#34;: [line.as_dict for line in self.lines],
            &#34;type&#34;: &#34;line&#34;
        })


class BarChart(Chart):
    &#34;&#34;&#34;Class for a bar chart&#34;&#34;&#34;
    def __init__(self, name: str, bars: Tuple[Union[BarSeries, XYSeries]], options: ChartOptions = None):
        &#34;&#34;&#34;
        Args:
            name (str): The name of the chart.
            bars (Tuple[Union[BarSeries, XYSeries]]): Iterable of bar series.
            options (Union[ChartOptions, dict], optional): The options for the chart. Defaults to None.
        &#34;&#34;&#34;
        super().__init__(name, options)
        self.bars: Tuple[Union[BarSeries, XYSeries]] = bars

    @property
    def as_dict(self) -&gt; Dict:
        return self._get_dict({
            &#34;bars&#34;: [bar.as_dict for bar in self.bars],
            &#34;type&#34;: &#34;bar&#34;
        })


class BarStackedChart(Chart):
    &#34;&#34;&#34;Class for a stacked bar chart&#34;&#34;&#34;
    def __init__(self, name: str, bars: Tuple[Union[BarStackedSeries, XYSeries]], options: ChartOptions = None):
        &#34;&#34;&#34;
        Args:
            name (str): The name of the chart.
            bars (Tuple[Union[BarSeries, XYSeries]]): Iterable of stacked bar series.
            options (Union[ChartOptions, dict], optional): The options for the chart. Defaults to None.
        &#34;&#34;&#34;
        super().__init__(name, options)
        self.bars: Tuple[Union[BarStackedSeries, XYSeries]] = bars

    @property
    def as_dict(self) -&gt; Dict:
        return self._get_dict({
            &#34;bars&#34;: [bar.as_dict for bar in self.bars],
            &#34;type&#34;: &#34;barStacked&#34;
        })


class BarStackedPercentChart(Chart):
    &#34;&#34;&#34;Class for a stacked bar chart with the x-axis expressed in percentage&#34;&#34;&#34;
    def __init__(self, name: str, bars: Tuple[Union[BarStackedPercentSeries, XYSeries]], options: ChartOptions = None):
        &#34;&#34;&#34;
        Args:
            name (str): The name of the chart.
            bars (Tuple[Union[BarSeries, XYSeries]]): Iterable of stacked bar (percentage) series.
            options (Union[ChartOptions, dict], optional): The options for the chart. Defaults to None.
        &#34;&#34;&#34;
        super().__init__(name, options)
        self.bars: Tuple[Union[BarStackedPercentSeries, XYSeries]] = bars

    @property
    def as_dict(self) -&gt; Dict:
        return self._get_dict({
            &#34;bars&#34;: [bar.as_dict for bar in self.bars],
            &#34;type&#34;: &#34;barStackedPercent&#34;
        })


class ColumnChart(Chart):
    &#34;&#34;&#34;Class for a column chart&#34;&#34;&#34;
    def __init__(self, name: str, columns: Tuple[Union[ColumnSeries, XYSeries]], options: ChartOptions = None):
        &#34;&#34;&#34;
        Args:
            name (str): The name of the chart.
            columns (Tuple[Union[ColumnSeries, XYSeries]]): Iterable of column series.
            options (Union[ChartOptions, dict], optional): The options for the chart. Defaults to None.
        &#34;&#34;&#34;
        super().__init__(name, options)
        self.columns: Tuple[Union[ColumnSeries, XYSeries]] = columns

    @property
    def as_dict(self) -&gt; Dict:
        return self._get_dict({
            &#34;columns&#34;: [col.as_dict for col in self.columns],
            &#34;type&#34;: &#34;column&#34;
        })


class ColumnStackedChart(Chart):
    &#34;&#34;&#34;Class for a stacked column chart&#34;&#34;&#34;
    def __init__(self, name: str, columns: Tuple[Union[ColumnStackedSeries, XYSeries]], options: ChartOptions = None):
        &#34;&#34;&#34;
        Args:
            name (str): The name of the chart.
            columns (Tuple[Union[ColumnSeries, XYSeries]]): Iterable of stacked column series.
            options (Union[ChartOptions, dict], optional): The options for the chart. Defaults to None.
        &#34;&#34;&#34;
        super().__init__(name, options)
        self.columns: Tuple[Union[ColumnStackedSeries, XYSeries]] = columns

    @property
    def as_dict(self) -&gt; Dict:
        return self._get_dict({
            &#34;columns&#34;: [col.as_dict for col in self.columns],
            &#34;type&#34;: &#34;columnStacked&#34;
        })


class ColumnStackedPercentChart(Chart):
    &#34;&#34;&#34;Class for a stacked column chart with the x-axis expressed in percentage&#34;&#34;&#34;
    def __init__(self, name: str, columns: Tuple[Union[ColumnStackedPercentSeries, XYSeries]], options: ChartOptions = None):
        &#34;&#34;&#34;
        Args:
            name (str): The name of the chart.
            columns (Tuple[Union[ColumnSeries, XYSeries]]): Iterable of stacked column (percentage) series.
            options (Union[ChartOptions, dict], optional): The options for the chart. Defaults to None.
        &#34;&#34;&#34;
        super().__init__(name, options)
        self.columns: Tuple[Union[ColumnStackedPercentSeries, XYSeries]] = columns

    @property
    def as_dict(self) -&gt; Dict:
        return self._get_dict({
            &#34;columns&#34;: [col.as_dict for col in self.columns],
            &#34;type&#34;: &#34;columnStackedPercent&#34;
        })


class PieChart(Chart):
    &#34;&#34;&#34;Class for a pie chart&#34;&#34;&#34;
    def __init__(self, name: str, pies: Tuple[Union[PieSeries, XYSeries]], options: ChartOptions = None):
        &#34;&#34;&#34;
        Args:
            name (str): The name of the chart.
            pies (Tuple[Union[PieSeries, XYSeries]]): Iterable of pie series.
            options (Union[ChartOptions, dict], optional): The options for the chart. Defaults to None.
        &#34;&#34;&#34;
        super().__init__(name, options)
        self.pies: Tuple[Union[PieSeries, XYSeries]] = pies

    @property
    def as_dict(self) -&gt; Dict:
        return self._get_dict({
            &#34;pies&#34;: [pie.as_dict for pie in self.pies],
            &#34;type&#34;: &#34;pie&#34;
        })


class Pie3DChart(Chart):
    &#34;&#34;&#34;Class for a 3D pie chart&#34;&#34;&#34;
    def __init__(self, name: str, pies: Tuple[Union[PieSeries, XYSeries]], options: ChartOptions = None):
        &#34;&#34;&#34;
        Args:
            name (str): The name of the chart.
            pies (Tuple[Union[PieSeries, XYSeries]]): Iterable of 3D pie series.
            options (Union[ChartOptions, dict], optional): The options for the chart. Defaults to None.
        &#34;&#34;&#34;
        super().__init__(name, options)
        self.pies: Tuple[Union[PieSeries, XYSeries]] = pies

    @property
    def as_dict(self) -&gt; Dict:
        return self._get_dict({
            &#34;pies&#34;: [pie.as_dict for pie in self.pies],
            &#34;type&#34;: &#34;pie3d&#34;
        })


class DoughnutChart(Chart):
    &#34;&#34;&#34;Class for a doughnut chart&#34;&#34;&#34;
    def __init__(self, name: str, doughnuts: Tuple[Union[PieSeries, XYSeries]], options: ChartOptions = None):
        &#34;&#34;&#34;
        Args:
            name (str): The name of the chart.
            doughnuts (Tuple[Union[PieSeries, XYSeries]]): Iterable of doughnut series.
            options (Union[ChartOptions, dict], optional): The options for the chart. Defaults to None.
        &#34;&#34;&#34;
        super().__init__(name, options)
        self.doughnuts: Tuple[Union[PieSeries, XYSeries]] = doughnuts

    @property
    def as_dict(self) -&gt; Dict:
        return self._get_dict({
            &#34;doughnuts&#34;: [nut.as_dict for nut in self.doughnuts],
            &#34;type&#34;: &#34;doughnut&#34;
        })


class RadarChart(Chart):
    &#34;&#34;&#34;Class for a radar chart&#34;&#34;&#34;
    def __init__(self, name: str, radars: Tuple[Union[RadarSeries, XYSeries]], options: ChartOptions = None):
        &#34;&#34;&#34;
        Args:
            name (str): The name of the chart.
            radars (Tuple[Union[RadarSeries, XYSeries]]): Iterable of radar series.
            options (Union[ChartOptions, dict], optional): The options for the chart. Defaults to None.
        &#34;&#34;&#34;
        super().__init__(name, options)
        self.radars: Tuple[Union[RadarSeries, XYSeries]] = radars

    @property
    def as_dict(self) -&gt; Dict:
        return self._get_dict({
            &#34;radars&#34;: [radar.as_dict for radar in self.radars],
            &#34;type&#34;: &#34;radar&#34;
        })


class AreaChart(Chart):
    &#34;&#34;&#34;Class for an area chart&#34;&#34;&#34;
    def __init__(self, name: str, areas: Tuple[Union[AreaSeries, XYSeries]], options: ChartOptions = None):
        &#34;&#34;&#34;
        Args:
            name (str): The name of the chart.
            areas (Tuple[Union[AreaSeries, XYSeries]]): Iterable of area series.
            options (Union[ChartOptions, dict], optional): The options for the chart. Defaults to None.
        &#34;&#34;&#34;
        super().__init__(name, options)
        self.areas: Tuple[Union[AreaSeries, XYSeries]] = areas

    @property
    def as_dict(self) -&gt; Dict:
        return self._get_dict({
            &#34;areas&#34;: [area.as_dict for area in self.areas],
            &#34;type&#34;: &#34;area&#34;
        })


class ScatterChart(Chart):
    &#34;&#34;&#34;Class for a scatter chart&#34;&#34;&#34;
    def __init__(self, name: str, scatters: Tuple[Union[ScatterSeries, XYSeries]], options: ChartOptions = None):
        &#34;&#34;&#34;
        Args:
            name (str): The name of the chart.
            scatters (Tuple[Union[ScatterSeries, XYSeries]]): Iterable of scatter series.
            options (Union[ChartOptions, dict], optional): The options for the chart. Defaults to None.
        &#34;&#34;&#34;
        super().__init__(name, options)
        self.scatters: Tuple[Union[ScatterSeries, XYSeries]] = scatters

    @property
    def as_dict(self) -&gt; Dict:
        return self._get_dict({
            &#34;scatters&#34;: [scatter.as_dict for scatter in self.scatters],
            &#34;type&#34;: &#34;scatter&#34;
        })


class BubbleChart(Chart):
    &#34;&#34;&#34;Class for a bubble chart&#34;&#34;&#34;
    def __init__(self, name: str, bubbles: Tuple[BubbleSeries], options: ChartOptions = None):
        &#34;&#34;&#34;
        Args:
            name (str): The name of the chart.
            bubbles (Tuple[BubbleSeries]): Iterable of bubble series.
            options (Union[ChartOptions, dict], optional): The options for the chart. Defaults to None.
        &#34;&#34;&#34;
        super().__init__(name, options)
        self.bubbles: Tuple[BubbleSeries] = bubbles

    @property
    def as_dict(self) -&gt; Dict:
        return self._get_dict({
            &#34;bubbles&#34;: [bub.as_dict for bub in self.bubbles],
            &#34;type&#34;: &#34;bubble&#34;
        })


class StockChart(Chart):
    &#34;&#34;&#34;Class for a candlestick chart&#34;&#34;&#34;
    def __init__(self, name: str, stocks: Tuple[StockSeries], options: ChartOptions = None):
        &#34;&#34;&#34;
        Args:
            name (str): The name of the chart.
            stocks (Tuple[StockSeries]): Iterable of stock series.
            options (Union[ChartOptions, dict], optional): The options for the chart. Defaults to None.
        &#34;&#34;&#34;
        super().__init__(name, options)
        self.stocks: Tuple[StockSeries] = stocks

    @property
    def as_dict(self) -&gt; Dict:
        return self._get_dict({
            &#34;stocks&#34;: [stock.as_dict for stock in self.stocks],
            &#34;type&#34;: &#34;stock&#34;
        })


def _replace_key_recursive(obj: Dict, old_key: str, new_key: str) -&gt; Dict:
    &#34;&#34;&#34;Recursively replace the keys in a (possibly) nested dictionary with a new name.

    Args:
        obj (Dict): input dictionary
        old_key (str): old name of the key
        new_key (str): new name of the key

    Returns:
        Dict: input dictionary with the old key name replaced by the new key name
    &#34;&#34;&#34;
    for key, value in obj.items():
        if isinstance(value, dict):
            obj[key] = _replace_key_recursive(value, old_key, new_key)
        elif isinstance(value, list):
            for i in range(len(value)):
                value[i] = _replace_key_recursive(value[i], old_key, new_key)
    if old_key in obj:
        obj[new_key] = obj.pop(old_key)
    return obj


class CombinedChart(Chart):
    &#34;&#34;&#34;Class for a combined chart. It is possible to combine more than 2 types of chart but there can only be two value axes.&#34;&#34;&#34;
    def __init__(self, name: str, charts: Iterable[Chart], secondaryCharts: Iterable[Chart] = None, options: ChartOptions = None):
        &#34;&#34;&#34;
        Args:
            name (str): The name of the chart.
            charts (Iterable[Chart]): Charts for the first y-axis.
            secondaryCharts (Iterable[Chart], optional): Charts for the secondary y-axis. Defaults to None.
            options (ChartOptions, optional): The options for the chart. If not defined, the chartoptions of the first chart that has options will be used. Defaults to None.
        &#34;&#34;&#34;
        if options is None:
            all_options = [chart.options.as_dict for chart in (
                tuple(charts) + tuple(secondaryCharts)) if chart.options is not None]
            options = {}
            # use reversed() to give the first charts precedence (they overwrite the others)
            for options in reversed(all_options):
                options.update(options)

        super().__init__(name, options)
        self.charts: Iterable[Chart] = charts
        self.secondaryCharts: Iterable[Chart] = secondaryCharts

    def _get_modified_chart_dicts(self) -&gt; List[Dict]:
        &#34;&#34;&#34;Remove the chart options from all charts in this combined chart object.
        Replace the y-axis with the y2-axis for the secondary charts.
        Add the dict representation for each chart to a list and return that list.

        Returns:
            List[Dict]: list containing the dict representation for each chart, after processing
        &#34;&#34;&#34;
        primary_list = list(self.charts)
        secondary_list = list(self.secondaryCharts)
        dict_list = []
        for chart in primary_list:
            chart_dict_full = chart.as_dict
            chart_dict = chart_dict_full[chart.name]
            chart_dict.pop(&#34;options&#34;, None)
            dict_list.append(chart_dict)
        for chart in secondary_list:
            chart_dict_full = chart.as_dict
            chart_dict = chart_dict_full[chart.name]
            chart_dict.pop(&#34;options&#34;, None)
            dict_list.append(_replace_key_recursive(chart_dict, &#34;y&#34;, &#34;y2&#34;))
        return dict_list

    @property
    def as_dict(self) -&gt; Dict:
        return self._get_dict({
            &#34;type&#34;: &#34;multiple&#34;,
            &#34;multiples&#34;: self._get_modified_chart_dicts()
        })</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="apexofficeprint.elements.charts.AreaChart"><code class="flex name class">
<span>class <span class="ident">AreaChart</span></span>
<span>(</span><span>name: str, areas: Tuple[Union[<a title="apexofficeprint.elements.charts.AreaSeries" href="#apexofficeprint.elements.charts.AreaSeries">AreaSeries</a>, <a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a>]], options: <a title="apexofficeprint.elements.charts.ChartOptions" href="#apexofficeprint.elements.charts.ChartOptions">ChartOptions</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class for an area chart</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the chart.</dd>
<dt><strong><code>areas</code></strong> :&ensp;<code>Tuple[Union[<a title="apexofficeprint.elements.charts.AreaSeries" href="#apexofficeprint.elements.charts.AreaSeries">AreaSeries</a>, <a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a>]]</code></dt>
<dd>Iterable of area series.</dd>
<dt><strong><code>options</code></strong> :&ensp;<code>Union[<a title="apexofficeprint.elements.charts.ChartOptions" href="#apexofficeprint.elements.charts.ChartOptions">ChartOptions</a>, dict]</code>, optional</dt>
<dd>The options for the chart. Defaults to None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AreaChart(Chart):
    &#34;&#34;&#34;Class for an area chart&#34;&#34;&#34;
    def __init__(self, name: str, areas: Tuple[Union[AreaSeries, XYSeries]], options: ChartOptions = None):
        &#34;&#34;&#34;
        Args:
            name (str): The name of the chart.
            areas (Tuple[Union[AreaSeries, XYSeries]]): Iterable of area series.
            options (Union[ChartOptions, dict], optional): The options for the chart. Defaults to None.
        &#34;&#34;&#34;
        super().__init__(name, options)
        self.areas: Tuple[Union[AreaSeries, XYSeries]] = areas

    @property
    def as_dict(self) -&gt; Dict:
        return self._get_dict({
            &#34;areas&#34;: [area.as_dict for area in self.areas],
            &#34;type&#34;: &#34;area&#34;
        })</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="apexofficeprint.elements.charts.Chart" href="#apexofficeprint.elements.charts.Chart">Chart</a></li>
<li><a title="apexofficeprint.elements.elements.Element" href="elements.html#apexofficeprint.elements.elements.Element">Element</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="apexofficeprint.elements.charts.Chart" href="#apexofficeprint.elements.charts.Chart">Chart</a></b></code>:
<ul class="hlist">
<li><code><a title="apexofficeprint.elements.charts.Chart.as_dict" href="elements.html#apexofficeprint.elements.elements.Element.as_dict">as_dict</a></code></li>
<li><code><a title="apexofficeprint.elements.charts.Chart.available_tags" href="elements.html#apexofficeprint.elements.elements.Element.available_tags">available_tags</a></code></li>
<li><code><a title="apexofficeprint.elements.charts.Chart.json" href="elements.html#apexofficeprint.elements.elements.Element.json">json</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="apexofficeprint.elements.charts.AreaSeries"><code class="flex name class">
<span>class <span class="ident">AreaSeries</span></span>
<span>(</span><span>x: Iterable[Union[int, float, str]], y: Iterable[Union[int, float]], name: str = None, color: str = None, opacity: float = None)</span>
</code></dt>
<dd>
<div class="desc"><p>A series for an area chart.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>Iterable[Union[int, float, str]]</code></dt>
<dd>The data for the x-axis.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>Iterable[Union[int, float]]</code></dt>
<dd>The data for the y-axis.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The name of the series. Defaults to None.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The color in which the series should be shown on a chart.
Can be html/css colors or hex values. Defaults to None.</dd>
<dt><strong><code>opacity</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The opacity for the color of the series. Defaults to None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AreaSeries(XYSeries):
    &#34;&#34;&#34;A series for an area chart.&#34;&#34;&#34;
    def __init__(self,
                 x: Iterable[Union[int, float, str]],
                 y: Iterable[Union[int, float]],
                 name: str = None,
                 color: str = None,
                 opacity: float = None):
        &#34;&#34;&#34;
        Args:
            x (Iterable[Union[int, float, str]]): The data for the x-axis.
            y (Iterable[Union[int, float]]): The data for the y-axis.
            name (str, optional): The name of the series. Defaults to None.
            color (str, optional): The color in which the series should be shown on a chart.
                Can be html/css colors or hex values. Defaults to None.
            opacity (float, optional): The opacity for the color of the series. Defaults to None.
        &#34;&#34;&#34;
        super().__init__(x, y, name, color)
        self.opacity: float = opacity

    @property
    def as_dict(self) -&gt; Dict:
        result = super().as_dict

        if self.opacity is not None:
            result[&#34;opacity&#34;] = self.opacity

        return result</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a></li>
<li><a title="apexofficeprint.elements.charts.Series" href="#apexofficeprint.elements.charts.Series">Series</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a></b></code>:
<ul class="hlist">
<li><code><a title="apexofficeprint.elements.charts.XYSeries.as_dict" href="#apexofficeprint.elements.charts.Series.as_dict">as_dict</a></code></li>
<li><code><a title="apexofficeprint.elements.charts.XYSeries.data" href="#apexofficeprint.elements.charts.Series.data">data</a></code></li>
<li><code><a title="apexofficeprint.elements.charts.XYSeries.from_dataframe" href="#apexofficeprint.elements.charts.XYSeries.from_dataframe">from_dataframe</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="apexofficeprint.elements.charts.BarChart"><code class="flex name class">
<span>class <span class="ident">BarChart</span></span>
<span>(</span><span>name: str, bars: Tuple[<a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a>], options: <a title="apexofficeprint.elements.charts.ChartOptions" href="#apexofficeprint.elements.charts.ChartOptions">ChartOptions</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class for a bar chart</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the chart.</dd>
<dt><strong><code>bars</code></strong> :&ensp;<code>Tuple[Union[<a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a>, <a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a>]]</code></dt>
<dd>Iterable of bar series.</dd>
<dt><strong><code>options</code></strong> :&ensp;<code>Union[<a title="apexofficeprint.elements.charts.ChartOptions" href="#apexofficeprint.elements.charts.ChartOptions">ChartOptions</a>, dict]</code>, optional</dt>
<dd>The options for the chart. Defaults to None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BarChart(Chart):
    &#34;&#34;&#34;Class for a bar chart&#34;&#34;&#34;
    def __init__(self, name: str, bars: Tuple[Union[BarSeries, XYSeries]], options: ChartOptions = None):
        &#34;&#34;&#34;
        Args:
            name (str): The name of the chart.
            bars (Tuple[Union[BarSeries, XYSeries]]): Iterable of bar series.
            options (Union[ChartOptions, dict], optional): The options for the chart. Defaults to None.
        &#34;&#34;&#34;
        super().__init__(name, options)
        self.bars: Tuple[Union[BarSeries, XYSeries]] = bars

    @property
    def as_dict(self) -&gt; Dict:
        return self._get_dict({
            &#34;bars&#34;: [bar.as_dict for bar in self.bars],
            &#34;type&#34;: &#34;bar&#34;
        })</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="apexofficeprint.elements.charts.Chart" href="#apexofficeprint.elements.charts.Chart">Chart</a></li>
<li><a title="apexofficeprint.elements.elements.Element" href="elements.html#apexofficeprint.elements.elements.Element">Element</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="apexofficeprint.elements.charts.Chart" href="#apexofficeprint.elements.charts.Chart">Chart</a></b></code>:
<ul class="hlist">
<li><code><a title="apexofficeprint.elements.charts.Chart.as_dict" href="elements.html#apexofficeprint.elements.elements.Element.as_dict">as_dict</a></code></li>
<li><code><a title="apexofficeprint.elements.charts.Chart.available_tags" href="elements.html#apexofficeprint.elements.elements.Element.available_tags">available_tags</a></code></li>
<li><code><a title="apexofficeprint.elements.charts.Chart.json" href="elements.html#apexofficeprint.elements.elements.Element.json">json</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="apexofficeprint.elements.charts.BarStackedChart"><code class="flex name class">
<span>class <span class="ident">BarStackedChart</span></span>
<span>(</span><span>name: str, bars: Tuple[<a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a>], options: <a title="apexofficeprint.elements.charts.ChartOptions" href="#apexofficeprint.elements.charts.ChartOptions">ChartOptions</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class for a stacked bar chart</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the chart.</dd>
<dt><strong><code>bars</code></strong> :&ensp;<code>Tuple[Union[<a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a>, <a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a>]]</code></dt>
<dd>Iterable of stacked bar series.</dd>
<dt><strong><code>options</code></strong> :&ensp;<code>Union[<a title="apexofficeprint.elements.charts.ChartOptions" href="#apexofficeprint.elements.charts.ChartOptions">ChartOptions</a>, dict]</code>, optional</dt>
<dd>The options for the chart. Defaults to None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BarStackedChart(Chart):
    &#34;&#34;&#34;Class for a stacked bar chart&#34;&#34;&#34;
    def __init__(self, name: str, bars: Tuple[Union[BarStackedSeries, XYSeries]], options: ChartOptions = None):
        &#34;&#34;&#34;
        Args:
            name (str): The name of the chart.
            bars (Tuple[Union[BarSeries, XYSeries]]): Iterable of stacked bar series.
            options (Union[ChartOptions, dict], optional): The options for the chart. Defaults to None.
        &#34;&#34;&#34;
        super().__init__(name, options)
        self.bars: Tuple[Union[BarStackedSeries, XYSeries]] = bars

    @property
    def as_dict(self) -&gt; Dict:
        return self._get_dict({
            &#34;bars&#34;: [bar.as_dict for bar in self.bars],
            &#34;type&#34;: &#34;barStacked&#34;
        })</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="apexofficeprint.elements.charts.Chart" href="#apexofficeprint.elements.charts.Chart">Chart</a></li>
<li><a title="apexofficeprint.elements.elements.Element" href="elements.html#apexofficeprint.elements.elements.Element">Element</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="apexofficeprint.elements.charts.Chart" href="#apexofficeprint.elements.charts.Chart">Chart</a></b></code>:
<ul class="hlist">
<li><code><a title="apexofficeprint.elements.charts.Chart.as_dict" href="elements.html#apexofficeprint.elements.elements.Element.as_dict">as_dict</a></code></li>
<li><code><a title="apexofficeprint.elements.charts.Chart.available_tags" href="elements.html#apexofficeprint.elements.elements.Element.available_tags">available_tags</a></code></li>
<li><code><a title="apexofficeprint.elements.charts.Chart.json" href="elements.html#apexofficeprint.elements.elements.Element.json">json</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="apexofficeprint.elements.charts.BarStackedPercentChart"><code class="flex name class">
<span>class <span class="ident">BarStackedPercentChart</span></span>
<span>(</span><span>name: str, bars: Tuple[<a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a>], options: <a title="apexofficeprint.elements.charts.ChartOptions" href="#apexofficeprint.elements.charts.ChartOptions">ChartOptions</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class for a stacked bar chart with the x-axis expressed in percentage</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the chart.</dd>
<dt><strong><code>bars</code></strong> :&ensp;<code>Tuple[Union[<a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a>, <a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a>]]</code></dt>
<dd>Iterable of stacked bar (percentage) series.</dd>
<dt><strong><code>options</code></strong> :&ensp;<code>Union[<a title="apexofficeprint.elements.charts.ChartOptions" href="#apexofficeprint.elements.charts.ChartOptions">ChartOptions</a>, dict]</code>, optional</dt>
<dd>The options for the chart. Defaults to None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BarStackedPercentChart(Chart):
    &#34;&#34;&#34;Class for a stacked bar chart with the x-axis expressed in percentage&#34;&#34;&#34;
    def __init__(self, name: str, bars: Tuple[Union[BarStackedPercentSeries, XYSeries]], options: ChartOptions = None):
        &#34;&#34;&#34;
        Args:
            name (str): The name of the chart.
            bars (Tuple[Union[BarSeries, XYSeries]]): Iterable of stacked bar (percentage) series.
            options (Union[ChartOptions, dict], optional): The options for the chart. Defaults to None.
        &#34;&#34;&#34;
        super().__init__(name, options)
        self.bars: Tuple[Union[BarStackedPercentSeries, XYSeries]] = bars

    @property
    def as_dict(self) -&gt; Dict:
        return self._get_dict({
            &#34;bars&#34;: [bar.as_dict for bar in self.bars],
            &#34;type&#34;: &#34;barStackedPercent&#34;
        })</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="apexofficeprint.elements.charts.Chart" href="#apexofficeprint.elements.charts.Chart">Chart</a></li>
<li><a title="apexofficeprint.elements.elements.Element" href="elements.html#apexofficeprint.elements.elements.Element">Element</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="apexofficeprint.elements.charts.Chart" href="#apexofficeprint.elements.charts.Chart">Chart</a></b></code>:
<ul class="hlist">
<li><code><a title="apexofficeprint.elements.charts.Chart.as_dict" href="elements.html#apexofficeprint.elements.elements.Element.as_dict">as_dict</a></code></li>
<li><code><a title="apexofficeprint.elements.charts.Chart.available_tags" href="elements.html#apexofficeprint.elements.elements.Element.available_tags">available_tags</a></code></li>
<li><code><a title="apexofficeprint.elements.charts.Chart.json" href="elements.html#apexofficeprint.elements.elements.Element.json">json</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="apexofficeprint.elements.charts.BubbleChart"><code class="flex name class">
<span>class <span class="ident">BubbleChart</span></span>
<span>(</span><span>name: str, bubbles: Tuple[<a title="apexofficeprint.elements.charts.BubbleSeries" href="#apexofficeprint.elements.charts.BubbleSeries">BubbleSeries</a>], options: <a title="apexofficeprint.elements.charts.ChartOptions" href="#apexofficeprint.elements.charts.ChartOptions">ChartOptions</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class for a bubble chart</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the chart.</dd>
<dt><strong><code>bubbles</code></strong> :&ensp;<code>Tuple[<a title="apexofficeprint.elements.charts.BubbleSeries" href="#apexofficeprint.elements.charts.BubbleSeries">BubbleSeries</a>]</code></dt>
<dd>Iterable of bubble series.</dd>
<dt><strong><code>options</code></strong> :&ensp;<code>Union[<a title="apexofficeprint.elements.charts.ChartOptions" href="#apexofficeprint.elements.charts.ChartOptions">ChartOptions</a>, dict]</code>, optional</dt>
<dd>The options for the chart. Defaults to None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BubbleChart(Chart):
    &#34;&#34;&#34;Class for a bubble chart&#34;&#34;&#34;
    def __init__(self, name: str, bubbles: Tuple[BubbleSeries], options: ChartOptions = None):
        &#34;&#34;&#34;
        Args:
            name (str): The name of the chart.
            bubbles (Tuple[BubbleSeries]): Iterable of bubble series.
            options (Union[ChartOptions, dict], optional): The options for the chart. Defaults to None.
        &#34;&#34;&#34;
        super().__init__(name, options)
        self.bubbles: Tuple[BubbleSeries] = bubbles

    @property
    def as_dict(self) -&gt; Dict:
        return self._get_dict({
            &#34;bubbles&#34;: [bub.as_dict for bub in self.bubbles],
            &#34;type&#34;: &#34;bubble&#34;
        })</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="apexofficeprint.elements.charts.Chart" href="#apexofficeprint.elements.charts.Chart">Chart</a></li>
<li><a title="apexofficeprint.elements.elements.Element" href="elements.html#apexofficeprint.elements.elements.Element">Element</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="apexofficeprint.elements.charts.Chart" href="#apexofficeprint.elements.charts.Chart">Chart</a></b></code>:
<ul class="hlist">
<li><code><a title="apexofficeprint.elements.charts.Chart.as_dict" href="elements.html#apexofficeprint.elements.elements.Element.as_dict">as_dict</a></code></li>
<li><code><a title="apexofficeprint.elements.charts.Chart.available_tags" href="elements.html#apexofficeprint.elements.elements.Element.available_tags">available_tags</a></code></li>
<li><code><a title="apexofficeprint.elements.charts.Chart.json" href="elements.html#apexofficeprint.elements.elements.Element.json">json</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="apexofficeprint.elements.charts.BubbleSeries"><code class="flex name class">
<span>class <span class="ident">BubbleSeries</span></span>
<span>(</span><span>x: Iterable[Union[int, float, str]], y: Iterable[Union[int, float]], sizes: Iterable[Union[int, float]], name: str = None, color: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>A series for a bubble chart.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>Iterable[Union[int, float, str]]</code></dt>
<dd>The data for the x-axis.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>Iterable[Union[int, float]]</code></dt>
<dd>The data for the y-axis.</dd>
<dt><strong><code>sizes</code></strong> :&ensp;<code>Iterable[Union[int, float]]</code></dt>
<dd>An iterable containing the sizes for each bubble of the series.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The name of the series. Defaults to None.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The color in which the series should be shown on a chart.
Can be html/css colors or hex values. Defaults to None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BubbleSeries(XYSeries):
    &#34;&#34;&#34;A series for a bubble chart.&#34;&#34;&#34;
    def __init__(self,
                 x: Iterable[Union[int, float, str]],
                 y: Iterable[Union[int, float]],
                 sizes: Iterable[Union[int, float]],
                 name: str = None,
                 color: str = None):
        &#34;&#34;&#34;
        Args:
            x (Iterable[Union[int, float, str]]): The data for the x-axis.
            y (Iterable[Union[int, float]]): The data for the y-axis.
            sizes (Iterable[Union[int, float]]): An iterable containing the sizes for each bubble of the series.
            name (str, optional): The name of the series. Defaults to None.
            color (str, optional): The color in which the series should be shown on a chart.
                Can be html/css colors or hex values. Defaults to None.
        &#34;&#34;&#34;
        super().__init__(x, y, name, color)
        self.sizes: Iterable[Union[int, float]] = sizes

    @property
    def data(self) -&gt; List[Dict[str, Any]]:
        return [{
            &#34;x&#34;: x,
            &#34;y&#34;: y,
            &#34;size&#34;: size
        } for x, y, size in zip(self.x, self.y, self.sizes)]

    @classmethod
    def from_dataframe(cls, data: &#39;pandas.DataFrame&#39;, name: str = None) -&gt; &#39;BubbleSeries&#39;:
        &#34;&#34;&#34;Generate a BubbleSeries from a [Pandas dataframe](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html).

        Args:
            data (pandas.DataFrame): Pandas dataframe containing the data for the x- and y-axis and the sizes for the bubbles.
            name (str): The name for the series.

        Returns:
            BubbleSeries: BubbleSeries generated from a Pandas dataframe
        &#34;&#34;&#34;
        x = list(data.iloc[:, 0])
        y = list(data.iloc[:, 1])
        sizes = list(data.iloc[:, 2])
        return cls(x, y, sizes, name=name)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a></li>
<li><a title="apexofficeprint.elements.charts.Series" href="#apexofficeprint.elements.charts.Series">Series</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="apexofficeprint.elements.charts.BubbleSeries.from_dataframe"><code class="name flex">
<span>def <span class="ident">from_dataframe</span></span>(<span>data: pandas.DataFrame, name: str = None) ‑> <a title="apexofficeprint.elements.charts.BubbleSeries" href="#apexofficeprint.elements.charts.BubbleSeries">BubbleSeries</a></span>
</code></dt>
<dd>
<div class="desc"><p>Generate a BubbleSeries from a <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html">Pandas dataframe</a>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>Pandas dataframe containing the data for the x- and y-axis and the sizes for the bubbles.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name for the series.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="apexofficeprint.elements.charts.BubbleSeries" href="#apexofficeprint.elements.charts.BubbleSeries">BubbleSeries</a></code></dt>
<dd>BubbleSeries generated from a Pandas dataframe</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_dataframe(cls, data: &#39;pandas.DataFrame&#39;, name: str = None) -&gt; &#39;BubbleSeries&#39;:
    &#34;&#34;&#34;Generate a BubbleSeries from a [Pandas dataframe](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html).

    Args:
        data (pandas.DataFrame): Pandas dataframe containing the data for the x- and y-axis and the sizes for the bubbles.
        name (str): The name for the series.

    Returns:
        BubbleSeries: BubbleSeries generated from a Pandas dataframe
    &#34;&#34;&#34;
    x = list(data.iloc[:, 0])
    y = list(data.iloc[:, 1])
    sizes = list(data.iloc[:, 2])
    return cls(x, y, sizes, name=name)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a></b></code>:
<ul class="hlist">
<li><code><a title="apexofficeprint.elements.charts.XYSeries.as_dict" href="#apexofficeprint.elements.charts.Series.as_dict">as_dict</a></code></li>
<li><code><a title="apexofficeprint.elements.charts.XYSeries.data" href="#apexofficeprint.elements.charts.Series.data">data</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="apexofficeprint.elements.charts.Chart"><code class="flex name class">
<span>class <span class="ident">Chart</span></span>
<span>(</span><span>name: str, options: Union[<a title="apexofficeprint.elements.charts.ChartOptions" href="#apexofficeprint.elements.charts.ChartOptions">ChartOptions</a>, dict] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>The abstract base class for a chart.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the chart.</dd>
<dt><strong><code>options</code></strong> :&ensp;<code>Union[<a title="apexofficeprint.elements.charts.ChartOptions" href="#apexofficeprint.elements.charts.ChartOptions">ChartOptions</a>, dict]</code>, optional</dt>
<dd>The options for the chart. Defaults to None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Chart(Element, ABC):
    &#34;&#34;&#34;The abstract base class for a chart.&#34;&#34;&#34;
    def __init__(self, name: str, options: Union[ChartOptions, dict] = None):
        &#34;&#34;&#34;
        Args:
            name (str): The name of the chart.
            options (Union[ChartOptions, dict], optional): The options for the chart. Defaults to None.
        &#34;&#34;&#34;
        Element.__init__(self, name)
        self.options: Union[ChartOptions, dict] = options

    @property
    @abstractmethod
    def as_dict(self) -&gt; Dict:
        pass

    def _get_dict(self, updates: dict) -&gt; Dict:
        &#34;&#34;&#34;Update the given dict with the chart options and return the result.

        Args:
            updates (dict): the dict that needs to be updated with the chart options

        Returns:
            Dict: the input dict, updated with the chart options
        &#34;&#34;&#34;
        result = {}
        if self.options is not None:
            result[&#34;options&#34;] = self.options if isinstance(
                self.options, dict) else self.options.as_dict
        result.update(updates)
        return {self.name: result}

    @property
    def available_tags(self) -&gt; FrozenSet[str]:
        return frozenset({&#34;{$&#34; + self.name + &#34;}&#34;})</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="apexofficeprint.elements.elements.Element" href="elements.html#apexofficeprint.elements.elements.Element">Element</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="apexofficeprint.elements.charts.AreaChart" href="#apexofficeprint.elements.charts.AreaChart">AreaChart</a></li>
<li><a title="apexofficeprint.elements.charts.BarChart" href="#apexofficeprint.elements.charts.BarChart">BarChart</a></li>
<li><a title="apexofficeprint.elements.charts.BarStackedChart" href="#apexofficeprint.elements.charts.BarStackedChart">BarStackedChart</a></li>
<li><a title="apexofficeprint.elements.charts.BarStackedPercentChart" href="#apexofficeprint.elements.charts.BarStackedPercentChart">BarStackedPercentChart</a></li>
<li><a title="apexofficeprint.elements.charts.BubbleChart" href="#apexofficeprint.elements.charts.BubbleChart">BubbleChart</a></li>
<li><a title="apexofficeprint.elements.charts.ColumnChart" href="#apexofficeprint.elements.charts.ColumnChart">ColumnChart</a></li>
<li><a title="apexofficeprint.elements.charts.ColumnStackedChart" href="#apexofficeprint.elements.charts.ColumnStackedChart">ColumnStackedChart</a></li>
<li><a title="apexofficeprint.elements.charts.ColumnStackedPercentChart" href="#apexofficeprint.elements.charts.ColumnStackedPercentChart">ColumnStackedPercentChart</a></li>
<li><a title="apexofficeprint.elements.charts.CombinedChart" href="#apexofficeprint.elements.charts.CombinedChart">CombinedChart</a></li>
<li><a title="apexofficeprint.elements.charts.DoughnutChart" href="#apexofficeprint.elements.charts.DoughnutChart">DoughnutChart</a></li>
<li><a title="apexofficeprint.elements.charts.LineChart" href="#apexofficeprint.elements.charts.LineChart">LineChart</a></li>
<li><a title="apexofficeprint.elements.charts.Pie3DChart" href="#apexofficeprint.elements.charts.Pie3DChart">Pie3DChart</a></li>
<li><a title="apexofficeprint.elements.charts.PieChart" href="#apexofficeprint.elements.charts.PieChart">PieChart</a></li>
<li><a title="apexofficeprint.elements.charts.RadarChart" href="#apexofficeprint.elements.charts.RadarChart">RadarChart</a></li>
<li><a title="apexofficeprint.elements.charts.ScatterChart" href="#apexofficeprint.elements.charts.ScatterChart">ScatterChart</a></li>
<li><a title="apexofficeprint.elements.charts.StockChart" href="#apexofficeprint.elements.charts.StockChart">StockChart</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="apexofficeprint.elements.elements.Element" href="elements.html#apexofficeprint.elements.elements.Element">Element</a></b></code>:
<ul class="hlist">
<li><code><a title="apexofficeprint.elements.elements.Element.as_dict" href="elements.html#apexofficeprint.elements.elements.Element.as_dict">as_dict</a></code></li>
<li><code><a title="apexofficeprint.elements.elements.Element.available_tags" href="elements.html#apexofficeprint.elements.elements.Element.available_tags">available_tags</a></code></li>
<li><code><a title="apexofficeprint.elements.elements.Element.json" href="elements.html#apexofficeprint.elements.elements.Element.json">json</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="apexofficeprint.elements.charts.ChartAxisOptions"><code class="flex name class">
<span>class <span class="ident">ChartAxisOptions</span></span>
<span>(</span><span>orientation: str = None, min: Union[int, float] = None, max: Union[int, float] = None, date: <a title="apexofficeprint.elements.charts.ChartDateOptions" href="#apexofficeprint.elements.charts.ChartDateOptions">ChartDateOptions</a> = None, title: str = None, values: bool = None, values_style: <a title="apexofficeprint.elements.charts.ChartTextStyle" href="#apexofficeprint.elements.charts.ChartTextStyle">ChartTextStyle</a> = None, title_style: <a title="apexofficeprint.elements.charts.ChartTextStyle" href="#apexofficeprint.elements.charts.ChartTextStyle">ChartTextStyle</a> = None, title_rotation: int = None, major_grid_lines: bool = None, major_unit: Union[int, float] = None, minor_grid_lines: bool = None, minor_unit: Union[int, float] = None, formatCode: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class for defining the axis options for a chart.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>orientation</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The orientation of the axis, 'minMax' or 'maxMin'. Defaults to None.</dd>
<dt><strong><code>min</code></strong> :&ensp;<code>Union[int, float]</code>, optional</dt>
<dd>Minimum of the axis. Defaults to None.</dd>
<dt><strong><code>max</code></strong> :&ensp;<code>Union[int, float]</code>, optional</dt>
<dd>Maximum of the axis. Defaults to None.</dd>
<dt><strong><code>date</code></strong> :&ensp;<code><a title="apexofficeprint.elements.charts.ChartDateOptions" href="#apexofficeprint.elements.charts.ChartDateOptions">ChartDateOptions</a></code>, optional</dt>
<dd>Date options, only for stock charts. Defaults to None.</dd>
<dt><strong><code>title</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Title of the axis. Defaults to None.</dd>
<dt><strong><code>values</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether or not to show the values on the axis. Defaults to None.</dd>
<dt><strong><code>values_style</code></strong> :&ensp;<code><a title="apexofficeprint.elements.charts.ChartTextStyle" href="#apexofficeprint.elements.charts.ChartTextStyle">ChartTextStyle</a></code>, optional</dt>
<dd>Styling for the values. Defaults to None.</dd>
<dt><strong><code>title_style</code></strong> :&ensp;<code><a title="apexofficeprint.elements.charts.ChartTextStyle" href="#apexofficeprint.elements.charts.ChartTextStyle">ChartTextStyle</a></code>, optional</dt>
<dd>Styling for the title. Defaults to None.</dd>
<dt><strong><code>title_rotation</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Title rotation in degrees, clockwise from horizontal axis. Defaults to None.</dd>
<dt><strong><code>major_grid_lines</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether or not to show the major grid lines. Defaults to None.</dd>
<dt><strong><code>major_unit</code></strong> :&ensp;<code>Union[int, float]</code>, optional</dt>
<dd>Automatic when undefined, spacing between major grid lines and axis values. Defaults to None.</dd>
<dt><strong><code>minor_grid_lines</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether or not to show the minor grid lines. Defaults to None.</dd>
<dt><strong><code>minor_unit</code></strong> :&ensp;<code>Union[int, float]</code>, optional</dt>
<dd>Automatic when undefined, spacing between minor grid lines and axis values. Defaults to None.</dd>
<dt><strong><code>formatCode</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Format code for axis data, "General", "Number" &hellip; Defaults to None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ChartAxisOptions:
    &#34;&#34;&#34;Class for defining the axis options for a chart.&#34;&#34;&#34;
    def __init__(self,
                 orientation: str = None,
                 min: Union[int, float] = None,
                 max: Union[int, float] = None,
                 date: ChartDateOptions = None,
                 title: str = None,
                 values: bool = None,
                 values_style: ChartTextStyle = None,
                 title_style: ChartTextStyle = None,
                 title_rotation: int = None,
                 major_grid_lines: bool = None,
                 major_unit: Union[int, float] = None,
                 minor_grid_lines: bool = None,
                 minor_unit: Union[int, float] = None,
                 formatCode: str = None):
        &#34;&#34;&#34;
        Args:
            orientation (str, optional): The orientation of the axis, &#39;minMax&#39; or &#39;maxMin&#39;. Defaults to None.
            min (Union[int, float], optional): Minimum of the axis. Defaults to None.
            max (Union[int, float], optional): Maximum of the axis. Defaults to None.
            date (ChartDateOptions, optional): Date options, only for stock charts. Defaults to None.
            title (str, optional): Title of the axis. Defaults to None.
            values (bool, optional): Whether or not to show the values on the axis. Defaults to None.
            values_style (ChartTextStyle, optional): Styling for the values. Defaults to None.
            title_style (ChartTextStyle, optional): Styling for the title. Defaults to None.
            title_rotation (int, optional): Title rotation in degrees, clockwise from horizontal axis. Defaults to None.
            major_grid_lines (bool, optional): Whether or not to show the major grid lines. Defaults to None.
            major_unit (Union[int, float], optional): Automatic when undefined, spacing between major grid lines and axis values. Defaults to None.
            minor_grid_lines (bool, optional): Whether or not to show the minor grid lines. Defaults to None.
            minor_unit (Union[int, float], optional): Automatic when undefined, spacing between minor grid lines and axis values. Defaults to None.
            formatCode (str, optional): Format code for axis data, &#34;General&#34;, &#34;Number&#34; ... Defaults to None.
        &#34;&#34;&#34;
        self.orientation: str = orientation
        self.min: Union[int, float] = min
        self.max: Union[int, float] = max
        self.date: ChartDateOptions = date
        self.title: str = title
        self.values: bool = values
        self.values_style: ChartTextStyle = values_style
        self.title_style: ChartTextStyle = title_style
        self.title_rotation: int = title_rotation
        self.major_grid_lines: bool = major_grid_lines
        self.major_unit: Union[int, float] = major_unit
        self.minor_grid_lines: bool = minor_grid_lines
        self.minor_unit: Union[int, float] = minor_unit
        self.format_code: str = formatCode

    @property
    def as_dict(self) -&gt; Dict:
        &#34;&#34;&#34;The dict representation of these chart axis options.

        Returns:
            Dict: dict representation of these chart axis options
        &#34;&#34;&#34;
        result = {}

        if self.orientation is not None:
            result[&#34;orientation&#34;] = self.orientation
        if self.min is not None:
            result[&#34;min&#34;] = self.min
        if self.max is not None:
            result[&#34;max&#34;] = self.max
        if self.date is not None:
            result[&#34;type&#34;] = &#34;date&#34;
            result[&#34;date&#34;] = self.date.as_dict
        if self.title is not None:
            result[&#34;title&#34;] = self.title
        if self.values is not None:
            result[&#34;showValues&#34;] = self.values
        if self.values_style is not None:
            result[&#34;valuesStyle&#34;] = self.values_style.as_dict
        if self.title_style is not None:
            result[&#34;titleStyle&#34;] = self.title_style.as_dict
        if self.title_rotation is not None:
            result[&#34;titleRotation&#34;] = self.title_rotation
        if self.major_grid_lines is not None:
            result[&#34;majorGridlines&#34;] = self.major_grid_lines
        if self.major_unit is not None:
            result[&#34;majorUnit&#34;] = self.major_unit
        if self.minor_grid_lines is not None:
            result[&#34;minorGridlines&#34;] = self.minor_grid_lines
        if self.minor_unit is not None:
            result[&#34;minorUnit&#34;] = self.minor_unit
        if self.format_code is not None:
            result[&#34;formatCode&#34;] = self.format_code

        return result</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="apexofficeprint.elements.charts.ChartAxisOptions.as_dict"><code class="name">var <span class="ident">as_dict</span> : Dict</code></dt>
<dd>
<div class="desc"><p>The dict representation of these chart axis options.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict</code></dt>
<dd>dict representation of these chart axis options</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def as_dict(self) -&gt; Dict:
    &#34;&#34;&#34;The dict representation of these chart axis options.

    Returns:
        Dict: dict representation of these chart axis options
    &#34;&#34;&#34;
    result = {}

    if self.orientation is not None:
        result[&#34;orientation&#34;] = self.orientation
    if self.min is not None:
        result[&#34;min&#34;] = self.min
    if self.max is not None:
        result[&#34;max&#34;] = self.max
    if self.date is not None:
        result[&#34;type&#34;] = &#34;date&#34;
        result[&#34;date&#34;] = self.date.as_dict
    if self.title is not None:
        result[&#34;title&#34;] = self.title
    if self.values is not None:
        result[&#34;showValues&#34;] = self.values
    if self.values_style is not None:
        result[&#34;valuesStyle&#34;] = self.values_style.as_dict
    if self.title_style is not None:
        result[&#34;titleStyle&#34;] = self.title_style.as_dict
    if self.title_rotation is not None:
        result[&#34;titleRotation&#34;] = self.title_rotation
    if self.major_grid_lines is not None:
        result[&#34;majorGridlines&#34;] = self.major_grid_lines
    if self.major_unit is not None:
        result[&#34;majorUnit&#34;] = self.major_unit
    if self.minor_grid_lines is not None:
        result[&#34;minorGridlines&#34;] = self.minor_grid_lines
    if self.minor_unit is not None:
        result[&#34;minorUnit&#34;] = self.minor_unit
    if self.format_code is not None:
        result[&#34;formatCode&#34;] = self.format_code

    return result</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="apexofficeprint.elements.charts.ChartDateOptions"><code class="flex name class">
<span>class <span class="ident">ChartDateOptions</span></span>
<span>(</span><span>format: str = None, code: str = None, unit: str = None, step: Union[int, str] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class for defining the date options for a chart.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>format</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The format to display the date on the chart's axis (e.g. unix). Defaults to None.</dd>
<dt><strong><code>code</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The code for the date (e.g. dd/mm/yyyy). Defaults to None.</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The unit to be used for spacing the axis values (e.g. months). Defaults to None.</dd>
<dt><strong><code>step</code></strong> :&ensp;<code>Union[int, str]</code>, optional</dt>
<dd>How many of the above unit should be used for spacing the axis values (automatic if undefined).
This option is not supported in LibreOffice. Defaults to None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ChartDateOptions:
    &#34;&#34;&#34;Class for defining the date options for a chart.&#34;&#34;&#34;
    def __init__(self,
                 format: str = None,
                 code: str = None,
                 unit: str = None,
                 step: Union[int, str] = None):
        &#34;&#34;&#34;
        Args:
            format (str, optional): The format to display the date on the chart&#39;s axis (e.g. unix). Defaults to None.
            code (str, optional): The code for the date (e.g. dd/mm/yyyy). Defaults to None.
            unit (str, optional): The unit to be used for spacing the axis values (e.g. months). Defaults to None.
            step (Union[int, str], optional): How many of the above unit should be used for spacing the axis values (automatic if undefined).
                This option is not supported in LibreOffice. Defaults to None.
        &#34;&#34;&#34;
        self.format: str = format
        self.code: str = code
        self.unit: str = unit
        self.step: Union[int, str] = step

    @property
    def as_dict(self) -&gt; Dict:
        &#34;&#34;&#34;The dict representation for this ChartDateOptions object.

        Returns:
            Dict: dict representation for this ChartDateOptions object
        &#34;&#34;&#34;
        result = {}

        if self.format is not None:
            result[&#34;format&#34;] = self.format
        if self.code is not None:
            result[&#34;code&#34;] = self.code
        if self.unit is not None:
            result[&#34;unit&#34;] = self.unit
        if self.step is not None:
            result[&#34;step&#34;] = self.step

        return result</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="apexofficeprint.elements.charts.ChartDateOptions.as_dict"><code class="name">var <span class="ident">as_dict</span> : Dict</code></dt>
<dd>
<div class="desc"><p>The dict representation for this ChartDateOptions object.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict</code></dt>
<dd>dict representation for this ChartDateOptions object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def as_dict(self) -&gt; Dict:
    &#34;&#34;&#34;The dict representation for this ChartDateOptions object.

    Returns:
        Dict: dict representation for this ChartDateOptions object
    &#34;&#34;&#34;
    result = {}

    if self.format is not None:
        result[&#34;format&#34;] = self.format
    if self.code is not None:
        result[&#34;code&#34;] = self.code
    if self.unit is not None:
        result[&#34;unit&#34;] = self.unit
    if self.step is not None:
        result[&#34;step&#34;] = self.step

    return result</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="apexofficeprint.elements.charts.ChartOptions"><code class="flex name class">
<span>class <span class="ident">ChartOptions</span></span>
<span>(</span><span>x_axis: <a title="apexofficeprint.elements.charts.ChartAxisOptions" href="#apexofficeprint.elements.charts.ChartAxisOptions">ChartAxisOptions</a> = None, y_axis: <a title="apexofficeprint.elements.charts.ChartAxisOptions" href="#apexofficeprint.elements.charts.ChartAxisOptions">ChartAxisOptions</a> = None, y2_axis: <a title="apexofficeprint.elements.charts.ChartAxisOptions" href="#apexofficeprint.elements.charts.ChartAxisOptions">ChartAxisOptions</a> = None, width: int = None, height: int = None, border: bool = None, rounded_corners: bool = None, background_color: str = None, background_opacity: int = None, title: str = None, title_style: <a title="apexofficeprint.elements.charts.ChartTextStyle" href="#apexofficeprint.elements.charts.ChartTextStyle">ChartTextStyle</a> = None, grid: bool = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Options object for a <code><a title="apexofficeprint.elements.charts.Chart" href="#apexofficeprint.elements.charts.Chart">Chart</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x_axis</code></strong> :&ensp;<code><a title="apexofficeprint.elements.charts.ChartAxisOptions" href="#apexofficeprint.elements.charts.ChartAxisOptions">ChartAxisOptions</a></code>, optional</dt>
<dd>The options for the x-axis. Defaults to None.</dd>
<dt><strong><code>y_axis</code></strong> :&ensp;<code><a title="apexofficeprint.elements.charts.ChartAxisOptions" href="#apexofficeprint.elements.charts.ChartAxisOptions">ChartAxisOptions</a></code>, optional</dt>
<dd>The options for the y-axis. Note: date options for the y axis are ignored by the AOP server. Defaults to None.</dd>
<dt><strong><code>y2_axis</code></strong> :&ensp;<code><a title="apexofficeprint.elements.charts.ChartAxisOptions" href="#apexofficeprint.elements.charts.ChartAxisOptions">ChartAxisOptions</a></code>, optional</dt>
<dd>The options for the y2-axis. Note: date options for the y2 axis are ignored by the AOP server. Defaults to None.</dd>
<dt><strong><code>width</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Width of the chart. Defaults to None.</dd>
<dt><strong><code>height</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Height of the chart. Defaults to None.</dd>
<dt><strong><code>border</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether or not the chart should have a border. Defaults to None.</dd>
<dt><strong><code>rounded_corners</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether or not the chart should have rounded corners. Note: displaying rounded corners is not supported by LibreOffice. Defaults to None.</dd>
<dt><strong><code>background_color</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Background color for the entire chart. Defaults to None.</dd>
<dt><strong><code>background_opacity</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The opacity of the background color for the entire chart.
Note: backgroundOpacity is ignored if backgroundColor is not specified or if backgroundColor is specified in a color space which includes an alpha channel (e.g. rgba(0,191,255,0.5)).
In the latter case, the alpha channel in backgroundColor is used. Defaults to None.</dd>
<dt><strong><code>title</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The title of the chart. Defaults to None.</dd>
<dt><strong><code>title_style</code></strong> :&ensp;<code><a title="apexofficeprint.elements.charts.ChartTextStyle" href="#apexofficeprint.elements.charts.ChartTextStyle">ChartTextStyle</a></code>, optional</dt>
<dd>The styling for the title of the chart. Defaults to None.</dd>
<dt><strong><code>grid</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether or not the chart should have a grid. Defaults to None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ChartOptions():
    &#34;&#34;&#34;Options object for a `Chart`.&#34;&#34;&#34;
    def __init__(self,
                 x_axis: ChartAxisOptions=None,
                 y_axis: ChartAxisOptions=None,
                 y2_axis: ChartAxisOptions=None,
                 width: int=None,
                 height: int=None,
                 border: bool=None,
                 rounded_corners: bool=None,
                 background_color: str=None,
                 background_opacity: int=None,
                 title: str=None,
                 title_style: ChartTextStyle=None,
                 grid: bool=None):
        &#34;&#34;&#34;
        Args:
            x_axis (ChartAxisOptions, optional): The options for the x-axis. Defaults to None.
            y_axis (ChartAxisOptions, optional): The options for the y-axis. Note: date options for the y axis are ignored by the AOP server. Defaults to None.
            y2_axis (ChartAxisOptions, optional): The options for the y2-axis. Note: date options for the y2 axis are ignored by the AOP server. Defaults to None.
            width (int, optional): Width of the chart. Defaults to None.
            height (int, optional): Height of the chart. Defaults to None.
            border (bool, optional): Whether or not the chart should have a border. Defaults to None.
            rounded_corners (bool, optional): Whether or not the chart should have rounded corners. Note: displaying rounded corners is not supported by LibreOffice. Defaults to None.
            background_color (str, optional): Background color for the entire chart. Defaults to None.
            background_opacity (int, optional): The opacity of the background color for the entire chart.
                Note: backgroundOpacity is ignored if backgroundColor is not specified or if backgroundColor is specified in a color space which includes an alpha channel (e.g. rgba(0,191,255,0.5)).
                In the latter case, the alpha channel in backgroundColor is used. Defaults to None.
            title (str, optional): The title of the chart. Defaults to None.
            title_style (ChartTextStyle, optional): The styling for the title of the chart. Defaults to None.
            grid (bool, optional): Whether or not the chart should have a grid. Defaults to None.
        &#34;&#34;&#34;
        self._legend_options: dict = None
        self._data_labels_options: dict = None

        self.x_axis: ChartAxisOptions = x_axis
        self.y_axis: ChartAxisOptions = y_axis
        self.y2_axis: ChartAxisOptions = y2_axis
        self.width: int = width
        self.height: int = height
        self.border: bool = border
        self.rounded_corners: bool = rounded_corners
        self.background_color: str = background_color
        self.background_opacity: int = background_opacity
        self.title: str = title
        self.title_style: ChartTextStyle = title_style
        self.grid: bool = grid

    def set_legend(self, position: str = &#39;r&#39;, style: ChartTextStyle = None):
        &#34;&#34;&#34;Setter for the legend of the chart.

        Args:
            position (str, optional): Position of the legend.  &#39;l&#39;: left, &#39;r&#39;: right, &#39;b&#39;: bottom, &#39;t&#39;: top. Defaults to &#39;r&#39;.
            style (ChartTextStyle, optional): The styling for the text of the legend. Defaults to None.
        &#34;&#34;&#34;
        self._legend_options = {
            &#34;showLegend&#34;: True
        }
        self._legend_options[&#34;position&#34;] = position
        if style is not None:
            self._legend_options[&#34;style&#34;] = style.as_dict

    def remove_legend(self):
        &#34;&#34;&#34;Setter for removing the legend from the chart.&#34;&#34;&#34;
        self._legend_options = None

    def set_data_labels(self,
                        separator: str = None,
                        series_name: bool = None,
                        category_name: bool = None,
                        legend_key: bool = None,
                        value: bool = None,
                        percentage: bool = None,
                        position: str = None):
        &#34;&#34;&#34;Setter for the data labels for the chart.

        Args:
            separator (str, optional): Seperator : can be either false or anything else for example \n or \t or ; or (, if false). Defaults to None.
            series_name (bool, optional): Whether or not to include the series name in the data label. Defaults to None.
            category_name (bool, optional): Whether or not to include the series category name in the data label. Defaults to None.
            legend_key (bool, optional): Whether or not to include the legend key (i.e. the color of the series) in the data label. Defaults to None.
            value (bool, optional): Whether or not to include the actual value in the data label. Defaults to None.
            percentage (bool, optional): Whether or not to include the percentage in the data label. By default True for pie/pie3d and doughnut. Defaults to None.
            position (str, optional): The position of the data label.
                Can be &#39;center&#39;, &#39;left&#39;, &#39;right&#39;, &#39;above&#39;, &#39;below&#39;, &#39;insideBase&#39;, &#39;bestFit&#39;, &#39;outsideEnd&#39;, &#39;insideEnd&#39;.
                Note that not all options might be available for specific charts. Defaults to None.
        &#34;&#34;&#34;
        self._data_labels_options = {
            &#34;showDataLabels&#34;: True
        }

        if separator is not None:
            self._data_labels_options[&#34;separator&#34;] = separator
        if series_name is not None:
            self._data_labels_options[&#34;showSeriesName&#34;] = series_name
        if category_name is not None:
            self._data_labels_options[&#34;showCategoryName&#34;] = category_name
        if legend_key is not None:
            self._data_labels_options[&#34;showLegendKey&#34;] = legend_key
        if value is not None:
            self._data_labels_options[&#34;showValue&#34;] = value
        if percentage is not None:
            self._data_labels_options[&#34;showPercentage&#34;] = percentage
        if position is not None:
            self._data_labels_options[&#34;position&#34;] = position

    def remove_data_labels(self):
        &#34;&#34;&#34;Setter to remove the data labels from the chart.&#34;&#34;&#34;
        self._data_labels_options = None

    @property
    def as_dict(self) -&gt; Dict:
        &#34;&#34;&#34;The dict representation of this ChartOptions object.

        Returns:
            Dict: dict representation of this ChartOptions object
        &#34;&#34;&#34;
        result = {
            &#34;axis&#34;: {
            }
        }

        if self.x_axis is not None:
            result[&#39;axis&#39;][&#39;x&#39;] = self.x_axis.as_dict
        if self.y_axis is not None:
            result[&#39;axis&#39;][&#39;y&#39;] = self.y_axis.as_dict
        if self.y2_axis is not None:
            result[&#34;axis&#34;][&#34;y2&#34;] = self.y2_axis.as_dict
        if self.width is not None:
            result[&#34;width&#34;] = self.width
        if self.height is not None:
            result[&#34;height&#34;] = self.height
        if self.border is not None:
            result[&#34;border&#34;] = self.border
        if self.rounded_corners is not None:
            result[&#34;roundedCorners&#34;] = self.rounded_corners
        if self.background_color is not None:
            result[&#34;backgroundColor&#34;] = self.background_color
        if self.background_opacity is not None:
            result[&#34;backgroundOpacity&#34;] = self.background_opacity
        if self.title is not None:
            result[&#34;title&#34;] = self.title
        if self.title_style is not None:
            result[&#34;titleStyle&#34;] = self.title_style.as_dict
        if self.grid is not None:
            result[&#34;grid&#34;] = self.grid
        if self._legend_options is not None:
            result[&#34;legend&#34;] = self._legend_options
        if self._data_labels_options is not None:
            result[&#34;dataLabels&#34;] = self._data_labels_options

        return result</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="apexofficeprint.elements.charts.ChartOptions.as_dict"><code class="name">var <span class="ident">as_dict</span> : Dict</code></dt>
<dd>
<div class="desc"><p>The dict representation of this ChartOptions object.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict</code></dt>
<dd>dict representation of this ChartOptions object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def as_dict(self) -&gt; Dict:
    &#34;&#34;&#34;The dict representation of this ChartOptions object.

    Returns:
        Dict: dict representation of this ChartOptions object
    &#34;&#34;&#34;
    result = {
        &#34;axis&#34;: {
        }
    }

    if self.x_axis is not None:
        result[&#39;axis&#39;][&#39;x&#39;] = self.x_axis.as_dict
    if self.y_axis is not None:
        result[&#39;axis&#39;][&#39;y&#39;] = self.y_axis.as_dict
    if self.y2_axis is not None:
        result[&#34;axis&#34;][&#34;y2&#34;] = self.y2_axis.as_dict
    if self.width is not None:
        result[&#34;width&#34;] = self.width
    if self.height is not None:
        result[&#34;height&#34;] = self.height
    if self.border is not None:
        result[&#34;border&#34;] = self.border
    if self.rounded_corners is not None:
        result[&#34;roundedCorners&#34;] = self.rounded_corners
    if self.background_color is not None:
        result[&#34;backgroundColor&#34;] = self.background_color
    if self.background_opacity is not None:
        result[&#34;backgroundOpacity&#34;] = self.background_opacity
    if self.title is not None:
        result[&#34;title&#34;] = self.title
    if self.title_style is not None:
        result[&#34;titleStyle&#34;] = self.title_style.as_dict
    if self.grid is not None:
        result[&#34;grid&#34;] = self.grid
    if self._legend_options is not None:
        result[&#34;legend&#34;] = self._legend_options
    if self._data_labels_options is not None:
        result[&#34;dataLabels&#34;] = self._data_labels_options

    return result</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="apexofficeprint.elements.charts.ChartOptions.remove_data_labels"><code class="name flex">
<span>def <span class="ident">remove_data_labels</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Setter to remove the data labels from the chart.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_data_labels(self):
    &#34;&#34;&#34;Setter to remove the data labels from the chart.&#34;&#34;&#34;
    self._data_labels_options = None</code></pre>
</details>
</dd>
<dt id="apexofficeprint.elements.charts.ChartOptions.remove_legend"><code class="name flex">
<span>def <span class="ident">remove_legend</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Setter for removing the legend from the chart.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_legend(self):
    &#34;&#34;&#34;Setter for removing the legend from the chart.&#34;&#34;&#34;
    self._legend_options = None</code></pre>
</details>
</dd>
<dt id="apexofficeprint.elements.charts.ChartOptions.set_data_labels"><code class="name flex">
<span>def <span class="ident">set_data_labels</span></span>(<span>self, separator: str = None, series_name: bool = None, category_name: bool = None, legend_key: bool = None, value: bool = None, percentage: bool = None, position: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Setter for the data labels for the chart.</p>
<pre><code>   Args:
       separator (str, optional): Seperator : can be either false or anything else for example
</code></pre>
<p>or
or ; or (, if false). Defaults to None.
series_name (bool, optional): Whether or not to include the series name in the data label. Defaults to None.
category_name (bool, optional): Whether or not to include the series category name in the data label. Defaults to None.
legend_key (bool, optional): Whether or not to include the legend key (i.e. the color of the series) in the data label. Defaults to None.
value (bool, optional): Whether or not to include the actual value in the data label. Defaults to None.
percentage (bool, optional): Whether or not to include the percentage in the data label. By default True for pie/pie3d and doughnut. Defaults to None.
position (str, optional): The position of the data label.
Can be 'center', 'left', 'right', 'above', 'below', 'insideBase', 'bestFit', 'outsideEnd', 'insideEnd'.
Note that not all options might be available for specific charts. Defaults to None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_data_labels(self,
                    separator: str = None,
                    series_name: bool = None,
                    category_name: bool = None,
                    legend_key: bool = None,
                    value: bool = None,
                    percentage: bool = None,
                    position: str = None):
    &#34;&#34;&#34;Setter for the data labels for the chart.

    Args:
        separator (str, optional): Seperator : can be either false or anything else for example \n or \t or ; or (, if false). Defaults to None.
        series_name (bool, optional): Whether or not to include the series name in the data label. Defaults to None.
        category_name (bool, optional): Whether or not to include the series category name in the data label. Defaults to None.
        legend_key (bool, optional): Whether or not to include the legend key (i.e. the color of the series) in the data label. Defaults to None.
        value (bool, optional): Whether or not to include the actual value in the data label. Defaults to None.
        percentage (bool, optional): Whether or not to include the percentage in the data label. By default True for pie/pie3d and doughnut. Defaults to None.
        position (str, optional): The position of the data label.
            Can be &#39;center&#39;, &#39;left&#39;, &#39;right&#39;, &#39;above&#39;, &#39;below&#39;, &#39;insideBase&#39;, &#39;bestFit&#39;, &#39;outsideEnd&#39;, &#39;insideEnd&#39;.
            Note that not all options might be available for specific charts. Defaults to None.
    &#34;&#34;&#34;
    self._data_labels_options = {
        &#34;showDataLabels&#34;: True
    }

    if separator is not None:
        self._data_labels_options[&#34;separator&#34;] = separator
    if series_name is not None:
        self._data_labels_options[&#34;showSeriesName&#34;] = series_name
    if category_name is not None:
        self._data_labels_options[&#34;showCategoryName&#34;] = category_name
    if legend_key is not None:
        self._data_labels_options[&#34;showLegendKey&#34;] = legend_key
    if value is not None:
        self._data_labels_options[&#34;showValue&#34;] = value
    if percentage is not None:
        self._data_labels_options[&#34;showPercentage&#34;] = percentage
    if position is not None:
        self._data_labels_options[&#34;position&#34;] = position</code></pre>
</details>
</dd>
<dt id="apexofficeprint.elements.charts.ChartOptions.set_legend"><code class="name flex">
<span>def <span class="ident">set_legend</span></span>(<span>self, position: str = 'r', style: <a title="apexofficeprint.elements.charts.ChartTextStyle" href="#apexofficeprint.elements.charts.ChartTextStyle">ChartTextStyle</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Setter for the legend of the chart.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>position</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Position of the legend.
'l': left, 'r': right, 'b': bottom, 't': top. Defaults to 'r'.</dd>
<dt><strong><code>style</code></strong> :&ensp;<code><a title="apexofficeprint.elements.charts.ChartTextStyle" href="#apexofficeprint.elements.charts.ChartTextStyle">ChartTextStyle</a></code>, optional</dt>
<dd>The styling for the text of the legend. Defaults to None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_legend(self, position: str = &#39;r&#39;, style: ChartTextStyle = None):
    &#34;&#34;&#34;Setter for the legend of the chart.

    Args:
        position (str, optional): Position of the legend.  &#39;l&#39;: left, &#39;r&#39;: right, &#39;b&#39;: bottom, &#39;t&#39;: top. Defaults to &#39;r&#39;.
        style (ChartTextStyle, optional): The styling for the text of the legend. Defaults to None.
    &#34;&#34;&#34;
    self._legend_options = {
        &#34;showLegend&#34;: True
    }
    self._legend_options[&#34;position&#34;] = position
    if style is not None:
        self._legend_options[&#34;style&#34;] = style.as_dict</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="apexofficeprint.elements.charts.ChartTextStyle"><code class="flex name class">
<span>class <span class="ident">ChartTextStyle</span></span>
<span>(</span><span>italic: bool = None, bold: bool = None, color: str = None, font: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class for defining the styling of the text for a chart.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>italic</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether or not the text should be in italic. Defaults to None.</dd>
<dt><strong><code>bold</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether or not the text should be in bold. Defaults to None.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The color of the text. Defaults to None.</dd>
<dt><strong><code>font</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The font of the text. Defaults to None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ChartTextStyle:
    &#34;&#34;&#34;Class for defining the styling of the text for a chart.&#34;&#34;&#34;
    def __init__(self,
                 italic: bool = None,
                 bold: bool = None,
                 color: str = None,
                 font: str = None):
        &#34;&#34;&#34;
        Args:
            italic (bool, optional): Whether or not the text should be in italic. Defaults to None.
            bold (bool, optional): Whether or not the text should be in bold. Defaults to None.
            color (str, optional): The color of the text. Defaults to None.
            font (str, optional): The font of the text. Defaults to None.
        &#34;&#34;&#34;
        self.italic: bool = italic
        self.bold: bool = bold
        self.color: str = color
        self.font: str = font

    @property
    def as_dict(self) -&gt; Dict:
        &#34;&#34;&#34;The dict representation of this ChartTextStyle object.

        Returns:
            Dict: dict representation of this ChartTextStyle object
        &#34;&#34;&#34;
        result = {}

        if self.italic is not None:
            result[&#34;italic&#34;] = self.italic
        if self.bold is not None:
            result[&#34;bold&#34;] = self.bold
        if self.color is not None:
            result[&#34;color&#34;] = self.color
        if self.font is not None:
            result[&#34;font&#34;] = self.font

        return result</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="apexofficeprint.elements.charts.ChartTextStyle.as_dict"><code class="name">var <span class="ident">as_dict</span> : Dict</code></dt>
<dd>
<div class="desc"><p>The dict representation of this ChartTextStyle object.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict</code></dt>
<dd>dict representation of this ChartTextStyle object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def as_dict(self) -&gt; Dict:
    &#34;&#34;&#34;The dict representation of this ChartTextStyle object.

    Returns:
        Dict: dict representation of this ChartTextStyle object
    &#34;&#34;&#34;
    result = {}

    if self.italic is not None:
        result[&#34;italic&#34;] = self.italic
    if self.bold is not None:
        result[&#34;bold&#34;] = self.bold
    if self.color is not None:
        result[&#34;color&#34;] = self.color
    if self.font is not None:
        result[&#34;font&#34;] = self.font

    return result</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="apexofficeprint.elements.charts.ColumnChart"><code class="flex name class">
<span>class <span class="ident">ColumnChart</span></span>
<span>(</span><span>name: str, columns: Tuple[<a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a>], options: <a title="apexofficeprint.elements.charts.ChartOptions" href="#apexofficeprint.elements.charts.ChartOptions">ChartOptions</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class for a column chart</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the chart.</dd>
<dt><strong><code>columns</code></strong> :&ensp;<code>Tuple[Union[<a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a>, <a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a>]]</code></dt>
<dd>Iterable of column series.</dd>
<dt><strong><code>options</code></strong> :&ensp;<code>Union[<a title="apexofficeprint.elements.charts.ChartOptions" href="#apexofficeprint.elements.charts.ChartOptions">ChartOptions</a>, dict]</code>, optional</dt>
<dd>The options for the chart. Defaults to None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ColumnChart(Chart):
    &#34;&#34;&#34;Class for a column chart&#34;&#34;&#34;
    def __init__(self, name: str, columns: Tuple[Union[ColumnSeries, XYSeries]], options: ChartOptions = None):
        &#34;&#34;&#34;
        Args:
            name (str): The name of the chart.
            columns (Tuple[Union[ColumnSeries, XYSeries]]): Iterable of column series.
            options (Union[ChartOptions, dict], optional): The options for the chart. Defaults to None.
        &#34;&#34;&#34;
        super().__init__(name, options)
        self.columns: Tuple[Union[ColumnSeries, XYSeries]] = columns

    @property
    def as_dict(self) -&gt; Dict:
        return self._get_dict({
            &#34;columns&#34;: [col.as_dict for col in self.columns],
            &#34;type&#34;: &#34;column&#34;
        })</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="apexofficeprint.elements.charts.Chart" href="#apexofficeprint.elements.charts.Chart">Chart</a></li>
<li><a title="apexofficeprint.elements.elements.Element" href="elements.html#apexofficeprint.elements.elements.Element">Element</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="apexofficeprint.elements.charts.Chart" href="#apexofficeprint.elements.charts.Chart">Chart</a></b></code>:
<ul class="hlist">
<li><code><a title="apexofficeprint.elements.charts.Chart.as_dict" href="elements.html#apexofficeprint.elements.elements.Element.as_dict">as_dict</a></code></li>
<li><code><a title="apexofficeprint.elements.charts.Chart.available_tags" href="elements.html#apexofficeprint.elements.elements.Element.available_tags">available_tags</a></code></li>
<li><code><a title="apexofficeprint.elements.charts.Chart.json" href="elements.html#apexofficeprint.elements.elements.Element.json">json</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="apexofficeprint.elements.charts.ColumnStackedChart"><code class="flex name class">
<span>class <span class="ident">ColumnStackedChart</span></span>
<span>(</span><span>name: str, columns: Tuple[<a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a>], options: <a title="apexofficeprint.elements.charts.ChartOptions" href="#apexofficeprint.elements.charts.ChartOptions">ChartOptions</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class for a stacked column chart</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the chart.</dd>
<dt><strong><code>columns</code></strong> :&ensp;<code>Tuple[Union[<a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a>, <a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a>]]</code></dt>
<dd>Iterable of stacked column series.</dd>
<dt><strong><code>options</code></strong> :&ensp;<code>Union[<a title="apexofficeprint.elements.charts.ChartOptions" href="#apexofficeprint.elements.charts.ChartOptions">ChartOptions</a>, dict]</code>, optional</dt>
<dd>The options for the chart. Defaults to None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ColumnStackedChart(Chart):
    &#34;&#34;&#34;Class for a stacked column chart&#34;&#34;&#34;
    def __init__(self, name: str, columns: Tuple[Union[ColumnStackedSeries, XYSeries]], options: ChartOptions = None):
        &#34;&#34;&#34;
        Args:
            name (str): The name of the chart.
            columns (Tuple[Union[ColumnSeries, XYSeries]]): Iterable of stacked column series.
            options (Union[ChartOptions, dict], optional): The options for the chart. Defaults to None.
        &#34;&#34;&#34;
        super().__init__(name, options)
        self.columns: Tuple[Union[ColumnStackedSeries, XYSeries]] = columns

    @property
    def as_dict(self) -&gt; Dict:
        return self._get_dict({
            &#34;columns&#34;: [col.as_dict for col in self.columns],
            &#34;type&#34;: &#34;columnStacked&#34;
        })</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="apexofficeprint.elements.charts.Chart" href="#apexofficeprint.elements.charts.Chart">Chart</a></li>
<li><a title="apexofficeprint.elements.elements.Element" href="elements.html#apexofficeprint.elements.elements.Element">Element</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="apexofficeprint.elements.charts.Chart" href="#apexofficeprint.elements.charts.Chart">Chart</a></b></code>:
<ul class="hlist">
<li><code><a title="apexofficeprint.elements.charts.Chart.as_dict" href="elements.html#apexofficeprint.elements.elements.Element.as_dict">as_dict</a></code></li>
<li><code><a title="apexofficeprint.elements.charts.Chart.available_tags" href="elements.html#apexofficeprint.elements.elements.Element.available_tags">available_tags</a></code></li>
<li><code><a title="apexofficeprint.elements.charts.Chart.json" href="elements.html#apexofficeprint.elements.elements.Element.json">json</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="apexofficeprint.elements.charts.ColumnStackedPercentChart"><code class="flex name class">
<span>class <span class="ident">ColumnStackedPercentChart</span></span>
<span>(</span><span>name: str, columns: Tuple[<a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a>], options: <a title="apexofficeprint.elements.charts.ChartOptions" href="#apexofficeprint.elements.charts.ChartOptions">ChartOptions</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class for a stacked column chart with the x-axis expressed in percentage</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the chart.</dd>
<dt><strong><code>columns</code></strong> :&ensp;<code>Tuple[Union[<a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a>, <a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a>]]</code></dt>
<dd>Iterable of stacked column (percentage) series.</dd>
<dt><strong><code>options</code></strong> :&ensp;<code>Union[<a title="apexofficeprint.elements.charts.ChartOptions" href="#apexofficeprint.elements.charts.ChartOptions">ChartOptions</a>, dict]</code>, optional</dt>
<dd>The options for the chart. Defaults to None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ColumnStackedPercentChart(Chart):
    &#34;&#34;&#34;Class for a stacked column chart with the x-axis expressed in percentage&#34;&#34;&#34;
    def __init__(self, name: str, columns: Tuple[Union[ColumnStackedPercentSeries, XYSeries]], options: ChartOptions = None):
        &#34;&#34;&#34;
        Args:
            name (str): The name of the chart.
            columns (Tuple[Union[ColumnSeries, XYSeries]]): Iterable of stacked column (percentage) series.
            options (Union[ChartOptions, dict], optional): The options for the chart. Defaults to None.
        &#34;&#34;&#34;
        super().__init__(name, options)
        self.columns: Tuple[Union[ColumnStackedPercentSeries, XYSeries]] = columns

    @property
    def as_dict(self) -&gt; Dict:
        return self._get_dict({
            &#34;columns&#34;: [col.as_dict for col in self.columns],
            &#34;type&#34;: &#34;columnStackedPercent&#34;
        })</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="apexofficeprint.elements.charts.Chart" href="#apexofficeprint.elements.charts.Chart">Chart</a></li>
<li><a title="apexofficeprint.elements.elements.Element" href="elements.html#apexofficeprint.elements.elements.Element">Element</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="apexofficeprint.elements.charts.Chart" href="#apexofficeprint.elements.charts.Chart">Chart</a></b></code>:
<ul class="hlist">
<li><code><a title="apexofficeprint.elements.charts.Chart.as_dict" href="elements.html#apexofficeprint.elements.elements.Element.as_dict">as_dict</a></code></li>
<li><code><a title="apexofficeprint.elements.charts.Chart.available_tags" href="elements.html#apexofficeprint.elements.elements.Element.available_tags">available_tags</a></code></li>
<li><code><a title="apexofficeprint.elements.charts.Chart.json" href="elements.html#apexofficeprint.elements.elements.Element.json">json</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="apexofficeprint.elements.charts.CombinedChart"><code class="flex name class">
<span>class <span class="ident">CombinedChart</span></span>
<span>(</span><span>name: str, charts: Iterable[<a title="apexofficeprint.elements.charts.Chart" href="#apexofficeprint.elements.charts.Chart">Chart</a>], secondaryCharts: Iterable[<a title="apexofficeprint.elements.charts.Chart" href="#apexofficeprint.elements.charts.Chart">Chart</a>] = None, options: <a title="apexofficeprint.elements.charts.ChartOptions" href="#apexofficeprint.elements.charts.ChartOptions">ChartOptions</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class for a combined chart. It is possible to combine more than 2 types of chart but there can only be two value axes.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the chart.</dd>
<dt><strong><code>charts</code></strong> :&ensp;<code>Iterable[<a title="apexofficeprint.elements.charts.Chart" href="#apexofficeprint.elements.charts.Chart">Chart</a>]</code></dt>
<dd>Charts for the first y-axis.</dd>
<dt><strong><code>secondaryCharts</code></strong> :&ensp;<code>Iterable[<a title="apexofficeprint.elements.charts.Chart" href="#apexofficeprint.elements.charts.Chart">Chart</a>]</code>, optional</dt>
<dd>Charts for the secondary y-axis. Defaults to None.</dd>
<dt><strong><code>options</code></strong> :&ensp;<code><a title="apexofficeprint.elements.charts.ChartOptions" href="#apexofficeprint.elements.charts.ChartOptions">ChartOptions</a></code>, optional</dt>
<dd>The options for the chart. If not defined, the chartoptions of the first chart that has options will be used. Defaults to None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CombinedChart(Chart):
    &#34;&#34;&#34;Class for a combined chart. It is possible to combine more than 2 types of chart but there can only be two value axes.&#34;&#34;&#34;
    def __init__(self, name: str, charts: Iterable[Chart], secondaryCharts: Iterable[Chart] = None, options: ChartOptions = None):
        &#34;&#34;&#34;
        Args:
            name (str): The name of the chart.
            charts (Iterable[Chart]): Charts for the first y-axis.
            secondaryCharts (Iterable[Chart], optional): Charts for the secondary y-axis. Defaults to None.
            options (ChartOptions, optional): The options for the chart. If not defined, the chartoptions of the first chart that has options will be used. Defaults to None.
        &#34;&#34;&#34;
        if options is None:
            all_options = [chart.options.as_dict for chart in (
                tuple(charts) + tuple(secondaryCharts)) if chart.options is not None]
            options = {}
            # use reversed() to give the first charts precedence (they overwrite the others)
            for options in reversed(all_options):
                options.update(options)

        super().__init__(name, options)
        self.charts: Iterable[Chart] = charts
        self.secondaryCharts: Iterable[Chart] = secondaryCharts

    def _get_modified_chart_dicts(self) -&gt; List[Dict]:
        &#34;&#34;&#34;Remove the chart options from all charts in this combined chart object.
        Replace the y-axis with the y2-axis for the secondary charts.
        Add the dict representation for each chart to a list and return that list.

        Returns:
            List[Dict]: list containing the dict representation for each chart, after processing
        &#34;&#34;&#34;
        primary_list = list(self.charts)
        secondary_list = list(self.secondaryCharts)
        dict_list = []
        for chart in primary_list:
            chart_dict_full = chart.as_dict
            chart_dict = chart_dict_full[chart.name]
            chart_dict.pop(&#34;options&#34;, None)
            dict_list.append(chart_dict)
        for chart in secondary_list:
            chart_dict_full = chart.as_dict
            chart_dict = chart_dict_full[chart.name]
            chart_dict.pop(&#34;options&#34;, None)
            dict_list.append(_replace_key_recursive(chart_dict, &#34;y&#34;, &#34;y2&#34;))
        return dict_list

    @property
    def as_dict(self) -&gt; Dict:
        return self._get_dict({
            &#34;type&#34;: &#34;multiple&#34;,
            &#34;multiples&#34;: self._get_modified_chart_dicts()
        })</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="apexofficeprint.elements.charts.Chart" href="#apexofficeprint.elements.charts.Chart">Chart</a></li>
<li><a title="apexofficeprint.elements.elements.Element" href="elements.html#apexofficeprint.elements.elements.Element">Element</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="apexofficeprint.elements.charts.Chart" href="#apexofficeprint.elements.charts.Chart">Chart</a></b></code>:
<ul class="hlist">
<li><code><a title="apexofficeprint.elements.charts.Chart.as_dict" href="elements.html#apexofficeprint.elements.elements.Element.as_dict">as_dict</a></code></li>
<li><code><a title="apexofficeprint.elements.charts.Chart.available_tags" href="elements.html#apexofficeprint.elements.elements.Element.available_tags">available_tags</a></code></li>
<li><code><a title="apexofficeprint.elements.charts.Chart.json" href="elements.html#apexofficeprint.elements.elements.Element.json">json</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="apexofficeprint.elements.charts.DoughnutChart"><code class="flex name class">
<span>class <span class="ident">DoughnutChart</span></span>
<span>(</span><span>name: str, doughnuts: Tuple[Union[<a title="apexofficeprint.elements.charts.PieSeries" href="#apexofficeprint.elements.charts.PieSeries">PieSeries</a>, <a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a>]], options: <a title="apexofficeprint.elements.charts.ChartOptions" href="#apexofficeprint.elements.charts.ChartOptions">ChartOptions</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class for a doughnut chart</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the chart.</dd>
<dt><strong><code>doughnuts</code></strong> :&ensp;<code>Tuple[Union[<a title="apexofficeprint.elements.charts.PieSeries" href="#apexofficeprint.elements.charts.PieSeries">PieSeries</a>, <a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a>]]</code></dt>
<dd>Iterable of doughnut series.</dd>
<dt><strong><code>options</code></strong> :&ensp;<code>Union[<a title="apexofficeprint.elements.charts.ChartOptions" href="#apexofficeprint.elements.charts.ChartOptions">ChartOptions</a>, dict]</code>, optional</dt>
<dd>The options for the chart. Defaults to None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DoughnutChart(Chart):
    &#34;&#34;&#34;Class for a doughnut chart&#34;&#34;&#34;
    def __init__(self, name: str, doughnuts: Tuple[Union[PieSeries, XYSeries]], options: ChartOptions = None):
        &#34;&#34;&#34;
        Args:
            name (str): The name of the chart.
            doughnuts (Tuple[Union[PieSeries, XYSeries]]): Iterable of doughnut series.
            options (Union[ChartOptions, dict], optional): The options for the chart. Defaults to None.
        &#34;&#34;&#34;
        super().__init__(name, options)
        self.doughnuts: Tuple[Union[PieSeries, XYSeries]] = doughnuts

    @property
    def as_dict(self) -&gt; Dict:
        return self._get_dict({
            &#34;doughnuts&#34;: [nut.as_dict for nut in self.doughnuts],
            &#34;type&#34;: &#34;doughnut&#34;
        })</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="apexofficeprint.elements.charts.Chart" href="#apexofficeprint.elements.charts.Chart">Chart</a></li>
<li><a title="apexofficeprint.elements.elements.Element" href="elements.html#apexofficeprint.elements.elements.Element">Element</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="apexofficeprint.elements.charts.Chart" href="#apexofficeprint.elements.charts.Chart">Chart</a></b></code>:
<ul class="hlist">
<li><code><a title="apexofficeprint.elements.charts.Chart.as_dict" href="elements.html#apexofficeprint.elements.elements.Element.as_dict">as_dict</a></code></li>
<li><code><a title="apexofficeprint.elements.charts.Chart.available_tags" href="elements.html#apexofficeprint.elements.elements.Element.available_tags">available_tags</a></code></li>
<li><code><a title="apexofficeprint.elements.charts.Chart.json" href="elements.html#apexofficeprint.elements.elements.Element.json">json</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="apexofficeprint.elements.charts.LineChart"><code class="flex name class">
<span>class <span class="ident">LineChart</span></span>
<span>(</span><span>name: str, lines: Tuple[Union[<a title="apexofficeprint.elements.charts.LineSeries" href="#apexofficeprint.elements.charts.LineSeries">LineSeries</a>, <a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a>]], options: <a title="apexofficeprint.elements.charts.ChartOptions" href="#apexofficeprint.elements.charts.ChartOptions">ChartOptions</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class for a line chart</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the chart.</dd>
<dt><strong><code>lines</code></strong> :&ensp;<code>Tuple[Union[<a title="apexofficeprint.elements.charts.LineSeries" href="#apexofficeprint.elements.charts.LineSeries">LineSeries</a>, <a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a>]]</code></dt>
<dd>Iterable of line series.</dd>
<dt><strong><code>options</code></strong> :&ensp;<code>Union[<a title="apexofficeprint.elements.charts.ChartOptions" href="#apexofficeprint.elements.charts.ChartOptions">ChartOptions</a>, dict]</code>, optional</dt>
<dd>The options for the chart. Defaults to None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LineChart(Chart):
    &#34;&#34;&#34;Class for a line chart&#34;&#34;&#34;
    def __init__(self, name: str, lines: Tuple[Union[LineSeries, XYSeries]], options: ChartOptions = None):
        &#34;&#34;&#34;
        Args:
            name (str): The name of the chart.
            lines (Tuple[Union[LineSeries, XYSeries]]): Iterable of line series.
            options (Union[ChartOptions, dict], optional): The options for the chart. Defaults to None.
        &#34;&#34;&#34;
        super().__init__(name, options)
        self.lines: Tuple[Union[LineSeries, XYSeries]] = lines

    @property
    def as_dict(self) -&gt; Dict:
        return self._get_dict({
            &#34;lines&#34;: [line.as_dict for line in self.lines],
            &#34;type&#34;: &#34;line&#34;
        })</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="apexofficeprint.elements.charts.Chart" href="#apexofficeprint.elements.charts.Chart">Chart</a></li>
<li><a title="apexofficeprint.elements.elements.Element" href="elements.html#apexofficeprint.elements.elements.Element">Element</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="apexofficeprint.elements.charts.Chart" href="#apexofficeprint.elements.charts.Chart">Chart</a></b></code>:
<ul class="hlist">
<li><code><a title="apexofficeprint.elements.charts.Chart.as_dict" href="elements.html#apexofficeprint.elements.elements.Element.as_dict">as_dict</a></code></li>
<li><code><a title="apexofficeprint.elements.charts.Chart.available_tags" href="elements.html#apexofficeprint.elements.elements.Element.available_tags">available_tags</a></code></li>
<li><code><a title="apexofficeprint.elements.charts.Chart.json" href="elements.html#apexofficeprint.elements.elements.Element.json">json</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="apexofficeprint.elements.charts.LineSeries"><code class="flex name class">
<span>class <span class="ident">LineSeries</span></span>
<span>(</span><span>x: Iterable[Union[int, float, str]], y: Iterable[Union[int, float]], name: str = None, smooth: bool = None, symbol: str = None, symbol_size: Union[str, int] = None, color: str = None, line_width: str = None, line_style: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>A series for a line chart.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>Iterable[Union[int, float, str]]</code></dt>
<dd>The data for the x-axis.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>Iterable[Union[int, float]]</code></dt>
<dd>The data for the y-axis.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The name of the series. Defaults to None.</dd>
<dt><strong><code>smooth</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether or not the corners of the angles formed in the data-points are smoothened. Defaults to None.</dd>
<dt><strong><code>symbol</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Symbol representing the datapoints. Can be square (default), diamond or triangle. Defaults to None.</dd>
<dt><strong><code>symbol_size</code></strong> :&ensp;<code>Union[str, int]</code>, optional</dt>
<dd>Size of the symbol representing the data-points in (in em, pt, px, cm or in), by default: automatic. Defaults to None.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The color in which the series should be shown on a chart.
Can be html/css colors or hex values. Defaults to None.</dd>
<dt><strong><code>line_width</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Thickness of the connecting line in em, pt, px, cm or in. Defaults to None.</dd>
<dt><strong><code>line_style</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Style of the line. Supported options can be found online on the <a href="https://www.apexofficeprint.com/docs/#line">AOP documentation</a>. Defaults to None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LineSeries(XYSeries):
    &#34;&#34;&#34;A series for a line chart.&#34;&#34;&#34;
    def __init__(self,
                 x: Iterable[Union[int, float, str]],
                 y: Iterable[Union[int, float]],
                 name: str = None,
                 smooth: bool = None,
                 symbol: str = None,
                 symbol_size: Union[str, int] = None,
                 color: str = None,
                 line_width: str = None,
                 line_style: str = None):
        &#34;&#34;&#34;
        Args:
            x (Iterable[Union[int, float, str]]): The data for the x-axis.
            y (Iterable[Union[int, float]]): The data for the y-axis.
            name (str, optional): The name of the series. Defaults to None.
            smooth (bool, optional): Whether or not the corners of the angles formed in the data-points are smoothened. Defaults to None.
            symbol (str, optional): Symbol representing the datapoints. Can be square (default), diamond or triangle. Defaults to None.
            symbol_size (Union[str, int], optional): Size of the symbol representing the data-points in (in em, pt, px, cm or in), by default: automatic. Defaults to None.
            color (str, optional): The color in which the series should be shown on a chart.
                Can be html/css colors or hex values. Defaults to None.
            line_width (str, optional): Thickness of the connecting line in em, pt, px, cm or in. Defaults to None.
            line_style (str, optional): Style of the line. Supported options can be found online on the [AOP documentation](https://www.apexofficeprint.com/docs/#line). Defaults to None.
        &#34;&#34;&#34;
        super().__init__(x, y, name, color)
        self.smooth: bool = smooth
        self.symbol: str = symbol
        self.symbol_size: Union[str, int] = symbol_size
        self.line_width: str = line_width
        self.line_style: str = line_style

    @property
    def as_dict(self) -&gt; Dict:
        result = super().as_dict

        if self.smooth is not None:
            result[&#34;smooth&#34;] = self.smooth
        if self.symbol is not None:
            result[&#34;symbol&#34;] = self.symbol
        if self.symbol_size is not None:
            result[&#34;symbolSize&#34;] = self.symbol_size
        if self.line_width is not None:
            result[&#34;lineWidth&#34;] = self.line_width
        if self.line_style is not None:
            result[&#34;lineStyle&#34;] = self.line_style
        
        return result</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a></li>
<li><a title="apexofficeprint.elements.charts.Series" href="#apexofficeprint.elements.charts.Series">Series</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="apexofficeprint.elements.charts.LineSeries.as_dict"><code class="name">var <span class="ident">as_dict</span> : Dict</code></dt>
<dd>
<div class="desc"><p>The dict representation of this Series object.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict</code></dt>
<dd>dict representation of this Series object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def as_dict(self) -&gt; Dict:
    result = super().as_dict

    if self.smooth is not None:
        result[&#34;smooth&#34;] = self.smooth
    if self.symbol is not None:
        result[&#34;symbol&#34;] = self.symbol
    if self.symbol_size is not None:
        result[&#34;symbolSize&#34;] = self.symbol_size
    if self.line_width is not None:
        result[&#34;lineWidth&#34;] = self.line_width
    if self.line_style is not None:
        result[&#34;lineStyle&#34;] = self.line_style
    
    return result</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="apexofficeprint.elements.charts.LineSeries"><code class="flex name class">
<span>class <span class="ident">RadarSeries</span></span>
<span>(</span><span>x: Iterable[Union[int, float, str]], y: Iterable[Union[int, float]], name: str = None, smooth: bool = None, symbol: str = None, symbol_size: Union[str, int] = None, color: str = None, line_width: str = None, line_style: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>A series for a line chart.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>Iterable[Union[int, float, str]]</code></dt>
<dd>The data for the x-axis.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>Iterable[Union[int, float]]</code></dt>
<dd>The data for the y-axis.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The name of the series. Defaults to None.</dd>
<dt><strong><code>smooth</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether or not the corners of the angles formed in the data-points are smoothened. Defaults to None.</dd>
<dt><strong><code>symbol</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Symbol representing the datapoints. Can be square (default), diamond or triangle. Defaults to None.</dd>
<dt><strong><code>symbol_size</code></strong> :&ensp;<code>Union[str, int]</code>, optional</dt>
<dd>Size of the symbol representing the data-points in (in em, pt, px, cm or in), by default: automatic. Defaults to None.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The color in which the series should be shown on a chart.
Can be html/css colors or hex values. Defaults to None.</dd>
<dt><strong><code>line_width</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Thickness of the connecting line in em, pt, px, cm or in. Defaults to None.</dd>
<dt><strong><code>line_style</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Style of the line. Supported options can be found online on the <a href="https://www.apexofficeprint.com/docs/#line">AOP documentation</a>. Defaults to None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LineSeries(XYSeries):
    &#34;&#34;&#34;A series for a line chart.&#34;&#34;&#34;
    def __init__(self,
                 x: Iterable[Union[int, float, str]],
                 y: Iterable[Union[int, float]],
                 name: str = None,
                 smooth: bool = None,
                 symbol: str = None,
                 symbol_size: Union[str, int] = None,
                 color: str = None,
                 line_width: str = None,
                 line_style: str = None):
        &#34;&#34;&#34;
        Args:
            x (Iterable[Union[int, float, str]]): The data for the x-axis.
            y (Iterable[Union[int, float]]): The data for the y-axis.
            name (str, optional): The name of the series. Defaults to None.
            smooth (bool, optional): Whether or not the corners of the angles formed in the data-points are smoothened. Defaults to None.
            symbol (str, optional): Symbol representing the datapoints. Can be square (default), diamond or triangle. Defaults to None.
            symbol_size (Union[str, int], optional): Size of the symbol representing the data-points in (in em, pt, px, cm or in), by default: automatic. Defaults to None.
            color (str, optional): The color in which the series should be shown on a chart.
                Can be html/css colors or hex values. Defaults to None.
            line_width (str, optional): Thickness of the connecting line in em, pt, px, cm or in. Defaults to None.
            line_style (str, optional): Style of the line. Supported options can be found online on the [AOP documentation](https://www.apexofficeprint.com/docs/#line). Defaults to None.
        &#34;&#34;&#34;
        super().__init__(x, y, name, color)
        self.smooth: bool = smooth
        self.symbol: str = symbol
        self.symbol_size: Union[str, int] = symbol_size
        self.line_width: str = line_width
        self.line_style: str = line_style

    @property
    def as_dict(self) -&gt; Dict:
        result = super().as_dict

        if self.smooth is not None:
            result[&#34;smooth&#34;] = self.smooth
        if self.symbol is not None:
            result[&#34;symbol&#34;] = self.symbol
        if self.symbol_size is not None:
            result[&#34;symbolSize&#34;] = self.symbol_size
        if self.line_width is not None:
            result[&#34;lineWidth&#34;] = self.line_width
        if self.line_style is not None:
            result[&#34;lineStyle&#34;] = self.line_style
        
        return result</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a></li>
<li><a title="apexofficeprint.elements.charts.Series" href="#apexofficeprint.elements.charts.Series">Series</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a></b></code>:
<ul class="hlist">
<li><code><a title="apexofficeprint.elements.charts.XYSeries.as_dict" href="#apexofficeprint.elements.charts.Series.as_dict">as_dict</a></code></li>
<li><code><a title="apexofficeprint.elements.charts.XYSeries.data" href="#apexofficeprint.elements.charts.Series.data">data</a></code></li>
<li><code><a title="apexofficeprint.elements.charts.XYSeries.from_dataframe" href="#apexofficeprint.elements.charts.XYSeries.from_dataframe">from_dataframe</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="apexofficeprint.elements.charts.Pie3DChart"><code class="flex name class">
<span>class <span class="ident">Pie3DChart</span></span>
<span>(</span><span>name: str, pies: Tuple[Union[<a title="apexofficeprint.elements.charts.PieSeries" href="#apexofficeprint.elements.charts.PieSeries">PieSeries</a>, <a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a>]], options: <a title="apexofficeprint.elements.charts.ChartOptions" href="#apexofficeprint.elements.charts.ChartOptions">ChartOptions</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class for a 3D pie chart</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the chart.</dd>
<dt><strong><code>pies</code></strong> :&ensp;<code>Tuple[Union[<a title="apexofficeprint.elements.charts.PieSeries" href="#apexofficeprint.elements.charts.PieSeries">PieSeries</a>, <a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a>]]</code></dt>
<dd>Iterable of 3D pie series.</dd>
<dt><strong><code>options</code></strong> :&ensp;<code>Union[<a title="apexofficeprint.elements.charts.ChartOptions" href="#apexofficeprint.elements.charts.ChartOptions">ChartOptions</a>, dict]</code>, optional</dt>
<dd>The options for the chart. Defaults to None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Pie3DChart(Chart):
    &#34;&#34;&#34;Class for a 3D pie chart&#34;&#34;&#34;
    def __init__(self, name: str, pies: Tuple[Union[PieSeries, XYSeries]], options: ChartOptions = None):
        &#34;&#34;&#34;
        Args:
            name (str): The name of the chart.
            pies (Tuple[Union[PieSeries, XYSeries]]): Iterable of 3D pie series.
            options (Union[ChartOptions, dict], optional): The options for the chart. Defaults to None.
        &#34;&#34;&#34;
        super().__init__(name, options)
        self.pies: Tuple[Union[PieSeries, XYSeries]] = pies

    @property
    def as_dict(self) -&gt; Dict:
        return self._get_dict({
            &#34;pies&#34;: [pie.as_dict for pie in self.pies],
            &#34;type&#34;: &#34;pie3d&#34;
        })</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="apexofficeprint.elements.charts.Chart" href="#apexofficeprint.elements.charts.Chart">Chart</a></li>
<li><a title="apexofficeprint.elements.elements.Element" href="elements.html#apexofficeprint.elements.elements.Element">Element</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="apexofficeprint.elements.charts.Chart" href="#apexofficeprint.elements.charts.Chart">Chart</a></b></code>:
<ul class="hlist">
<li><code><a title="apexofficeprint.elements.charts.Chart.as_dict" href="elements.html#apexofficeprint.elements.elements.Element.as_dict">as_dict</a></code></li>
<li><code><a title="apexofficeprint.elements.charts.Chart.available_tags" href="elements.html#apexofficeprint.elements.elements.Element.available_tags">available_tags</a></code></li>
<li><code><a title="apexofficeprint.elements.charts.Chart.json" href="elements.html#apexofficeprint.elements.elements.Element.json">json</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="apexofficeprint.elements.charts.PieChart"><code class="flex name class">
<span>class <span class="ident">PieChart</span></span>
<span>(</span><span>name: str, pies: Tuple[Union[<a title="apexofficeprint.elements.charts.PieSeries" href="#apexofficeprint.elements.charts.PieSeries">PieSeries</a>, <a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a>]], options: <a title="apexofficeprint.elements.charts.ChartOptions" href="#apexofficeprint.elements.charts.ChartOptions">ChartOptions</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class for a pie chart</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the chart.</dd>
<dt><strong><code>pies</code></strong> :&ensp;<code>Tuple[Union[<a title="apexofficeprint.elements.charts.PieSeries" href="#apexofficeprint.elements.charts.PieSeries">PieSeries</a>, <a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a>]]</code></dt>
<dd>Iterable of pie series.</dd>
<dt><strong><code>options</code></strong> :&ensp;<code>Union[<a title="apexofficeprint.elements.charts.ChartOptions" href="#apexofficeprint.elements.charts.ChartOptions">ChartOptions</a>, dict]</code>, optional</dt>
<dd>The options for the chart. Defaults to None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PieChart(Chart):
    &#34;&#34;&#34;Class for a pie chart&#34;&#34;&#34;
    def __init__(self, name: str, pies: Tuple[Union[PieSeries, XYSeries]], options: ChartOptions = None):
        &#34;&#34;&#34;
        Args:
            name (str): The name of the chart.
            pies (Tuple[Union[PieSeries, XYSeries]]): Iterable of pie series.
            options (Union[ChartOptions, dict], optional): The options for the chart. Defaults to None.
        &#34;&#34;&#34;
        super().__init__(name, options)
        self.pies: Tuple[Union[PieSeries, XYSeries]] = pies

    @property
    def as_dict(self) -&gt; Dict:
        return self._get_dict({
            &#34;pies&#34;: [pie.as_dict for pie in self.pies],
            &#34;type&#34;: &#34;pie&#34;
        })</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="apexofficeprint.elements.charts.Chart" href="#apexofficeprint.elements.charts.Chart">Chart</a></li>
<li><a title="apexofficeprint.elements.elements.Element" href="elements.html#apexofficeprint.elements.elements.Element">Element</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="apexofficeprint.elements.charts.Chart" href="#apexofficeprint.elements.charts.Chart">Chart</a></b></code>:
<ul class="hlist">
<li><code><a title="apexofficeprint.elements.charts.Chart.as_dict" href="elements.html#apexofficeprint.elements.elements.Element.as_dict">as_dict</a></code></li>
<li><code><a title="apexofficeprint.elements.charts.Chart.available_tags" href="elements.html#apexofficeprint.elements.elements.Element.available_tags">available_tags</a></code></li>
<li><code><a title="apexofficeprint.elements.charts.Chart.json" href="elements.html#apexofficeprint.elements.elements.Element.json">json</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="apexofficeprint.elements.charts.PieSeries"><code class="flex name class">
<span>class <span class="ident">PieSeries</span></span>
<span>(</span><span>x: Iterable[Union[int, float, str]], y: Iterable[Union[int, float]], name: str = None, colors: Iterable[str] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>A series for pie charts.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>Iterable[Union[int, float, str]]</code></dt>
<dd>The data for the x-axis.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>Iterable[Union[int, float]]</code></dt>
<dd>The data for the y-axis.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The name of the series. Defaults to None.</dd>
<dt><strong><code>colors</code></strong> :&ensp;<code>Iterable[str]</code>, optional</dt>
<dd>Should be an iterable that contains the color for each specific pie slice.
If no colors are specified, the document's theme color is used.
If some colors are specified, but not for all data points, random colors will fill the gaps.
The value for non-specified colors must be None.
Warning: this is not the same as self.color of XYSeries, which is the color for the entire series, but this is not applicable to PieSeries.
Defaults to None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PieSeries(XYSeries):
    &#34;&#34;&#34;A series for pie charts.&#34;&#34;&#34;
    def __init__(self,
                 x: Iterable[Union[int, float, str]],
                 y: Iterable[Union[int, float]],
                 name: str = None,
                 colors: Iterable[str] = None):
        &#34;&#34;&#34;
        Args:
            x (Iterable[Union[int, float, str]]): The data for the x-axis.
            y (Iterable[Union[int, float]]): The data for the y-axis.
            name (str, optional): The name of the series. Defaults to None.
            colors (Iterable[str], optional): Should be an iterable that contains the color for each specific pie slice.
                If no colors are specified, the document&#39;s theme color is used.
                If some colors are specified, but not for all data points, random colors will fill the gaps.
                The value for non-specified colors must be None.
                Warning: this is not the same as self.color of XYSeries, which is the color for the entire series, but this is not applicable to PieSeries.
                Defaults to None.
        &#34;&#34;&#34;
        super().__init__(x, y, name)
        self.colors = colors

    @property
    def as_dict(self) -&gt; Dict:
        result = super().as_dict

        if self.colors is not None:
            # Add the color for each slice to &#39;data&#39;
            for i in range(len(tuple(self.colors))):
                if self.colors[i] is not None:
                    result[&#34;data&#34;][i][&#39;color&#39;] = self.colors[i]

        return result</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a></li>
<li><a title="apexofficeprint.elements.charts.Series" href="#apexofficeprint.elements.charts.Series">Series</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a></b></code>:
<ul class="hlist">
<li><code><a title="apexofficeprint.elements.charts.XYSeries.as_dict" href="#apexofficeprint.elements.charts.Series.as_dict">as_dict</a></code></li>
<li><code><a title="apexofficeprint.elements.charts.XYSeries.data" href="#apexofficeprint.elements.charts.Series.data">data</a></code></li>
<li><code><a title="apexofficeprint.elements.charts.XYSeries.from_dataframe" href="#apexofficeprint.elements.charts.XYSeries.from_dataframe">from_dataframe</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="apexofficeprint.elements.charts.RadarChart"><code class="flex name class">
<span>class <span class="ident">RadarChart</span></span>
<span>(</span><span>name: str, radars: Tuple[Union[<a title="apexofficeprint.elements.charts.LineSeries" href="#apexofficeprint.elements.charts.LineSeries">LineSeries</a>, <a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a>]], options: <a title="apexofficeprint.elements.charts.ChartOptions" href="#apexofficeprint.elements.charts.ChartOptions">ChartOptions</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class for a radar chart</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the chart.</dd>
<dt><strong><code>radars</code></strong> :&ensp;<code>Tuple[Union[<a title="apexofficeprint.elements.charts.LineSeries" href="#apexofficeprint.elements.charts.LineSeries">LineSeries</a>, <a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a>]]</code></dt>
<dd>Iterable of radar series.</dd>
<dt><strong><code>options</code></strong> :&ensp;<code>Union[<a title="apexofficeprint.elements.charts.ChartOptions" href="#apexofficeprint.elements.charts.ChartOptions">ChartOptions</a>, dict]</code>, optional</dt>
<dd>The options for the chart. Defaults to None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RadarChart(Chart):
    &#34;&#34;&#34;Class for a radar chart&#34;&#34;&#34;
    def __init__(self, name: str, radars: Tuple[Union[RadarSeries, XYSeries]], options: ChartOptions = None):
        &#34;&#34;&#34;
        Args:
            name (str): The name of the chart.
            radars (Tuple[Union[RadarSeries, XYSeries]]): Iterable of radar series.
            options (Union[ChartOptions, dict], optional): The options for the chart. Defaults to None.
        &#34;&#34;&#34;
        super().__init__(name, options)
        self.radars: Tuple[Union[RadarSeries, XYSeries]] = radars

    @property
    def as_dict(self) -&gt; Dict:
        return self._get_dict({
            &#34;radars&#34;: [radar.as_dict for radar in self.radars],
            &#34;type&#34;: &#34;radar&#34;
        })</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="apexofficeprint.elements.charts.Chart" href="#apexofficeprint.elements.charts.Chart">Chart</a></li>
<li><a title="apexofficeprint.elements.elements.Element" href="elements.html#apexofficeprint.elements.elements.Element">Element</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="apexofficeprint.elements.charts.Chart" href="#apexofficeprint.elements.charts.Chart">Chart</a></b></code>:
<ul class="hlist">
<li><code><a title="apexofficeprint.elements.charts.Chart.as_dict" href="elements.html#apexofficeprint.elements.elements.Element.as_dict">as_dict</a></code></li>
<li><code><a title="apexofficeprint.elements.charts.Chart.available_tags" href="elements.html#apexofficeprint.elements.elements.Element.available_tags">available_tags</a></code></li>
<li><code><a title="apexofficeprint.elements.charts.Chart.json" href="elements.html#apexofficeprint.elements.elements.Element.json">json</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="apexofficeprint.elements.charts.ScatterChart"><code class="flex name class">
<span>class <span class="ident">ScatterChart</span></span>
<span>(</span><span>name: str, scatters: Tuple[<a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a>], options: <a title="apexofficeprint.elements.charts.ChartOptions" href="#apexofficeprint.elements.charts.ChartOptions">ChartOptions</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class for a scatter chart</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the chart.</dd>
<dt><strong><code>scatters</code></strong> :&ensp;<code>Tuple[Union[<a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a>, <a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a>]]</code></dt>
<dd>Iterable of scatter series.</dd>
<dt><strong><code>options</code></strong> :&ensp;<code>Union[<a title="apexofficeprint.elements.charts.ChartOptions" href="#apexofficeprint.elements.charts.ChartOptions">ChartOptions</a>, dict]</code>, optional</dt>
<dd>The options for the chart. Defaults to None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ScatterChart(Chart):
    &#34;&#34;&#34;Class for a scatter chart&#34;&#34;&#34;
    def __init__(self, name: str, scatters: Tuple[Union[ScatterSeries, XYSeries]], options: ChartOptions = None):
        &#34;&#34;&#34;
        Args:
            name (str): The name of the chart.
            scatters (Tuple[Union[ScatterSeries, XYSeries]]): Iterable of scatter series.
            options (Union[ChartOptions, dict], optional): The options for the chart. Defaults to None.
        &#34;&#34;&#34;
        super().__init__(name, options)
        self.scatters: Tuple[Union[ScatterSeries, XYSeries]] = scatters

    @property
    def as_dict(self) -&gt; Dict:
        return self._get_dict({
            &#34;scatters&#34;: [scatter.as_dict for scatter in self.scatters],
            &#34;type&#34;: &#34;scatter&#34;
        })</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="apexofficeprint.elements.charts.Chart" href="#apexofficeprint.elements.charts.Chart">Chart</a></li>
<li><a title="apexofficeprint.elements.elements.Element" href="elements.html#apexofficeprint.elements.elements.Element">Element</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="apexofficeprint.elements.charts.Chart" href="#apexofficeprint.elements.charts.Chart">Chart</a></b></code>:
<ul class="hlist">
<li><code><a title="apexofficeprint.elements.charts.Chart.as_dict" href="elements.html#apexofficeprint.elements.elements.Element.as_dict">as_dict</a></code></li>
<li><code><a title="apexofficeprint.elements.charts.Chart.available_tags" href="elements.html#apexofficeprint.elements.elements.Element.available_tags">available_tags</a></code></li>
<li><code><a title="apexofficeprint.elements.charts.Chart.json" href="elements.html#apexofficeprint.elements.elements.Element.json">json</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="apexofficeprint.elements.charts.Series"><code class="flex name class">
<span>class <span class="ident">Series</span></span>
<span>(</span><span>name: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Abstract base class for a series.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Series(ABC):
    &#34;&#34;&#34;Abstract base class for a series.&#34;&#34;&#34;
    def __init__(self, name: str = None):
        self.name: str = name

    @property
    @abstractmethod
    def data(self):
        &#34;&#34;&#34;Get the data used in the series. E.g. x-values, y-values, ...&#34;&#34;&#34;
        pass

    @property
    def as_dict(self) -&gt; Dict:
        &#34;&#34;&#34;The dict representation of this Series object.

        Returns:
            Dict: dict representation of this Series object
        &#34;&#34;&#34;
        result = {
            &#34;data&#34;: self.data
        }

        if self.name is not None:
            result[&#34;name&#34;] = self.name

        return result</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="apexofficeprint.elements.charts.StockSeries" href="#apexofficeprint.elements.charts.StockSeries">StockSeries</a></li>
<li><a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="apexofficeprint.elements.charts.Series.as_dict"><code class="name">var <span class="ident">as_dict</span> : Dict</code></dt>
<dd>
<div class="desc"><p>The dict representation of this Series object.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict</code></dt>
<dd>dict representation of this Series object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def as_dict(self) -&gt; Dict:
    &#34;&#34;&#34;The dict representation of this Series object.

    Returns:
        Dict: dict representation of this Series object
    &#34;&#34;&#34;
    result = {
        &#34;data&#34;: self.data
    }

    if self.name is not None:
        result[&#34;name&#34;] = self.name

    return result</code></pre>
</details>
</dd>
<dt id="apexofficeprint.elements.charts.Series.data"><code class="name">var <span class="ident">data</span></code></dt>
<dd>
<div class="desc"><p>Get the data used in the series. E.g. x-values, y-values, &hellip;</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@abstractmethod
def data(self):
    &#34;&#34;&#34;Get the data used in the series. E.g. x-values, y-values, ...&#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="apexofficeprint.elements.charts.StockChart"><code class="flex name class">
<span>class <span class="ident">StockChart</span></span>
<span>(</span><span>name: str, stocks: Tuple[<a title="apexofficeprint.elements.charts.StockSeries" href="#apexofficeprint.elements.charts.StockSeries">StockSeries</a>], options: <a title="apexofficeprint.elements.charts.ChartOptions" href="#apexofficeprint.elements.charts.ChartOptions">ChartOptions</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class for a candlestick chart</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the chart.</dd>
<dt><strong><code>stocks</code></strong> :&ensp;<code>Tuple[<a title="apexofficeprint.elements.charts.StockSeries" href="#apexofficeprint.elements.charts.StockSeries">StockSeries</a>]</code></dt>
<dd>Iterable of stock series.</dd>
<dt><strong><code>options</code></strong> :&ensp;<code>Union[<a title="apexofficeprint.elements.charts.ChartOptions" href="#apexofficeprint.elements.charts.ChartOptions">ChartOptions</a>, dict]</code>, optional</dt>
<dd>The options for the chart. Defaults to None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StockChart(Chart):
    &#34;&#34;&#34;Class for a candlestick chart&#34;&#34;&#34;
    def __init__(self, name: str, stocks: Tuple[StockSeries], options: ChartOptions = None):
        &#34;&#34;&#34;
        Args:
            name (str): The name of the chart.
            stocks (Tuple[StockSeries]): Iterable of stock series.
            options (Union[ChartOptions, dict], optional): The options for the chart. Defaults to None.
        &#34;&#34;&#34;
        super().__init__(name, options)
        self.stocks: Tuple[StockSeries] = stocks

    @property
    def as_dict(self) -&gt; Dict:
        return self._get_dict({
            &#34;stocks&#34;: [stock.as_dict for stock in self.stocks],
            &#34;type&#34;: &#34;stock&#34;
        })</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="apexofficeprint.elements.charts.Chart" href="#apexofficeprint.elements.charts.Chart">Chart</a></li>
<li><a title="apexofficeprint.elements.elements.Element" href="elements.html#apexofficeprint.elements.elements.Element">Element</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="apexofficeprint.elements.charts.Chart" href="#apexofficeprint.elements.charts.Chart">Chart</a></b></code>:
<ul class="hlist">
<li><code><a title="apexofficeprint.elements.charts.Chart.as_dict" href="elements.html#apexofficeprint.elements.elements.Element.as_dict">as_dict</a></code></li>
<li><code><a title="apexofficeprint.elements.charts.Chart.available_tags" href="elements.html#apexofficeprint.elements.elements.Element.available_tags">available_tags</a></code></li>
<li><code><a title="apexofficeprint.elements.charts.Chart.json" href="elements.html#apexofficeprint.elements.elements.Element.json">json</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="apexofficeprint.elements.charts.StockSeries"><code class="flex name class">
<span>class <span class="ident">StockSeries</span></span>
<span>(</span><span>x: Iterable[Union[int, float, str]], high: Iterable[Union[int, float]], low: Iterable[Union[int, float]], close: Iterable[Union[int, float]], open_: Iterable[Union[int, float]] = None, volume: Iterable[Union[int, float]] = None, name: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>A series for candlestick charts.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>Iterable[Union[int, float, str]]</code></dt>
<dd>The data for the x-axis.</dd>
<dt><strong><code>high</code></strong> :&ensp;<code>Iterable[Union[int, float]]</code></dt>
<dd>The data for the hight prices.</dd>
<dt><strong><code>low</code></strong> :&ensp;<code>Iterable[Union[int, float]]</code></dt>
<dd>The data for the low prices.</dd>
<dt><strong><code>close</code></strong> :&ensp;<code>Iterable[Union[int, float]]</code></dt>
<dd>The data for the closing prices.</dd>
<dt><strong><code>open_</code></strong> :&ensp;<code>Iterable[Union[int, float]]</code>, optional</dt>
<dd>The data for the opening prices. Defaults to None.</dd>
<dt><strong><code>volume</code></strong> :&ensp;<code>Iterable[Union[int, float]]</code>, optional</dt>
<dd>The data for the volumes. Defaults to None.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The name of the series. Defaults to None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StockSeries(Series):
    &#34;&#34;&#34;A series for candlestick charts.&#34;&#34;&#34;
    def __init__(self,
                 x: Iterable[Union[int, float, str]],
                 high: Iterable[Union[int, float]],
                 low: Iterable[Union[int, float]],
                 close: Iterable[Union[int, float]],
                 open_: Iterable[Union[int, float]] = None,
                 volume: Iterable[Union[int, float]] = None,
                 name: str = None):
        &#34;&#34;&#34;
        Args:
            x (Iterable[Union[int, float, str]]): The data for the x-axis.
            high (Iterable[Union[int, float]]): The data for the hight prices.
            low (Iterable[Union[int, float]]): The data for the low prices.
            close (Iterable[Union[int, float]]): The data for the closing prices.
            open_ (Iterable[Union[int, float]], optional): The data for the opening prices. Defaults to None.
            volume (Iterable[Union[int, float]], optional): The data for the volumes. Defaults to None.
            name (str, optional): The name of the series. Defaults to None.
        &#34;&#34;&#34;
        super().__init__(name)
        self.x: Iterable[Union[int, float, str]] = x
        self.high: Iterable[Union[int, float]] = high
        self.low: Iterable[Union[int, float]] = low
        self.close: Iterable[Union[int, float]] = close
        # open argument gets a trailing _ because open() is a built-in function
        self.open: Iterable[Union[int, float]] = open_
        self.volume: Iterable[Union[int, float]] = volume

    @property
    def data(self):
        result = [{
            &#34;x&#34;: x,
            &#34;high&#34;: high,
            &#34;low&#34;: low,
            &#34;close&#34;: close
        } for x, high, low, close in zip(self.x, self.high, self.low, self.close)]

        for i in range(len(result)):
            if self.open is not None:
                result[i][&#34;open&#34;] = self.open[i]
            if self.volume is not None:
                result[i][&#34;volume&#34;] = self.volume[i]

        return result

    @classmethod
    def from_dataframe(cls, data: &#39;pandas.DataFrame&#39;, name: str = None) -&gt; &#39;StockSeries&#39;:
        &#34;&#34;&#34;Generate a StockSeries from a [Pandas dataframe](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html).

        Args:
            data (pandas.DataFrame): Pandas dataframe containing the x, high, low and possibly volume and open data.
            name (str): The name for the series.

        Returns:
            StockSeries: StockSeries generated from a Pandas dataframe
        &#34;&#34;&#34;
        x = list(data.iloc[:, 0])
        high = list(data[&#34;high&#34;])
        low = list(data[&#34;low&#34;])
        close = list(data[&#34;close&#34;])
        # volume and open are optional
        try:
            open_ = list(data[&#34;open&#34;])
        except KeyError:
            open_ = None
        try:
            volume = list(data[&#34;volume&#34;])
        except KeyError:
            volume = None
        return cls(x, high, low, close, open_, volume, name=name)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="apexofficeprint.elements.charts.Series" href="#apexofficeprint.elements.charts.Series">Series</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="apexofficeprint.elements.charts.StockSeries.from_dataframe"><code class="name flex">
<span>def <span class="ident">from_dataframe</span></span>(<span>data: pandas.DataFrame, name: str = None) ‑> <a title="apexofficeprint.elements.charts.StockSeries" href="#apexofficeprint.elements.charts.StockSeries">StockSeries</a></span>
</code></dt>
<dd>
<div class="desc"><p>Generate a StockSeries from a <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html">Pandas dataframe</a>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>Pandas dataframe containing the x, high, low and possibly volume and open data.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name for the series.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="apexofficeprint.elements.charts.StockSeries" href="#apexofficeprint.elements.charts.StockSeries">StockSeries</a></code></dt>
<dd>StockSeries generated from a Pandas dataframe</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_dataframe(cls, data: &#39;pandas.DataFrame&#39;, name: str = None) -&gt; &#39;StockSeries&#39;:
    &#34;&#34;&#34;Generate a StockSeries from a [Pandas dataframe](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html).

    Args:
        data (pandas.DataFrame): Pandas dataframe containing the x, high, low and possibly volume and open data.
        name (str): The name for the series.

    Returns:
        StockSeries: StockSeries generated from a Pandas dataframe
    &#34;&#34;&#34;
    x = list(data.iloc[:, 0])
    high = list(data[&#34;high&#34;])
    low = list(data[&#34;low&#34;])
    close = list(data[&#34;close&#34;])
    # volume and open are optional
    try:
        open_ = list(data[&#34;open&#34;])
    except KeyError:
        open_ = None
    try:
        volume = list(data[&#34;volume&#34;])
    except KeyError:
        volume = None
    return cls(x, high, low, close, open_, volume, name=name)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="apexofficeprint.elements.charts.Series" href="#apexofficeprint.elements.charts.Series">Series</a></b></code>:
<ul class="hlist">
<li><code><a title="apexofficeprint.elements.charts.Series.as_dict" href="#apexofficeprint.elements.charts.Series.as_dict">as_dict</a></code></li>
<li><code><a title="apexofficeprint.elements.charts.Series.data" href="#apexofficeprint.elements.charts.Series.data">data</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="apexofficeprint.elements.charts.XYSeries"><code class="flex name class">
<span>class <span class="ident">XYSeries</span></span>
<span>(</span><span>x: Iterable[Union[int, float, str]], y: Iterable[Union[int, float]], name: str = None, color: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>A series for the case where the data consists of x-values and y-values.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>Iterable[Union[int, float, str]]</code></dt>
<dd>The data for the x-axis.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>Iterable[Union[int, float]]</code></dt>
<dd>The data for the y-axis.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The name of the series. Defaults to None.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The color in which the series should be shown on a chart.
Can be html/css colors or hex values. Defaults to None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class XYSeries(Series):
    &#34;&#34;&#34;A series for the case where the data consists of x-values and y-values.&#34;&#34;&#34;
    def __init__(self,
                 x: Iterable[Union[int, float, str]],
                 y: Iterable[Union[int, float]],
                 name: str = None,
                 color: str = None):
        &#34;&#34;&#34;
        Args:
            x (Iterable[Union[int, float, str]]): The data for the x-axis.
            y (Iterable[Union[int, float]]): The data for the y-axis.
            name (str, optional): The name of the series. Defaults to None.
            color (str, optional): The color in which the series should be shown on a chart.
                Can be html/css colors or hex values. Defaults to None.
        &#34;&#34;&#34;
        super().__init__(name)
        self.x: Iterable[Union[int, float, str]] = x
        self.y: Iterable[Union[int, float]] = y
        self.color: str = color

    @property
    def data(self):
        return [{
            &#34;x&#34;: x,
            &#34;y&#34;: y
        } for x, y in zip(self.x, self.y)]

    @classmethod
    def from_dataframe(cls, data: &#39;pandas.DataFrame&#39;, name: str = None) -&gt; &#39;XYSeries&#39;:
        &#34;&#34;&#34;Generate an XYSeries from a [Pandas dataframe](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html).

        Args:
            data (pandas.DataFrame): Pandas dataframe containing the data for the x- and y-axis.
            name (str): The name for the series.

        Returns:
            XYSeries: XYSeries generated from a Pandas dataframe
        &#34;&#34;&#34;
        x = list(data.iloc[:, 0])
        y = list(data.iloc[:, 1])
        return cls(x, y, name=name)
    
    @property
    def as_dict(self) -&gt; Dict:
        result = super().as_dict

        if self.color is not None:
            result[&#39;color&#39;] = self.color
        
        return result</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="apexofficeprint.elements.charts.Series" href="#apexofficeprint.elements.charts.Series">Series</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="apexofficeprint.elements.charts.AreaSeries" href="#apexofficeprint.elements.charts.AreaSeries">AreaSeries</a></li>
<li><a title="apexofficeprint.elements.charts.BubbleSeries" href="#apexofficeprint.elements.charts.BubbleSeries">BubbleSeries</a></li>
<li><a title="apexofficeprint.elements.charts.LineSeries" href="#apexofficeprint.elements.charts.LineSeries">LineSeries</a></li>
<li><a title="apexofficeprint.elements.charts.PieSeries" href="#apexofficeprint.elements.charts.PieSeries">PieSeries</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="apexofficeprint.elements.charts.XYSeries.from_dataframe"><code class="name flex">
<span>def <span class="ident">from_dataframe</span></span>(<span>data: pandas.DataFrame, name: str = None) ‑> <a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a></span>
</code></dt>
<dd>
<div class="desc"><p>Generate an XYSeries from a <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html">Pandas dataframe</a>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>Pandas dataframe containing the data for the x- and y-axis.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name for the series.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a></code></dt>
<dd>XYSeries generated from a Pandas dataframe</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_dataframe(cls, data: &#39;pandas.DataFrame&#39;, name: str = None) -&gt; &#39;XYSeries&#39;:
    &#34;&#34;&#34;Generate an XYSeries from a [Pandas dataframe](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html).

    Args:
        data (pandas.DataFrame): Pandas dataframe containing the data for the x- and y-axis.
        name (str): The name for the series.

    Returns:
        XYSeries: XYSeries generated from a Pandas dataframe
    &#34;&#34;&#34;
    x = list(data.iloc[:, 0])
    y = list(data.iloc[:, 1])
    return cls(x, y, name=name)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="apexofficeprint.elements.charts.XYSeries.as_dict"><code class="name">var <span class="ident">as_dict</span> : Dict</code></dt>
<dd>
<div class="desc"><p>The dict representation of this Series object.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict</code></dt>
<dd>dict representation of this Series object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def as_dict(self) -&gt; Dict:
    result = super().as_dict

    if self.color is not None:
        result[&#39;color&#39;] = self.color
    
    return result</code></pre>
</details>
</dd>
<dt id="apexofficeprint.elements.charts.XYSeries.data"><code class="name">var <span class="ident">data</span></code></dt>
<dd>
<div class="desc"><p>Get the data used in the series. E.g. x-values, y-values, &hellip;</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def data(self):
    return [{
        &#34;x&#34;: x,
        &#34;y&#34;: y
    } for x, y in zip(self.x, self.y)]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="apexofficeprint.elements.charts.XYSeries"><code class="flex name class">
<span>class <span class="ident">BarSeries</span></span>
<span>(</span><span>x: Iterable[Union[int, float, str]], y: Iterable[Union[int, float]], name: str = None, color: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>A series for the case where the data consists of x-values and y-values.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>Iterable[Union[int, float, str]]</code></dt>
<dd>The data for the x-axis.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>Iterable[Union[int, float]]</code></dt>
<dd>The data for the y-axis.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The name of the series. Defaults to None.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The color in which the series should be shown on a chart.
Can be html/css colors or hex values. Defaults to None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class XYSeries(Series):
    &#34;&#34;&#34;A series for the case where the data consists of x-values and y-values.&#34;&#34;&#34;
    def __init__(self,
                 x: Iterable[Union[int, float, str]],
                 y: Iterable[Union[int, float]],
                 name: str = None,
                 color: str = None):
        &#34;&#34;&#34;
        Args:
            x (Iterable[Union[int, float, str]]): The data for the x-axis.
            y (Iterable[Union[int, float]]): The data for the y-axis.
            name (str, optional): The name of the series. Defaults to None.
            color (str, optional): The color in which the series should be shown on a chart.
                Can be html/css colors or hex values. Defaults to None.
        &#34;&#34;&#34;
        super().__init__(name)
        self.x: Iterable[Union[int, float, str]] = x
        self.y: Iterable[Union[int, float]] = y
        self.color: str = color

    @property
    def data(self):
        return [{
            &#34;x&#34;: x,
            &#34;y&#34;: y
        } for x, y in zip(self.x, self.y)]

    @classmethod
    def from_dataframe(cls, data: &#39;pandas.DataFrame&#39;, name: str = None) -&gt; &#39;XYSeries&#39;:
        &#34;&#34;&#34;Generate an XYSeries from a [Pandas dataframe](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html).

        Args:
            data (pandas.DataFrame): Pandas dataframe containing the data for the x- and y-axis.
            name (str): The name for the series.

        Returns:
            XYSeries: XYSeries generated from a Pandas dataframe
        &#34;&#34;&#34;
        x = list(data.iloc[:, 0])
        y = list(data.iloc[:, 1])
        return cls(x, y, name=name)
    
    @property
    def as_dict(self) -&gt; Dict:
        result = super().as_dict

        if self.color is not None:
            result[&#39;color&#39;] = self.color
        
        return result</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="apexofficeprint.elements.charts.Series" href="#apexofficeprint.elements.charts.Series">Series</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="apexofficeprint.elements.charts.AreaSeries" href="#apexofficeprint.elements.charts.AreaSeries">AreaSeries</a></li>
<li><a title="apexofficeprint.elements.charts.BubbleSeries" href="#apexofficeprint.elements.charts.BubbleSeries">BubbleSeries</a></li>
<li><a title="apexofficeprint.elements.charts.LineSeries" href="#apexofficeprint.elements.charts.LineSeries">LineSeries</a></li>
<li><a title="apexofficeprint.elements.charts.PieSeries" href="#apexofficeprint.elements.charts.PieSeries">PieSeries</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="apexofficeprint.elements.charts.XYSeries.from_dataframe"><code class="name flex">
<span>def <span class="ident">from_dataframe</span></span>(<span>data: pandas.DataFrame, name: str = None) ‑> <a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a></span>
</code></dt>
<dd>
<div class="desc"><p>Generate an XYSeries from a <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html">Pandas dataframe</a>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>Pandas dataframe containing the data for the x- and y-axis.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name for the series.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a></code></dt>
<dd>XYSeries generated from a Pandas dataframe</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_dataframe(cls, data: &#39;pandas.DataFrame&#39;, name: str = None) -&gt; &#39;XYSeries&#39;:
    &#34;&#34;&#34;Generate an XYSeries from a [Pandas dataframe](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html).

    Args:
        data (pandas.DataFrame): Pandas dataframe containing the data for the x- and y-axis.
        name (str): The name for the series.

    Returns:
        XYSeries: XYSeries generated from a Pandas dataframe
    &#34;&#34;&#34;
    x = list(data.iloc[:, 0])
    y = list(data.iloc[:, 1])
    return cls(x, y, name=name)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="apexofficeprint.elements.charts.XYSeries.as_dict"><code class="name">var <span class="ident">as_dict</span> : Dict</code></dt>
<dd>
<div class="desc"><p>The dict representation of this Series object.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict</code></dt>
<dd>dict representation of this Series object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def as_dict(self) -&gt; Dict:
    result = super().as_dict

    if self.color is not None:
        result[&#39;color&#39;] = self.color
    
    return result</code></pre>
</details>
</dd>
<dt id="apexofficeprint.elements.charts.XYSeries.data"><code class="name">var <span class="ident">data</span></code></dt>
<dd>
<div class="desc"><p>Get the data used in the series. E.g. x-values, y-values, &hellip;</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def data(self):
    return [{
        &#34;x&#34;: x,
        &#34;y&#34;: y
    } for x, y in zip(self.x, self.y)]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="apexofficeprint.elements.charts.XYSeries"><code class="flex name class">
<span>class <span class="ident">BarStackedSeries</span></span>
<span>(</span><span>x: Iterable[Union[int, float, str]], y: Iterable[Union[int, float]], name: str = None, color: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>A series for the case where the data consists of x-values and y-values.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>Iterable[Union[int, float, str]]</code></dt>
<dd>The data for the x-axis.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>Iterable[Union[int, float]]</code></dt>
<dd>The data for the y-axis.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The name of the series. Defaults to None.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The color in which the series should be shown on a chart.
Can be html/css colors or hex values. Defaults to None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class XYSeries(Series):
    &#34;&#34;&#34;A series for the case where the data consists of x-values and y-values.&#34;&#34;&#34;
    def __init__(self,
                 x: Iterable[Union[int, float, str]],
                 y: Iterable[Union[int, float]],
                 name: str = None,
                 color: str = None):
        &#34;&#34;&#34;
        Args:
            x (Iterable[Union[int, float, str]]): The data for the x-axis.
            y (Iterable[Union[int, float]]): The data for the y-axis.
            name (str, optional): The name of the series. Defaults to None.
            color (str, optional): The color in which the series should be shown on a chart.
                Can be html/css colors or hex values. Defaults to None.
        &#34;&#34;&#34;
        super().__init__(name)
        self.x: Iterable[Union[int, float, str]] = x
        self.y: Iterable[Union[int, float]] = y
        self.color: str = color

    @property
    def data(self):
        return [{
            &#34;x&#34;: x,
            &#34;y&#34;: y
        } for x, y in zip(self.x, self.y)]

    @classmethod
    def from_dataframe(cls, data: &#39;pandas.DataFrame&#39;, name: str = None) -&gt; &#39;XYSeries&#39;:
        &#34;&#34;&#34;Generate an XYSeries from a [Pandas dataframe](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html).

        Args:
            data (pandas.DataFrame): Pandas dataframe containing the data for the x- and y-axis.
            name (str): The name for the series.

        Returns:
            XYSeries: XYSeries generated from a Pandas dataframe
        &#34;&#34;&#34;
        x = list(data.iloc[:, 0])
        y = list(data.iloc[:, 1])
        return cls(x, y, name=name)
    
    @property
    def as_dict(self) -&gt; Dict:
        result = super().as_dict

        if self.color is not None:
            result[&#39;color&#39;] = self.color
        
        return result</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="apexofficeprint.elements.charts.Series" href="#apexofficeprint.elements.charts.Series">Series</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="apexofficeprint.elements.charts.AreaSeries" href="#apexofficeprint.elements.charts.AreaSeries">AreaSeries</a></li>
<li><a title="apexofficeprint.elements.charts.BubbleSeries" href="#apexofficeprint.elements.charts.BubbleSeries">BubbleSeries</a></li>
<li><a title="apexofficeprint.elements.charts.LineSeries" href="#apexofficeprint.elements.charts.LineSeries">LineSeries</a></li>
<li><a title="apexofficeprint.elements.charts.PieSeries" href="#apexofficeprint.elements.charts.PieSeries">PieSeries</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="apexofficeprint.elements.charts.XYSeries.from_dataframe"><code class="name flex">
<span>def <span class="ident">from_dataframe</span></span>(<span>data: pandas.DataFrame, name: str = None) ‑> <a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a></span>
</code></dt>
<dd>
<div class="desc"><p>Generate an XYSeries from a <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html">Pandas dataframe</a>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>Pandas dataframe containing the data for the x- and y-axis.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name for the series.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a></code></dt>
<dd>XYSeries generated from a Pandas dataframe</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_dataframe(cls, data: &#39;pandas.DataFrame&#39;, name: str = None) -&gt; &#39;XYSeries&#39;:
    &#34;&#34;&#34;Generate an XYSeries from a [Pandas dataframe](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html).

    Args:
        data (pandas.DataFrame): Pandas dataframe containing the data for the x- and y-axis.
        name (str): The name for the series.

    Returns:
        XYSeries: XYSeries generated from a Pandas dataframe
    &#34;&#34;&#34;
    x = list(data.iloc[:, 0])
    y = list(data.iloc[:, 1])
    return cls(x, y, name=name)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="apexofficeprint.elements.charts.XYSeries.as_dict"><code class="name">var <span class="ident">as_dict</span> : Dict</code></dt>
<dd>
<div class="desc"><p>The dict representation of this Series object.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict</code></dt>
<dd>dict representation of this Series object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def as_dict(self) -&gt; Dict:
    result = super().as_dict

    if self.color is not None:
        result[&#39;color&#39;] = self.color
    
    return result</code></pre>
</details>
</dd>
<dt id="apexofficeprint.elements.charts.XYSeries.data"><code class="name">var <span class="ident">data</span></code></dt>
<dd>
<div class="desc"><p>Get the data used in the series. E.g. x-values, y-values, &hellip;</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def data(self):
    return [{
        &#34;x&#34;: x,
        &#34;y&#34;: y
    } for x, y in zip(self.x, self.y)]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="apexofficeprint.elements.charts.XYSeries"><code class="flex name class">
<span>class <span class="ident">BarStackedPercentSeries</span></span>
<span>(</span><span>x: Iterable[Union[int, float, str]], y: Iterable[Union[int, float]], name: str = None, color: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>A series for the case where the data consists of x-values and y-values.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>Iterable[Union[int, float, str]]</code></dt>
<dd>The data for the x-axis.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>Iterable[Union[int, float]]</code></dt>
<dd>The data for the y-axis.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The name of the series. Defaults to None.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The color in which the series should be shown on a chart.
Can be html/css colors or hex values. Defaults to None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class XYSeries(Series):
    &#34;&#34;&#34;A series for the case where the data consists of x-values and y-values.&#34;&#34;&#34;
    def __init__(self,
                 x: Iterable[Union[int, float, str]],
                 y: Iterable[Union[int, float]],
                 name: str = None,
                 color: str = None):
        &#34;&#34;&#34;
        Args:
            x (Iterable[Union[int, float, str]]): The data for the x-axis.
            y (Iterable[Union[int, float]]): The data for the y-axis.
            name (str, optional): The name of the series. Defaults to None.
            color (str, optional): The color in which the series should be shown on a chart.
                Can be html/css colors or hex values. Defaults to None.
        &#34;&#34;&#34;
        super().__init__(name)
        self.x: Iterable[Union[int, float, str]] = x
        self.y: Iterable[Union[int, float]] = y
        self.color: str = color

    @property
    def data(self):
        return [{
            &#34;x&#34;: x,
            &#34;y&#34;: y
        } for x, y in zip(self.x, self.y)]

    @classmethod
    def from_dataframe(cls, data: &#39;pandas.DataFrame&#39;, name: str = None) -&gt; &#39;XYSeries&#39;:
        &#34;&#34;&#34;Generate an XYSeries from a [Pandas dataframe](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html).

        Args:
            data (pandas.DataFrame): Pandas dataframe containing the data for the x- and y-axis.
            name (str): The name for the series.

        Returns:
            XYSeries: XYSeries generated from a Pandas dataframe
        &#34;&#34;&#34;
        x = list(data.iloc[:, 0])
        y = list(data.iloc[:, 1])
        return cls(x, y, name=name)
    
    @property
    def as_dict(self) -&gt; Dict:
        result = super().as_dict

        if self.color is not None:
            result[&#39;color&#39;] = self.color
        
        return result</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="apexofficeprint.elements.charts.Series" href="#apexofficeprint.elements.charts.Series">Series</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="apexofficeprint.elements.charts.AreaSeries" href="#apexofficeprint.elements.charts.AreaSeries">AreaSeries</a></li>
<li><a title="apexofficeprint.elements.charts.BubbleSeries" href="#apexofficeprint.elements.charts.BubbleSeries">BubbleSeries</a></li>
<li><a title="apexofficeprint.elements.charts.LineSeries" href="#apexofficeprint.elements.charts.LineSeries">LineSeries</a></li>
<li><a title="apexofficeprint.elements.charts.PieSeries" href="#apexofficeprint.elements.charts.PieSeries">PieSeries</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="apexofficeprint.elements.charts.XYSeries.from_dataframe"><code class="name flex">
<span>def <span class="ident">from_dataframe</span></span>(<span>data: pandas.DataFrame, name: str = None) ‑> <a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a></span>
</code></dt>
<dd>
<div class="desc"><p>Generate an XYSeries from a <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html">Pandas dataframe</a>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>Pandas dataframe containing the data for the x- and y-axis.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name for the series.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a></code></dt>
<dd>XYSeries generated from a Pandas dataframe</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_dataframe(cls, data: &#39;pandas.DataFrame&#39;, name: str = None) -&gt; &#39;XYSeries&#39;:
    &#34;&#34;&#34;Generate an XYSeries from a [Pandas dataframe](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html).

    Args:
        data (pandas.DataFrame): Pandas dataframe containing the data for the x- and y-axis.
        name (str): The name for the series.

    Returns:
        XYSeries: XYSeries generated from a Pandas dataframe
    &#34;&#34;&#34;
    x = list(data.iloc[:, 0])
    y = list(data.iloc[:, 1])
    return cls(x, y, name=name)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="apexofficeprint.elements.charts.XYSeries.as_dict"><code class="name">var <span class="ident">as_dict</span> : Dict</code></dt>
<dd>
<div class="desc"><p>The dict representation of this Series object.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict</code></dt>
<dd>dict representation of this Series object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def as_dict(self) -&gt; Dict:
    result = super().as_dict

    if self.color is not None:
        result[&#39;color&#39;] = self.color
    
    return result</code></pre>
</details>
</dd>
<dt id="apexofficeprint.elements.charts.XYSeries.data"><code class="name">var <span class="ident">data</span></code></dt>
<dd>
<div class="desc"><p>Get the data used in the series. E.g. x-values, y-values, &hellip;</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def data(self):
    return [{
        &#34;x&#34;: x,
        &#34;y&#34;: y
    } for x, y in zip(self.x, self.y)]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="apexofficeprint.elements.charts.XYSeries"><code class="flex name class">
<span>class <span class="ident">ColumnSeries</span></span>
<span>(</span><span>x: Iterable[Union[int, float, str]], y: Iterable[Union[int, float]], name: str = None, color: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>A series for the case where the data consists of x-values and y-values.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>Iterable[Union[int, float, str]]</code></dt>
<dd>The data for the x-axis.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>Iterable[Union[int, float]]</code></dt>
<dd>The data for the y-axis.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The name of the series. Defaults to None.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The color in which the series should be shown on a chart.
Can be html/css colors or hex values. Defaults to None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class XYSeries(Series):
    &#34;&#34;&#34;A series for the case where the data consists of x-values and y-values.&#34;&#34;&#34;
    def __init__(self,
                 x: Iterable[Union[int, float, str]],
                 y: Iterable[Union[int, float]],
                 name: str = None,
                 color: str = None):
        &#34;&#34;&#34;
        Args:
            x (Iterable[Union[int, float, str]]): The data for the x-axis.
            y (Iterable[Union[int, float]]): The data for the y-axis.
            name (str, optional): The name of the series. Defaults to None.
            color (str, optional): The color in which the series should be shown on a chart.
                Can be html/css colors or hex values. Defaults to None.
        &#34;&#34;&#34;
        super().__init__(name)
        self.x: Iterable[Union[int, float, str]] = x
        self.y: Iterable[Union[int, float]] = y
        self.color: str = color

    @property
    def data(self):
        return [{
            &#34;x&#34;: x,
            &#34;y&#34;: y
        } for x, y in zip(self.x, self.y)]

    @classmethod
    def from_dataframe(cls, data: &#39;pandas.DataFrame&#39;, name: str = None) -&gt; &#39;XYSeries&#39;:
        &#34;&#34;&#34;Generate an XYSeries from a [Pandas dataframe](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html).

        Args:
            data (pandas.DataFrame): Pandas dataframe containing the data for the x- and y-axis.
            name (str): The name for the series.

        Returns:
            XYSeries: XYSeries generated from a Pandas dataframe
        &#34;&#34;&#34;
        x = list(data.iloc[:, 0])
        y = list(data.iloc[:, 1])
        return cls(x, y, name=name)
    
    @property
    def as_dict(self) -&gt; Dict:
        result = super().as_dict

        if self.color is not None:
            result[&#39;color&#39;] = self.color
        
        return result</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="apexofficeprint.elements.charts.Series" href="#apexofficeprint.elements.charts.Series">Series</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="apexofficeprint.elements.charts.AreaSeries" href="#apexofficeprint.elements.charts.AreaSeries">AreaSeries</a></li>
<li><a title="apexofficeprint.elements.charts.BubbleSeries" href="#apexofficeprint.elements.charts.BubbleSeries">BubbleSeries</a></li>
<li><a title="apexofficeprint.elements.charts.LineSeries" href="#apexofficeprint.elements.charts.LineSeries">LineSeries</a></li>
<li><a title="apexofficeprint.elements.charts.PieSeries" href="#apexofficeprint.elements.charts.PieSeries">PieSeries</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="apexofficeprint.elements.charts.XYSeries.from_dataframe"><code class="name flex">
<span>def <span class="ident">from_dataframe</span></span>(<span>data: pandas.DataFrame, name: str = None) ‑> <a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a></span>
</code></dt>
<dd>
<div class="desc"><p>Generate an XYSeries from a <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html">Pandas dataframe</a>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>Pandas dataframe containing the data for the x- and y-axis.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name for the series.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a></code></dt>
<dd>XYSeries generated from a Pandas dataframe</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_dataframe(cls, data: &#39;pandas.DataFrame&#39;, name: str = None) -&gt; &#39;XYSeries&#39;:
    &#34;&#34;&#34;Generate an XYSeries from a [Pandas dataframe](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html).

    Args:
        data (pandas.DataFrame): Pandas dataframe containing the data for the x- and y-axis.
        name (str): The name for the series.

    Returns:
        XYSeries: XYSeries generated from a Pandas dataframe
    &#34;&#34;&#34;
    x = list(data.iloc[:, 0])
    y = list(data.iloc[:, 1])
    return cls(x, y, name=name)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="apexofficeprint.elements.charts.XYSeries.as_dict"><code class="name">var <span class="ident">as_dict</span> : Dict</code></dt>
<dd>
<div class="desc"><p>The dict representation of this Series object.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict</code></dt>
<dd>dict representation of this Series object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def as_dict(self) -&gt; Dict:
    result = super().as_dict

    if self.color is not None:
        result[&#39;color&#39;] = self.color
    
    return result</code></pre>
</details>
</dd>
<dt id="apexofficeprint.elements.charts.XYSeries.data"><code class="name">var <span class="ident">data</span></code></dt>
<dd>
<div class="desc"><p>Get the data used in the series. E.g. x-values, y-values, &hellip;</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def data(self):
    return [{
        &#34;x&#34;: x,
        &#34;y&#34;: y
    } for x, y in zip(self.x, self.y)]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="apexofficeprint.elements.charts.XYSeries"><code class="flex name class">
<span>class <span class="ident">ColumnStackedSeries</span></span>
<span>(</span><span>x: Iterable[Union[int, float, str]], y: Iterable[Union[int, float]], name: str = None, color: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>A series for the case where the data consists of x-values and y-values.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>Iterable[Union[int, float, str]]</code></dt>
<dd>The data for the x-axis.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>Iterable[Union[int, float]]</code></dt>
<dd>The data for the y-axis.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The name of the series. Defaults to None.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The color in which the series should be shown on a chart.
Can be html/css colors or hex values. Defaults to None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class XYSeries(Series):
    &#34;&#34;&#34;A series for the case where the data consists of x-values and y-values.&#34;&#34;&#34;
    def __init__(self,
                 x: Iterable[Union[int, float, str]],
                 y: Iterable[Union[int, float]],
                 name: str = None,
                 color: str = None):
        &#34;&#34;&#34;
        Args:
            x (Iterable[Union[int, float, str]]): The data for the x-axis.
            y (Iterable[Union[int, float]]): The data for the y-axis.
            name (str, optional): The name of the series. Defaults to None.
            color (str, optional): The color in which the series should be shown on a chart.
                Can be html/css colors or hex values. Defaults to None.
        &#34;&#34;&#34;
        super().__init__(name)
        self.x: Iterable[Union[int, float, str]] = x
        self.y: Iterable[Union[int, float]] = y
        self.color: str = color

    @property
    def data(self):
        return [{
            &#34;x&#34;: x,
            &#34;y&#34;: y
        } for x, y in zip(self.x, self.y)]

    @classmethod
    def from_dataframe(cls, data: &#39;pandas.DataFrame&#39;, name: str = None) -&gt; &#39;XYSeries&#39;:
        &#34;&#34;&#34;Generate an XYSeries from a [Pandas dataframe](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html).

        Args:
            data (pandas.DataFrame): Pandas dataframe containing the data for the x- and y-axis.
            name (str): The name for the series.

        Returns:
            XYSeries: XYSeries generated from a Pandas dataframe
        &#34;&#34;&#34;
        x = list(data.iloc[:, 0])
        y = list(data.iloc[:, 1])
        return cls(x, y, name=name)
    
    @property
    def as_dict(self) -&gt; Dict:
        result = super().as_dict

        if self.color is not None:
            result[&#39;color&#39;] = self.color
        
        return result</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="apexofficeprint.elements.charts.Series" href="#apexofficeprint.elements.charts.Series">Series</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="apexofficeprint.elements.charts.AreaSeries" href="#apexofficeprint.elements.charts.AreaSeries">AreaSeries</a></li>
<li><a title="apexofficeprint.elements.charts.BubbleSeries" href="#apexofficeprint.elements.charts.BubbleSeries">BubbleSeries</a></li>
<li><a title="apexofficeprint.elements.charts.LineSeries" href="#apexofficeprint.elements.charts.LineSeries">LineSeries</a></li>
<li><a title="apexofficeprint.elements.charts.PieSeries" href="#apexofficeprint.elements.charts.PieSeries">PieSeries</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="apexofficeprint.elements.charts.XYSeries.from_dataframe"><code class="name flex">
<span>def <span class="ident">from_dataframe</span></span>(<span>data: pandas.DataFrame, name: str = None) ‑> <a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a></span>
</code></dt>
<dd>
<div class="desc"><p>Generate an XYSeries from a <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html">Pandas dataframe</a>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>Pandas dataframe containing the data for the x- and y-axis.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name for the series.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a></code></dt>
<dd>XYSeries generated from a Pandas dataframe</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_dataframe(cls, data: &#39;pandas.DataFrame&#39;, name: str = None) -&gt; &#39;XYSeries&#39;:
    &#34;&#34;&#34;Generate an XYSeries from a [Pandas dataframe](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html).

    Args:
        data (pandas.DataFrame): Pandas dataframe containing the data for the x- and y-axis.
        name (str): The name for the series.

    Returns:
        XYSeries: XYSeries generated from a Pandas dataframe
    &#34;&#34;&#34;
    x = list(data.iloc[:, 0])
    y = list(data.iloc[:, 1])
    return cls(x, y, name=name)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="apexofficeprint.elements.charts.XYSeries.as_dict"><code class="name">var <span class="ident">as_dict</span> : Dict</code></dt>
<dd>
<div class="desc"><p>The dict representation of this Series object.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict</code></dt>
<dd>dict representation of this Series object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def as_dict(self) -&gt; Dict:
    result = super().as_dict

    if self.color is not None:
        result[&#39;color&#39;] = self.color
    
    return result</code></pre>
</details>
</dd>
<dt id="apexofficeprint.elements.charts.XYSeries.data"><code class="name">var <span class="ident">data</span></code></dt>
<dd>
<div class="desc"><p>Get the data used in the series. E.g. x-values, y-values, &hellip;</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def data(self):
    return [{
        &#34;x&#34;: x,
        &#34;y&#34;: y
    } for x, y in zip(self.x, self.y)]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="apexofficeprint.elements.charts.XYSeries"><code class="flex name class">
<span>class <span class="ident">ColumnStackedPercentSeries</span></span>
<span>(</span><span>x: Iterable[Union[int, float, str]], y: Iterable[Union[int, float]], name: str = None, color: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>A series for the case where the data consists of x-values and y-values.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>Iterable[Union[int, float, str]]</code></dt>
<dd>The data for the x-axis.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>Iterable[Union[int, float]]</code></dt>
<dd>The data for the y-axis.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The name of the series. Defaults to None.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The color in which the series should be shown on a chart.
Can be html/css colors or hex values. Defaults to None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class XYSeries(Series):
    &#34;&#34;&#34;A series for the case where the data consists of x-values and y-values.&#34;&#34;&#34;
    def __init__(self,
                 x: Iterable[Union[int, float, str]],
                 y: Iterable[Union[int, float]],
                 name: str = None,
                 color: str = None):
        &#34;&#34;&#34;
        Args:
            x (Iterable[Union[int, float, str]]): The data for the x-axis.
            y (Iterable[Union[int, float]]): The data for the y-axis.
            name (str, optional): The name of the series. Defaults to None.
            color (str, optional): The color in which the series should be shown on a chart.
                Can be html/css colors or hex values. Defaults to None.
        &#34;&#34;&#34;
        super().__init__(name)
        self.x: Iterable[Union[int, float, str]] = x
        self.y: Iterable[Union[int, float]] = y
        self.color: str = color

    @property
    def data(self):
        return [{
            &#34;x&#34;: x,
            &#34;y&#34;: y
        } for x, y in zip(self.x, self.y)]

    @classmethod
    def from_dataframe(cls, data: &#39;pandas.DataFrame&#39;, name: str = None) -&gt; &#39;XYSeries&#39;:
        &#34;&#34;&#34;Generate an XYSeries from a [Pandas dataframe](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html).

        Args:
            data (pandas.DataFrame): Pandas dataframe containing the data for the x- and y-axis.
            name (str): The name for the series.

        Returns:
            XYSeries: XYSeries generated from a Pandas dataframe
        &#34;&#34;&#34;
        x = list(data.iloc[:, 0])
        y = list(data.iloc[:, 1])
        return cls(x, y, name=name)
    
    @property
    def as_dict(self) -&gt; Dict:
        result = super().as_dict

        if self.color is not None:
            result[&#39;color&#39;] = self.color
        
        return result</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="apexofficeprint.elements.charts.Series" href="#apexofficeprint.elements.charts.Series">Series</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="apexofficeprint.elements.charts.AreaSeries" href="#apexofficeprint.elements.charts.AreaSeries">AreaSeries</a></li>
<li><a title="apexofficeprint.elements.charts.BubbleSeries" href="#apexofficeprint.elements.charts.BubbleSeries">BubbleSeries</a></li>
<li><a title="apexofficeprint.elements.charts.LineSeries" href="#apexofficeprint.elements.charts.LineSeries">LineSeries</a></li>
<li><a title="apexofficeprint.elements.charts.PieSeries" href="#apexofficeprint.elements.charts.PieSeries">PieSeries</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="apexofficeprint.elements.charts.XYSeries.from_dataframe"><code class="name flex">
<span>def <span class="ident">from_dataframe</span></span>(<span>data: pandas.DataFrame, name: str = None) ‑> <a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a></span>
</code></dt>
<dd>
<div class="desc"><p>Generate an XYSeries from a <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html">Pandas dataframe</a>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>Pandas dataframe containing the data for the x- and y-axis.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name for the series.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a></code></dt>
<dd>XYSeries generated from a Pandas dataframe</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_dataframe(cls, data: &#39;pandas.DataFrame&#39;, name: str = None) -&gt; &#39;XYSeries&#39;:
    &#34;&#34;&#34;Generate an XYSeries from a [Pandas dataframe](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html).

    Args:
        data (pandas.DataFrame): Pandas dataframe containing the data for the x- and y-axis.
        name (str): The name for the series.

    Returns:
        XYSeries: XYSeries generated from a Pandas dataframe
    &#34;&#34;&#34;
    x = list(data.iloc[:, 0])
    y = list(data.iloc[:, 1])
    return cls(x, y, name=name)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="apexofficeprint.elements.charts.XYSeries.as_dict"><code class="name">var <span class="ident">as_dict</span> : Dict</code></dt>
<dd>
<div class="desc"><p>The dict representation of this Series object.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict</code></dt>
<dd>dict representation of this Series object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def as_dict(self) -&gt; Dict:
    result = super().as_dict

    if self.color is not None:
        result[&#39;color&#39;] = self.color
    
    return result</code></pre>
</details>
</dd>
<dt id="apexofficeprint.elements.charts.XYSeries.data"><code class="name">var <span class="ident">data</span></code></dt>
<dd>
<div class="desc"><p>Get the data used in the series. E.g. x-values, y-values, &hellip;</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def data(self):
    return [{
        &#34;x&#34;: x,
        &#34;y&#34;: y
    } for x, y in zip(self.x, self.y)]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="apexofficeprint.elements.charts.XYSeries"><code class="flex name class">
<span>class <span class="ident">ScatterSeries</span></span>
<span>(</span><span>x: Iterable[Union[int, float, str]], y: Iterable[Union[int, float]], name: str = None, color: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>A series for the case where the data consists of x-values and y-values.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>Iterable[Union[int, float, str]]</code></dt>
<dd>The data for the x-axis.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>Iterable[Union[int, float]]</code></dt>
<dd>The data for the y-axis.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The name of the series. Defaults to None.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The color in which the series should be shown on a chart.
Can be html/css colors or hex values. Defaults to None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class XYSeries(Series):
    &#34;&#34;&#34;A series for the case where the data consists of x-values and y-values.&#34;&#34;&#34;
    def __init__(self,
                 x: Iterable[Union[int, float, str]],
                 y: Iterable[Union[int, float]],
                 name: str = None,
                 color: str = None):
        &#34;&#34;&#34;
        Args:
            x (Iterable[Union[int, float, str]]): The data for the x-axis.
            y (Iterable[Union[int, float]]): The data for the y-axis.
            name (str, optional): The name of the series. Defaults to None.
            color (str, optional): The color in which the series should be shown on a chart.
                Can be html/css colors or hex values. Defaults to None.
        &#34;&#34;&#34;
        super().__init__(name)
        self.x: Iterable[Union[int, float, str]] = x
        self.y: Iterable[Union[int, float]] = y
        self.color: str = color

    @property
    def data(self):
        return [{
            &#34;x&#34;: x,
            &#34;y&#34;: y
        } for x, y in zip(self.x, self.y)]

    @classmethod
    def from_dataframe(cls, data: &#39;pandas.DataFrame&#39;, name: str = None) -&gt; &#39;XYSeries&#39;:
        &#34;&#34;&#34;Generate an XYSeries from a [Pandas dataframe](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html).

        Args:
            data (pandas.DataFrame): Pandas dataframe containing the data for the x- and y-axis.
            name (str): The name for the series.

        Returns:
            XYSeries: XYSeries generated from a Pandas dataframe
        &#34;&#34;&#34;
        x = list(data.iloc[:, 0])
        y = list(data.iloc[:, 1])
        return cls(x, y, name=name)
    
    @property
    def as_dict(self) -&gt; Dict:
        result = super().as_dict

        if self.color is not None:
            result[&#39;color&#39;] = self.color
        
        return result</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="apexofficeprint.elements.charts.Series" href="#apexofficeprint.elements.charts.Series">Series</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="apexofficeprint.elements.charts.AreaSeries" href="#apexofficeprint.elements.charts.AreaSeries">AreaSeries</a></li>
<li><a title="apexofficeprint.elements.charts.BubbleSeries" href="#apexofficeprint.elements.charts.BubbleSeries">BubbleSeries</a></li>
<li><a title="apexofficeprint.elements.charts.LineSeries" href="#apexofficeprint.elements.charts.LineSeries">LineSeries</a></li>
<li><a title="apexofficeprint.elements.charts.PieSeries" href="#apexofficeprint.elements.charts.PieSeries">PieSeries</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="apexofficeprint.elements.charts.XYSeries.from_dataframe"><code class="name flex">
<span>def <span class="ident">from_dataframe</span></span>(<span>data: pandas.DataFrame, name: str = None) ‑> <a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a></span>
</code></dt>
<dd>
<div class="desc"><p>Generate an XYSeries from a <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html">Pandas dataframe</a>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>Pandas dataframe containing the data for the x- and y-axis.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name for the series.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a></code></dt>
<dd>XYSeries generated from a Pandas dataframe</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_dataframe(cls, data: &#39;pandas.DataFrame&#39;, name: str = None) -&gt; &#39;XYSeries&#39;:
    &#34;&#34;&#34;Generate an XYSeries from a [Pandas dataframe](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html).

    Args:
        data (pandas.DataFrame): Pandas dataframe containing the data for the x- and y-axis.
        name (str): The name for the series.

    Returns:
        XYSeries: XYSeries generated from a Pandas dataframe
    &#34;&#34;&#34;
    x = list(data.iloc[:, 0])
    y = list(data.iloc[:, 1])
    return cls(x, y, name=name)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="apexofficeprint.elements.charts.Series" href="#apexofficeprint.elements.charts.Series">Series</a></b></code>:
<ul class="hlist">
<li><code><a title="apexofficeprint.elements.charts.Series.as_dict" href="#apexofficeprint.elements.charts.Series.as_dict">as_dict</a></code></li>
<li><code><a title="apexofficeprint.elements.charts.Series.data" href="#apexofficeprint.elements.charts.Series.data">data</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="apexofficeprint.elements" href="index.html">apexofficeprint.elements</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="apexofficeprint.elements.charts.AreaChart" href="#apexofficeprint.elements.charts.AreaChart">AreaChart</a></code></h4>
</li>
<li>
<h4><code><a title="apexofficeprint.elements.charts.AreaSeries" href="#apexofficeprint.elements.charts.AreaSeries">AreaSeries</a></code></h4>
</li>
<li>
<h4><code><a title="apexofficeprint.elements.charts.BarChart" href="#apexofficeprint.elements.charts.BarChart">BarChart</a></code></h4>
</li>
<li>
<h4><code><a title="apexofficeprint.elements.charts.BarStackedChart" href="#apexofficeprint.elements.charts.BarStackedChart">BarStackedChart</a></code></h4>
</li>
<li>
<h4><code><a title="apexofficeprint.elements.charts.BarStackedPercentChart" href="#apexofficeprint.elements.charts.BarStackedPercentChart">BarStackedPercentChart</a></code></h4>
</li>
<li>
<h4><code><a title="apexofficeprint.elements.charts.BubbleChart" href="#apexofficeprint.elements.charts.BubbleChart">BubbleChart</a></code></h4>
</li>
<li>
<h4><code><a title="apexofficeprint.elements.charts.BubbleSeries" href="#apexofficeprint.elements.charts.BubbleSeries">BubbleSeries</a></code></h4>
<ul class="">
<li><code><a title="apexofficeprint.elements.charts.BubbleSeries.from_dataframe" href="#apexofficeprint.elements.charts.BubbleSeries.from_dataframe">from_dataframe</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="apexofficeprint.elements.charts.Chart" href="#apexofficeprint.elements.charts.Chart">Chart</a></code></h4>
</li>
<li>
<h4><code><a title="apexofficeprint.elements.charts.ChartAxisOptions" href="#apexofficeprint.elements.charts.ChartAxisOptions">ChartAxisOptions</a></code></h4>
<ul class="">
<li><code><a title="apexofficeprint.elements.charts.ChartAxisOptions.as_dict" href="#apexofficeprint.elements.charts.ChartAxisOptions.as_dict">as_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="apexofficeprint.elements.charts.ChartDateOptions" href="#apexofficeprint.elements.charts.ChartDateOptions">ChartDateOptions</a></code></h4>
<ul class="">
<li><code><a title="apexofficeprint.elements.charts.ChartDateOptions.as_dict" href="#apexofficeprint.elements.charts.ChartDateOptions.as_dict">as_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="apexofficeprint.elements.charts.ChartOptions" href="#apexofficeprint.elements.charts.ChartOptions">ChartOptions</a></code></h4>
<ul class="">
<li><code><a title="apexofficeprint.elements.charts.ChartOptions.as_dict" href="#apexofficeprint.elements.charts.ChartOptions.as_dict">as_dict</a></code></li>
<li><code><a title="apexofficeprint.elements.charts.ChartOptions.remove_data_labels" href="#apexofficeprint.elements.charts.ChartOptions.remove_data_labels">remove_data_labels</a></code></li>
<li><code><a title="apexofficeprint.elements.charts.ChartOptions.remove_legend" href="#apexofficeprint.elements.charts.ChartOptions.remove_legend">remove_legend</a></code></li>
<li><code><a title="apexofficeprint.elements.charts.ChartOptions.set_data_labels" href="#apexofficeprint.elements.charts.ChartOptions.set_data_labels">set_data_labels</a></code></li>
<li><code><a title="apexofficeprint.elements.charts.ChartOptions.set_legend" href="#apexofficeprint.elements.charts.ChartOptions.set_legend">set_legend</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="apexofficeprint.elements.charts.ChartTextStyle" href="#apexofficeprint.elements.charts.ChartTextStyle">ChartTextStyle</a></code></h4>
<ul class="">
<li><code><a title="apexofficeprint.elements.charts.ChartTextStyle.as_dict" href="#apexofficeprint.elements.charts.ChartTextStyle.as_dict">as_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="apexofficeprint.elements.charts.ColumnChart" href="#apexofficeprint.elements.charts.ColumnChart">ColumnChart</a></code></h4>
</li>
<li>
<h4><code><a title="apexofficeprint.elements.charts.ColumnStackedChart" href="#apexofficeprint.elements.charts.ColumnStackedChart">ColumnStackedChart</a></code></h4>
</li>
<li>
<h4><code><a title="apexofficeprint.elements.charts.ColumnStackedPercentChart" href="#apexofficeprint.elements.charts.ColumnStackedPercentChart">ColumnStackedPercentChart</a></code></h4>
</li>
<li>
<h4><code><a title="apexofficeprint.elements.charts.CombinedChart" href="#apexofficeprint.elements.charts.CombinedChart">CombinedChart</a></code></h4>
</li>
<li>
<h4><code><a title="apexofficeprint.elements.charts.DoughnutChart" href="#apexofficeprint.elements.charts.DoughnutChart">DoughnutChart</a></code></h4>
</li>
<li>
<h4><code><a title="apexofficeprint.elements.charts.LineChart" href="#apexofficeprint.elements.charts.LineChart">LineChart</a></code></h4>
</li>
<li>
<h4><code><a title="apexofficeprint.elements.charts.LineSeries" href="#apexofficeprint.elements.charts.LineSeries">LineSeries</a></code></h4>
<ul class="">
<li><code><a title="apexofficeprint.elements.charts.LineSeries.as_dict" href="#apexofficeprint.elements.charts.LineSeries.as_dict">as_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="apexofficeprint.elements.charts.LineSeries" href="#apexofficeprint.elements.charts.LineSeries">LineSeries</a></code></h4>
</li>
<li>
<h4><code><a title="apexofficeprint.elements.charts.Pie3DChart" href="#apexofficeprint.elements.charts.Pie3DChart">Pie3DChart</a></code></h4>
</li>
<li>
<h4><code><a title="apexofficeprint.elements.charts.PieChart" href="#apexofficeprint.elements.charts.PieChart">PieChart</a></code></h4>
</li>
<li>
<h4><code><a title="apexofficeprint.elements.charts.PieSeries" href="#apexofficeprint.elements.charts.PieSeries">PieSeries</a></code></h4>
</li>
<li>
<h4><code><a title="apexofficeprint.elements.charts.RadarChart" href="#apexofficeprint.elements.charts.RadarChart">RadarChart</a></code></h4>
</li>
<li>
<h4><code><a title="apexofficeprint.elements.charts.ScatterChart" href="#apexofficeprint.elements.charts.ScatterChart">ScatterChart</a></code></h4>
</li>
<li>
<h4><code><a title="apexofficeprint.elements.charts.Series" href="#apexofficeprint.elements.charts.Series">Series</a></code></h4>
<ul class="">
<li><code><a title="apexofficeprint.elements.charts.Series.as_dict" href="#apexofficeprint.elements.charts.Series.as_dict">as_dict</a></code></li>
<li><code><a title="apexofficeprint.elements.charts.Series.data" href="#apexofficeprint.elements.charts.Series.data">data</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="apexofficeprint.elements.charts.StockChart" href="#apexofficeprint.elements.charts.StockChart">StockChart</a></code></h4>
</li>
<li>
<h4><code><a title="apexofficeprint.elements.charts.StockSeries" href="#apexofficeprint.elements.charts.StockSeries">StockSeries</a></code></h4>
<ul class="">
<li><code><a title="apexofficeprint.elements.charts.StockSeries.from_dataframe" href="#apexofficeprint.elements.charts.StockSeries.from_dataframe">from_dataframe</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a></code></h4>
<ul class="">
<li><code><a title="apexofficeprint.elements.charts.XYSeries.as_dict" href="#apexofficeprint.elements.charts.XYSeries.as_dict">as_dict</a></code></li>
<li><code><a title="apexofficeprint.elements.charts.XYSeries.data" href="#apexofficeprint.elements.charts.XYSeries.data">data</a></code></li>
<li><code><a title="apexofficeprint.elements.charts.XYSeries.from_dataframe" href="#apexofficeprint.elements.charts.XYSeries.from_dataframe">from_dataframe</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a></code></h4>
<ul class="">
<li><code><a title="apexofficeprint.elements.charts.XYSeries.as_dict" href="#apexofficeprint.elements.charts.XYSeries.as_dict">as_dict</a></code></li>
<li><code><a title="apexofficeprint.elements.charts.XYSeries.data" href="#apexofficeprint.elements.charts.XYSeries.data">data</a></code></li>
<li><code><a title="apexofficeprint.elements.charts.XYSeries.from_dataframe" href="#apexofficeprint.elements.charts.XYSeries.from_dataframe">from_dataframe</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a></code></h4>
<ul class="">
<li><code><a title="apexofficeprint.elements.charts.XYSeries.as_dict" href="#apexofficeprint.elements.charts.XYSeries.as_dict">as_dict</a></code></li>
<li><code><a title="apexofficeprint.elements.charts.XYSeries.data" href="#apexofficeprint.elements.charts.XYSeries.data">data</a></code></li>
<li><code><a title="apexofficeprint.elements.charts.XYSeries.from_dataframe" href="#apexofficeprint.elements.charts.XYSeries.from_dataframe">from_dataframe</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a></code></h4>
<ul class="">
<li><code><a title="apexofficeprint.elements.charts.XYSeries.as_dict" href="#apexofficeprint.elements.charts.XYSeries.as_dict">as_dict</a></code></li>
<li><code><a title="apexofficeprint.elements.charts.XYSeries.data" href="#apexofficeprint.elements.charts.XYSeries.data">data</a></code></li>
<li><code><a title="apexofficeprint.elements.charts.XYSeries.from_dataframe" href="#apexofficeprint.elements.charts.XYSeries.from_dataframe">from_dataframe</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a></code></h4>
<ul class="">
<li><code><a title="apexofficeprint.elements.charts.XYSeries.as_dict" href="#apexofficeprint.elements.charts.XYSeries.as_dict">as_dict</a></code></li>
<li><code><a title="apexofficeprint.elements.charts.XYSeries.data" href="#apexofficeprint.elements.charts.XYSeries.data">data</a></code></li>
<li><code><a title="apexofficeprint.elements.charts.XYSeries.from_dataframe" href="#apexofficeprint.elements.charts.XYSeries.from_dataframe">from_dataframe</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a></code></h4>
<ul class="">
<li><code><a title="apexofficeprint.elements.charts.XYSeries.as_dict" href="#apexofficeprint.elements.charts.XYSeries.as_dict">as_dict</a></code></li>
<li><code><a title="apexofficeprint.elements.charts.XYSeries.data" href="#apexofficeprint.elements.charts.XYSeries.data">data</a></code></li>
<li><code><a title="apexofficeprint.elements.charts.XYSeries.from_dataframe" href="#apexofficeprint.elements.charts.XYSeries.from_dataframe">from_dataframe</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a></code></h4>
<ul class="">
<li><code><a title="apexofficeprint.elements.charts.XYSeries.as_dict" href="#apexofficeprint.elements.charts.XYSeries.as_dict">as_dict</a></code></li>
<li><code><a title="apexofficeprint.elements.charts.XYSeries.data" href="#apexofficeprint.elements.charts.XYSeries.data">data</a></code></li>
<li><code><a title="apexofficeprint.elements.charts.XYSeries.from_dataframe" href="#apexofficeprint.elements.charts.XYSeries.from_dataframe">from_dataframe</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="apexofficeprint.elements.charts.XYSeries" href="#apexofficeprint.elements.charts.XYSeries">XYSeries</a></code></h4>
<ul class="">
<li><code><a title="apexofficeprint.elements.charts.XYSeries.from_dataframe" href="#apexofficeprint.elements.charts.XYSeries.from_dataframe">from_dataframe</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>