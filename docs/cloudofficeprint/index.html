<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.5">
<title>cloudofficeprint API documentation</title>
<meta name="description" content="This Python package provides a programmatic interface with a [Cloud Office Print](https://www.cloudofficeprint.com) server …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>cloudofficeprint</code></h1>
</header>
<section id="section-intro">
<p>This Python package provides a programmatic interface with a <a href="https://www.cloudofficeprint.com">Cloud Office Print</a> server.</p>
<h2 id="usage">Usage</h2>
<p>The examples below call this package cop.</p>
<pre><code class="language-python">import cloudofficeprint as cop
</code></pre>
<h3 id="templates">Templates</h3>
<p>Templates are represented by <code><a title="cloudofficeprint.Resource" href="#cloudofficeprint.Resource">Resource</a></code>. The simplest way to obtain a <code><a title="cloudofficeprint.Resource" href="#cloudofficeprint.Resource">Resource</a></code> is to load from a local path.</p>
<pre><code class="language-python">template = cop.Resource.from_local_file(&quot;./path/to/template.docx&quot;)
</code></pre>
<h3 id="render-elements">Render elements</h3>
<p>Most render elements encapsulate the data for a single tag. An <code>elements.ElementCollection</code> is an element which represents a collection of elements.</p>
<p>Combining a simple line chart and some text tags:</p>
<pre><code class="language-python">line = cop.elements.LineChart(
    &quot;linechart&quot;,
    cop.elements.LineSeries([1, 2, 3, 4], [1, 2, 3, 4], color=&quot;green&quot;),
    cop.elements.XYSeries([1, 2, 3, 4], [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;])
)

text_tag = cop.elements.Property(&quot;tag-name&quot;, &quot;Hello, world!&quot;)
# or multiple at once using ElementCollection.from_mapping
# and supplying the dictionary representation directly
text_tags = cop.elements.ElementCollection.from_mapping({
    &quot;another-tag&quot;: &quot;Foo&quot;,
    &quot;one-more-tag&quot;: &quot;Bar&quot;
})

combined_data = cop.elements.ElementCollection()
combined_data.add(line)
combined_data.add(text_tag)
combined_data.add_all(text_tags)
</code></pre>
<h3 id="the-server">The server</h3>
<p>A Cloud Office Print server is configured as a <code>config.Server</code>. It takes a url and an optional <code>config.ServerConfig</code> which allows for various server configuration options. If you're using Cloud Office Print Cloud edition, you will need to use this to declare your API key.</p>
<pre><code class="language-python">server = cop.config.Server(
    &quot;http://server.url.com/&quot;,
    cop.config.ServerConfig(api_key = &quot;YOUR_API_KEY&quot;)
)
</code></pre>
<h3 id="print-job">Print job</h3>
<p><code><a title="cloudofficeprint.PrintJob" href="#cloudofficeprint.PrintJob">PrintJob</a></code> combines template, data, server and an optional output configuration (<code>config.OutputConfig</code>) and can execute itself on the Cloud Office Print server. An example using the variables declared above:</p>
<pre><code class="language-python">printjob = cop.PrintJob(combined_data, server, template)
printjob.execute()
</code></pre>
<p>A print job can be executed asynchronously as well.</p>
<pre><code class="language-python">import asyncio
coroutine = printjob.execute_async()
# simply await your result when you need it
result = await coroutine
</code></pre>
<h3 id="full-json-available">Full JSON available</h3>
<p>If you already have the JSON to be sent to the server (not just the data, but the entire JSON body including your API key and template), this package will wrap the request to the server for you (requests are made using <a href="https://requests.readthedocs.io/en/master/">requests</a>).</p>
<pre><code class="language-python">json_data = open(&quot;./path/to/data.json&quot;, &quot;r&quot;).read()
cop.PrintJob.execute_full_json(
        json_data, server
    ).to_file(&quot;./test/from_full_json_output&quot;)
</code></pre>
<h3 id="server-errors">Server errors</h3>
<p>In case the Cloud Office Print server returns an error, <code><a title="cloudofficeprint.PrintJob" href="#cloudofficeprint.PrintJob">PrintJob</a></code> will throw one as well.
You can catch it and get either its user-readable message or an encoded stack trace that can be passed to Cloud Office Print support.</p>
<pre><code class="language-python">try:
    # execute some previously constructed printjob
    printjob.execute()
except cop.exceptions.COPError as err:
    print(&quot;Cloud Office Print error! &quot; + err.user_message)
    print(err.encoded_message)
    ...
</code></pre>
<h3 id="further-information">Further information</h3>
<p>For further information, such as where to find our examples, we refer to our README.md file on our <a href="https://github.com/United-Codes/cloudofficeprint-python/">Github page</a>.</p>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="cloudofficeprint.config" href="config/index.html">cloudofficeprint.config</a></code></dt>
<dd>
<div class="desc"><p>Module for output configurations …</p></div>
</dd>
<dt><code class="name"><a title="cloudofficeprint.elements" href="elements/index.html">cloudofficeprint.elements</a></code></dt>
<dd>
<div class="desc"><p>Elements are used to replace the various tags in a template with actual data.</p></div>
</dd>
<dt><code class="name"><a title="cloudofficeprint.exceptions" href="exceptions.html">cloudofficeprint.exceptions</a></code></dt>
<dd>
<div class="desc"><p>Custom exceptions for cloudofficeprint.</p></div>
</dd>
<dt><code class="name"><a title="cloudofficeprint.own_utils" href="own_utils/index.html">cloudofficeprint.own_utils</a></code></dt>
<dd>
<div class="desc"><p>Helper functions.</p></div>
</dd>
<dt><code class="name"><a title="cloudofficeprint.printjob" href="printjob.html">cloudofficeprint.printjob</a></code></dt>
<dd>
<div class="desc"><p>Module containing the PrintJob class, which is also exposed at package level.</p></div>
</dd>
<dt><code class="name"><a title="cloudofficeprint.resource" href="resource.html">cloudofficeprint.resource</a></code></dt>
<dd>
<div class="desc"><p>Module containing the Resource class and its subclasses, which is also exposed at package level …</p></div>
</dd>
<dt><code class="name"><a title="cloudofficeprint.response" href="response.html">cloudofficeprint.response</a></code></dt>
<dd>
<div class="desc"><p>Module containing the Response class, which is also exposed at package level.</p></div>
</dd>
<dt><code class="name"><a title="cloudofficeprint.template" href="template.html">cloudofficeprint.template</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="cloudofficeprint.PrintJob"><code class="flex name class">
<span>class <span class="ident">PrintJob</span></span>
<span>(</span><span>data: <a title="cloudofficeprint.elements.elements.Element" href="elements/elements.html#cloudofficeprint.elements.elements.Element">Element</a> | Mapping[str, <a title="cloudofficeprint.elements.elements.Element" href="elements/elements.html#cloudofficeprint.elements.elements.Element">Element</a>] | <a title="cloudofficeprint.elements.rest_source.RESTSource" href="elements/rest_source.html#cloudofficeprint.elements.rest_source.RESTSource">RESTSource</a>,<br>server: <a title="cloudofficeprint.config.server.Server" href="config/server.html#cloudofficeprint.config.server.Server">Server</a>,<br>template: <a title="cloudofficeprint.template.Template" href="template.html#cloudofficeprint.template.Template">Template</a> | <a title="cloudofficeprint.resource.Resource" href="resource.html#cloudofficeprint.resource.Resource">Resource</a> = None,<br>output_config: <a title="cloudofficeprint.config.output.OutputConfig" href="config/output.html#cloudofficeprint.config.output.OutputConfig">OutputConfig</a> = &lt;cloudofficeprint.config.output.OutputConfig object&gt;,<br>subtemplates: Dict[str, <a title="cloudofficeprint.resource.Resource" href="resource.html#cloudofficeprint.resource.Resource">Resource</a>] = {},<br>prepend_files: List[<a title="cloudofficeprint.resource.Resource" href="resource.html#cloudofficeprint.resource.Resource">Resource</a>] = [],<br>append_files: List[<a title="cloudofficeprint.resource.Resource" href="resource.html#cloudofficeprint.resource.Resource">Resource</a>] = [],<br>cop_verbose: bool = False,<br>attachments: List[<a title="cloudofficeprint.resource.Resource" href="resource.html#cloudofficeprint.resource.Resource">Resource</a>] = [])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PrintJob:
    &#34;&#34;&#34;A print job for a Cloud Office Print server.

    This class contains all configuration options, resources, render elements ...
    and the `PrintJob.execute` method to combine all these and send a request to the Cloud Office Print server.
    &#34;&#34;&#34;

    def __init__(
        self,
        data: Union[Element, Mapping[str, Element], RESTSource],
        server: Server,
        template: Union[Template, Resource] = None,
        output_config: OutputConfig = OutputConfig(),
        subtemplates: Dict[str, Resource] = {},
        prepend_files: List[Resource] = [],
        append_files: List[Resource] = [],
        cop_verbose: bool = False,
        attachments : List[Resource] = [],
    ):
        &#34;&#34;&#34;
        Args:
            data (Union[Element, Mapping[str, Element], RESTSource]): This is either: An `Element` (e.g. an `ElementCollection`); A mapping, containing file names as keys and an `Element` as data. Multiple files will be produced from the different datas, the result is a zip file containing them. In the first case, no output file name is specified and the server will name it &#34;file0&#34;.
            server (Server): Server to be used for this print job.
            template (Union[Template, Resource]): Template to use for this print job.
            output_config (OutputConfig, optional): Output configuration to be used for this print job. Defaults to `OutputConfig`().
            subtemplates (Dict[str, Resource], optional): Subtemplates for this print job, accessible (in docx) through `{?include subtemplate_dict_key}`. Defaults to {}.
            prepend_files (List[Resource], optional): Files to prepend to the output file. Defaults to [].
            append_files (List[Resource], optional): Files to append to the output file. Defaults to [].
            cop_verbose (bool, optional): Whether or not verbose mode should be activated. Defaults to False.
            attachments (List[Resource], optional): Files to attach to the pdf file. Defaults to []. The file must be PDF.
        &#34;&#34;&#34;
        self.data: Union[Element, Mapping[str, Element], RESTSource] = data
        self.server: Server = server
        self.output_config: OutputConfig = output_config
        self.template: Union[Template, Resource] = template
        self.subtemplates: Dict[str, Resource] = subtemplates
        self.prepend_files: List[Resource] = prepend_files
        self.append_files: List[Resource] = append_files
        self.cop_verbose: bool = cop_verbose
        self.attachments: List[Resource] = attachments

    def execute(self) -&gt; Response:
        &#34;&#34;&#34;Execute this print job.

        Returns:
            Response: `Response`-object
        &#34;&#34;&#34;
        self.server._raise_if_unreachable()
        proxy = self.server.config.proxies if self.server.config else None
        response = requests.post(
            self.server.url,
            json=self.as_dict,
            proxies=proxy,
            headers={&#34;Content-type&#34;: &#34;application/json&#34;},
        )
        if type(self.template) is Template and self.template.should_hash:
            template_hash = response.headers[&#34;Template-Hash&#34;]
            if template_hash:
                self.template.update_hash(template_hash)
        return self._handle_response(response)

    async def execute_async(self) -&gt; Response:
        &#34;&#34;&#34;Async version of `PrintJob.execute`

        Returns:
            Response: `Response`-object
        &#34;&#34;&#34;
        self.server._raise_if_unreachable()
        proxy = self.server.config.proxies if self.server.config else None
        response = await asyncio.get_event_loop().run_in_executor(
            None,
            partial(
                requests.post,
                self.server.url,
                json=self.as_dict,
                proxies=proxy,
                headers={&#34;Content-type&#34;: &#34;application/json&#34;},
            ),
        )
        if type(self.template) is Template and self.template.should_hash:
            template_hash = response.headers[&#34;Template-Hash&#34;]
            if template_hash:
                self.template.update_hash(template_hash)
        return PrintJob._handle_response(response)

    @staticmethod
    def execute_full_json(json_data: str, server: Server) -&gt; Response:
        &#34;&#34;&#34;If you already have the JSON to be sent to the server (not just the data, but the entire JSON body including your API key and template), this package will wrap the request to the server.

        Args:
            json_data (str): full JSON data that needs to be sent to a Cloud Office Print server
            server (Server): `Server`-object

        Returns:
            Response: `Response`-object
        &#34;&#34;&#34;
        server._raise_if_unreachable()
        proxy = server.config.proxies if server.config else None
        response = requests.post(
            server.url,
            data=json_data,
            proxies=proxy,
            headers={&#34;Content-type&#34;: &#34;application/json&#34;},
        )
        return PrintJob._handle_response(response)

    @staticmethod
    async def execute_full_json_async(json_data: str, server: Server) -&gt; Response:
        &#34;&#34;&#34;Async version of `Printjob.execute_full_json`

        Args:
            json_data (str): full JSON data that needs to be sent to a Cloud Office Print server
            server (Server): `Server`-object

        Returns:
            Response: `Response`-object
        &#34;&#34;&#34;
        server._raise_if_unreachable()
        proxy = server.config.proxies if server.config else None
        response = await asyncio.get_event_loop().run_in_executor(
            None,
            partial(
                requests.post,
                server.url,
                data=json_data,
                proxies=proxy,
                headers={&#34;Content-type&#34;: &#34;application/json&#34;},
            ),
        )
        return PrintJob._handle_response(response)

    @staticmethod
    def _handle_response(res: requests.Response) -&gt; Response:
        &#34;&#34;&#34;Converts the HTML response to a `Response`-object

        Args:
            res (requests.Response): HTML response from the Cloud Office Print server

        Raises:
            COPError: Error when the HTML status code is not 200

        Returns:
            Response: `Response`-object of HTML response
        &#34;&#34;&#34;
        if res.status_code != 200:
            raise COPError(res.text)
        else:
            return Response(res)

    @property
    def json(self) -&gt; str:
        &#34;&#34;&#34;JSON equivalent of the dict representation of this print job.
        This representation is isomorphic to the dict representation `Printjob.as_dict`.

        Returns:
            str: JSON equivalent of the dict representation of this print job
        &#34;&#34;&#34;
        return json.dumps(self.as_dict)

    @property
    def as_dict(self) -&gt; Dict:
        &#34;&#34;&#34;Return the dict representation of this print job.

        Returns:
            Dict: dict representation of this print job
        &#34;&#34;&#34;
        # Copy of STATIC_OPTS! Otherwise everything we add to &#39;result&#39; will also be added to &#39;STATIC_OPTS&#39;
        result = dict(STATIC_OPTS)
        # server config goes in the upper level
        if self.server.config:
            result.update(self.server.config.as_dict)

        # output config goes in &#34;output&#34;
        # and decides where its sub-configs go through its as_dict property
        # (e.g. PDFConfigs are just appended at this &#34;output&#34; level)
        result[&#34;output&#34;] = self.output_config.as_dict

        if self.template:
            result[&#34;template&#34;] = self.template.template_dict

        # If output_type is not specified, set this to the template filetype
        # If no template found: default docx
        if &#34;output_type&#34; not in self.output_config.as_dict.keys():
            if self.template:
                result[&#34;output&#34;][&#34;output_type&#34;] = result[&#34;template&#34;][&#34;template_type&#34;]
            else:
                result[&#34;output&#34;][&#34;output_type&#34;] = &#34;docx&#34;

        if isinstance(self.data, Mapping):
            result[&#34;files&#34;] = [
                {&#34;filename&#34;: name, &#34;data&#34;: data.as_dict}
                for name, data in self.data.items()
            ]
        elif isinstance(self.data, RESTSource):
            result[&#34;files&#34;] = [self.data.as_dict]
        else:
            result[&#34;files&#34;] = [{&#34;data&#34;: self.data.as_dict}]

        if len(self.prepend_files) &gt; 0:
            result[&#34;prepend_files&#34;] = [
                file.secondary_file_dict for file in self.prepend_files
            ]

        if len(self.append_files) &gt; 0:
            result[&#34;append_files&#34;] = [
                file.secondary_file_dict for file in self.append_files
            ]
        if len(self.attachments) &gt; 0:
            result[&#34;attachments&#34;] = [
                file.secondary_file_dict for file in self.attachments
            ]

        if len(self.subtemplates) &gt; 0:
            result[&#34;templates&#34;] = [
                {**file.secondary_file_dict, &#34;name&#34;: name}
                for name, file in self.subtemplates.items()
            ]

        # If verbose mode is activated, print the result to the terminal
        if self.cop_verbose:
            print(&#34;The JSON data that is sent to the Cloud Office Print server:\n&#34;)
            pprint(result)

        return result</code></pre>
</details>
<div class="desc"><p>A print job for a Cloud Office Print server.</p>
<p>This class contains all configuration options, resources, render elements &hellip;
and the <code><a title="cloudofficeprint.PrintJob.execute" href="#cloudofficeprint.PrintJob.execute">PrintJob.execute()</a></code> method to combine all these and send a request to the Cloud Office Print server.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>Union[Element, Mapping[str, Element], RESTSource]</code></dt>
<dd>This is either: An <code>Element</code> (e.g. an <code>ElementCollection</code>); A mapping, containing file names as keys and an <code>Element</code> as data. Multiple files will be produced from the different datas, the result is a zip file containing them. In the first case, no output file name is specified and the server will name it "file0".</dd>
<dt><strong><code>server</code></strong> :&ensp;<code>Server</code></dt>
<dd>Server to be used for this print job.</dd>
<dt><strong><code>template</code></strong> :&ensp;<code>Union[<a title="cloudofficeprint.Template" href="#cloudofficeprint.Template">Template</a>, <a title="cloudofficeprint.Resource" href="#cloudofficeprint.Resource">Resource</a>]</code></dt>
<dd>Template to use for this print job.</dd>
<dt><strong><code>output_config</code></strong> :&ensp;<code>OutputConfig</code>, optional</dt>
<dd>Output configuration to be used for this print job. Defaults to <code>OutputConfig</code>().</dd>
<dt><strong><code>subtemplates</code></strong> :&ensp;<code>Dict[str, <a title="cloudofficeprint.Resource" href="#cloudofficeprint.Resource">Resource</a>]</code>, optional</dt>
<dd>Subtemplates for this print job, accessible (in docx) through <code>{?include subtemplate_dict_key}</code>. Defaults to {}.</dd>
<dt><strong><code>prepend_files</code></strong> :&ensp;<code>List[<a title="cloudofficeprint.Resource" href="#cloudofficeprint.Resource">Resource</a>]</code>, optional</dt>
<dd>Files to prepend to the output file. Defaults to [].</dd>
<dt><strong><code>append_files</code></strong> :&ensp;<code>List[<a title="cloudofficeprint.Resource" href="#cloudofficeprint.Resource">Resource</a>]</code>, optional</dt>
<dd>Files to append to the output file. Defaults to [].</dd>
<dt><strong><code>cop_verbose</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether or not verbose mode should be activated. Defaults to False.</dd>
<dt><strong><code>attachments</code></strong> :&ensp;<code>List[<a title="cloudofficeprint.Resource" href="#cloudofficeprint.Resource">Resource</a>]</code>, optional</dt>
<dd>Files to attach to the pdf file. Defaults to []. The file must be PDF.</dd>
</dl></div>
<h3>Static methods</h3>
<dl>
<dt id="cloudofficeprint.PrintJob.execute_full_json"><code class="name flex">
<span>def <span class="ident">execute_full_json</span></span>(<span>json_data: str,<br>server: <a title="cloudofficeprint.config.server.Server" href="config/server.html#cloudofficeprint.config.server.Server">Server</a>) ‑> <a title="cloudofficeprint.response.Response" href="response.html#cloudofficeprint.response.Response">Response</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def execute_full_json(json_data: str, server: Server) -&gt; Response:
    &#34;&#34;&#34;If you already have the JSON to be sent to the server (not just the data, but the entire JSON body including your API key and template), this package will wrap the request to the server.

    Args:
        json_data (str): full JSON data that needs to be sent to a Cloud Office Print server
        server (Server): `Server`-object

    Returns:
        Response: `Response`-object
    &#34;&#34;&#34;
    server._raise_if_unreachable()
    proxy = server.config.proxies if server.config else None
    response = requests.post(
        server.url,
        data=json_data,
        proxies=proxy,
        headers={&#34;Content-type&#34;: &#34;application/json&#34;},
    )
    return PrintJob._handle_response(response)</code></pre>
</details>
<div class="desc"><p>If you already have the JSON to be sent to the server (not just the data, but the entire JSON body including your API key and template), this package will wrap the request to the server.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>json_data</code></strong> :&ensp;<code>str</code></dt>
<dd>full JSON data that needs to be sent to a Cloud Office Print server</dd>
<dt><strong><code>server</code></strong> :&ensp;<code>Server</code></dt>
<dd><code>Server</code>-object</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="cloudofficeprint.Response" href="#cloudofficeprint.Response">Response</a></code></dt>
<dd><code><a title="cloudofficeprint.Response" href="#cloudofficeprint.Response">Response</a></code>-object</dd>
</dl></div>
</dd>
<dt id="cloudofficeprint.PrintJob.execute_full_json_async"><code class="name flex">
<span>async def <span class="ident">execute_full_json_async</span></span>(<span>json_data: str,<br>server: <a title="cloudofficeprint.config.server.Server" href="config/server.html#cloudofficeprint.config.server.Server">Server</a>) ‑> <a title="cloudofficeprint.response.Response" href="response.html#cloudofficeprint.response.Response">Response</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
async def execute_full_json_async(json_data: str, server: Server) -&gt; Response:
    &#34;&#34;&#34;Async version of `Printjob.execute_full_json`

    Args:
        json_data (str): full JSON data that needs to be sent to a Cloud Office Print server
        server (Server): `Server`-object

    Returns:
        Response: `Response`-object
    &#34;&#34;&#34;
    server._raise_if_unreachable()
    proxy = server.config.proxies if server.config else None
    response = await asyncio.get_event_loop().run_in_executor(
        None,
        partial(
            requests.post,
            server.url,
            data=json_data,
            proxies=proxy,
            headers={&#34;Content-type&#34;: &#34;application/json&#34;},
        ),
    )
    return PrintJob._handle_response(response)</code></pre>
</details>
<div class="desc"><p>Async version of <code>Printjob.execute_full_json</code></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>json_data</code></strong> :&ensp;<code>str</code></dt>
<dd>full JSON data that needs to be sent to a Cloud Office Print server</dd>
<dt><strong><code>server</code></strong> :&ensp;<code>Server</code></dt>
<dd><code>Server</code>-object</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="cloudofficeprint.Response" href="#cloudofficeprint.Response">Response</a></code></dt>
<dd><code><a title="cloudofficeprint.Response" href="#cloudofficeprint.Response">Response</a></code>-object</dd>
</dl></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="cloudofficeprint.PrintJob.as_dict"><code class="name">prop <span class="ident">as_dict</span> : Dict</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def as_dict(self) -&gt; Dict:
    &#34;&#34;&#34;Return the dict representation of this print job.

    Returns:
        Dict: dict representation of this print job
    &#34;&#34;&#34;
    # Copy of STATIC_OPTS! Otherwise everything we add to &#39;result&#39; will also be added to &#39;STATIC_OPTS&#39;
    result = dict(STATIC_OPTS)
    # server config goes in the upper level
    if self.server.config:
        result.update(self.server.config.as_dict)

    # output config goes in &#34;output&#34;
    # and decides where its sub-configs go through its as_dict property
    # (e.g. PDFConfigs are just appended at this &#34;output&#34; level)
    result[&#34;output&#34;] = self.output_config.as_dict

    if self.template:
        result[&#34;template&#34;] = self.template.template_dict

    # If output_type is not specified, set this to the template filetype
    # If no template found: default docx
    if &#34;output_type&#34; not in self.output_config.as_dict.keys():
        if self.template:
            result[&#34;output&#34;][&#34;output_type&#34;] = result[&#34;template&#34;][&#34;template_type&#34;]
        else:
            result[&#34;output&#34;][&#34;output_type&#34;] = &#34;docx&#34;

    if isinstance(self.data, Mapping):
        result[&#34;files&#34;] = [
            {&#34;filename&#34;: name, &#34;data&#34;: data.as_dict}
            for name, data in self.data.items()
        ]
    elif isinstance(self.data, RESTSource):
        result[&#34;files&#34;] = [self.data.as_dict]
    else:
        result[&#34;files&#34;] = [{&#34;data&#34;: self.data.as_dict}]

    if len(self.prepend_files) &gt; 0:
        result[&#34;prepend_files&#34;] = [
            file.secondary_file_dict for file in self.prepend_files
        ]

    if len(self.append_files) &gt; 0:
        result[&#34;append_files&#34;] = [
            file.secondary_file_dict for file in self.append_files
        ]
    if len(self.attachments) &gt; 0:
        result[&#34;attachments&#34;] = [
            file.secondary_file_dict for file in self.attachments
        ]

    if len(self.subtemplates) &gt; 0:
        result[&#34;templates&#34;] = [
            {**file.secondary_file_dict, &#34;name&#34;: name}
            for name, file in self.subtemplates.items()
        ]

    # If verbose mode is activated, print the result to the terminal
    if self.cop_verbose:
        print(&#34;The JSON data that is sent to the Cloud Office Print server:\n&#34;)
        pprint(result)

    return result</code></pre>
</details>
<div class="desc"><p>Return the dict representation of this print job.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict</code></dt>
<dd>dict representation of this print job</dd>
</dl></div>
</dd>
<dt id="cloudofficeprint.PrintJob.json"><code class="name">prop <span class="ident">json</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def json(self) -&gt; str:
    &#34;&#34;&#34;JSON equivalent of the dict representation of this print job.
    This representation is isomorphic to the dict representation `Printjob.as_dict`.

    Returns:
        str: JSON equivalent of the dict representation of this print job
    &#34;&#34;&#34;
    return json.dumps(self.as_dict)</code></pre>
</details>
<div class="desc"><p>JSON equivalent of the dict representation of this print job.
This representation is isomorphic to the dict representation <code>Printjob.as_dict</code>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>JSON equivalent of the dict representation of this print job</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="cloudofficeprint.PrintJob.execute"><code class="name flex">
<span>def <span class="ident">execute</span></span>(<span>self) ‑> <a title="cloudofficeprint.response.Response" href="response.html#cloudofficeprint.response.Response">Response</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute(self) -&gt; Response:
    &#34;&#34;&#34;Execute this print job.

    Returns:
        Response: `Response`-object
    &#34;&#34;&#34;
    self.server._raise_if_unreachable()
    proxy = self.server.config.proxies if self.server.config else None
    response = requests.post(
        self.server.url,
        json=self.as_dict,
        proxies=proxy,
        headers={&#34;Content-type&#34;: &#34;application/json&#34;},
    )
    if type(self.template) is Template and self.template.should_hash:
        template_hash = response.headers[&#34;Template-Hash&#34;]
        if template_hash:
            self.template.update_hash(template_hash)
    return self._handle_response(response)</code></pre>
</details>
<div class="desc"><p>Execute this print job.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="cloudofficeprint.Response" href="#cloudofficeprint.Response">Response</a></code></dt>
<dd><code><a title="cloudofficeprint.Response" href="#cloudofficeprint.Response">Response</a></code>-object</dd>
</dl></div>
</dd>
<dt id="cloudofficeprint.PrintJob.execute_async"><code class="name flex">
<span>async def <span class="ident">execute_async</span></span>(<span>self) ‑> <a title="cloudofficeprint.response.Response" href="response.html#cloudofficeprint.response.Response">Response</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def execute_async(self) -&gt; Response:
    &#34;&#34;&#34;Async version of `PrintJob.execute`

    Returns:
        Response: `Response`-object
    &#34;&#34;&#34;
    self.server._raise_if_unreachable()
    proxy = self.server.config.proxies if self.server.config else None
    response = await asyncio.get_event_loop().run_in_executor(
        None,
        partial(
            requests.post,
            self.server.url,
            json=self.as_dict,
            proxies=proxy,
            headers={&#34;Content-type&#34;: &#34;application/json&#34;},
        ),
    )
    if type(self.template) is Template and self.template.should_hash:
        template_hash = response.headers[&#34;Template-Hash&#34;]
        if template_hash:
            self.template.update_hash(template_hash)
    return PrintJob._handle_response(response)</code></pre>
</details>
<div class="desc"><p>Async version of <code><a title="cloudofficeprint.PrintJob.execute" href="#cloudofficeprint.PrintJob.execute">PrintJob.execute()</a></code></p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="cloudofficeprint.Response" href="#cloudofficeprint.Response">Response</a></code></dt>
<dd><code><a title="cloudofficeprint.Response" href="#cloudofficeprint.Response">Response</a></code>-object</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="cloudofficeprint.Resource"><code class="flex name class">
<span>class <span class="ident">Resource</span></span>
<span>(</span><span>data: str | bytes = None, filetype: str = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Resource(ABC):
    &#34;&#34;&#34;The abstract base class for the resources.&#34;&#34;&#34;

    def __init__(
        self,
        data: Union[str, bytes] = None,
        filetype: str = None,
    ):
        &#34;&#34;&#34;Create a new Resource.

        Args:
            data (Union[str, bytes], optional): the data for this Resource. Defaults to None.
            filetype (str, optional): the file type of this Resource. Defaults to None.
        &#34;&#34;&#34;
        self.data: Union[str, bytes] = data
        self.filetype: str = filetype

    @property
    def mimetype(self) -&gt; str:
        &#34;&#34;&#34;
        Returns:
            str: the mime type of the Resource
        &#34;&#34;&#34;
        return type_utils.extension_to_mimetype(self.filetype)

    @property
    def template_json(self) -&gt; str:
        &#34;&#34;&#34;
        Returns:
            str: the JSON representation of this Resource.
        &#34;&#34;&#34;
        return json.dumps(self.template_dict)

    @property
    @abstractmethod
    def template_dict(self) -&gt; Dict:
        &#34;&#34;&#34;
        Returns:
            Dict: the dictionary representation of this Resource.
        &#34;&#34;&#34;
        pass

    @property
    def secondary_file_json(self) -&gt; str:
        &#34;&#34;&#34;
        Returns:
            str: the JSON representation of this Resource.
        &#34;&#34;&#34;
        return json.dumps(self.secondary_file_dict)

    @property
    @abstractmethod
    def secondary_file_dict(self) -&gt; Dict:
        &#34;&#34;&#34;
        Returns:
            Dict: the dictionarty representation of this resource as a secondary file (prepend, append, insert, as subtemplate).
        &#34;&#34;&#34;
        pass

    def __str__(self) -&gt; str:
        &#34;&#34;&#34;Override the string representation of this class to return the template-style json.

        Returns:
            str: the JSON representation of this resource as a template.
        &#34;&#34;&#34;
        return self.template_json

    @staticmethod
    def from_raw(raw_data: bytes, filetype: str) -&gt; &#34;RawResource&#34;:
        &#34;&#34;&#34;Create a RawResource from raw file data.

        Args:
            raw_data (bytes): the raw data as a [bytes-like object](https://docs.python.org/3/glossary.html#term-bytes-like-object).
            filetype (str): the file type (extension).

        Returns:
            RawResource: the created RawResource.
        &#34;&#34;&#34;
        return RawResource(raw_data, filetype)

    @staticmethod
    def from_base64(base64string: str, filetype: str) -&gt; &#34;Base64Resource&#34;:
        &#34;&#34;&#34;Create a Base64Resource from a base64 string.

        Args:
            base64string (str): the base64 encoded representation of a file.
            filetype (str): the file type (extension).

        Returns:
            Base64Resource: the created Base64Resource.
        &#34;&#34;&#34;
        return Base64Resource(base64string, filetype)

    @staticmethod
    def from_local_file(local_path: str) -&gt; &#34;Base64Resource&#34;:
        &#34;&#34;&#34;Create a Base64Resource with the contents of a local file.
        The filetype is determined by the extension of the file.

        Throws IOError if it can&#39;t read the file.

        Args:
            local_path (str): the path to local file.

        Returns:
            Base64Resource: the created Base64Resource.
        &#34;&#34;&#34;
        return Base64Resource(
            file_utils.read_file_as_base64(local_path),
            type_utils.path_to_extension(local_path),
        )

    @staticmethod
    def from_server_path(path: str) -&gt; &#34;ServerPathResource&#34;:
        &#34;&#34;&#34;Create a ServerPathResource targeting a file on the server.
        The filetype is determined by the extension of the file.

        Args:
            path (str): the location of target file on the server.

        Returns:
            ServerPathResource: the created ServerPathResource.
        &#34;&#34;&#34;
        return ServerPathResource(path)

    @staticmethod
    def from_url(url: str, filetype: str) -&gt; &#34;URLResource&#34;:
        &#34;&#34;&#34;Create an URLResource targeting the file at a given URL.

        Args:
            url (str): the file URL.
            filetype (str): the file type (extension).

        Returns:
            URLResource: the created URLResource.
        &#34;&#34;&#34;
        return URLResource(url, filetype)

    @staticmethod
    def from_html(htmlstring: str, landscape: bool = False) -&gt; &#34;HTMLResource&#34;:
        &#34;&#34;&#34;Create an HTMLResource with html data in plain text.
        Landscape is not supported for prepend/append sources, only for template resources.

        Args:
            htmlstring (str): the html content.
            landscape (bool, optional): whether or not to use the landscape option. Defaults to False.

        Returns:
            HTMLResource: the created HTMLResource.
        &#34;&#34;&#34;
        return HTMLResource(htmlstring, landscape)</code></pre>
</details>
<div class="desc"><p>The abstract base class for the resources.</p>
<p>Create a new Resource.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>Union[str, bytes]</code>, optional</dt>
<dd>the data for this Resource. Defaults to None.</dd>
<dt><strong><code>filetype</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>the file type of this Resource. Defaults to None.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="cloudofficeprint.resource.Base64Resource" href="resource.html#cloudofficeprint.resource.Base64Resource">Base64Resource</a></li>
<li><a title="cloudofficeprint.resource.HTMLResource" href="resource.html#cloudofficeprint.resource.HTMLResource">HTMLResource</a></li>
<li><a title="cloudofficeprint.resource.RawResource" href="resource.html#cloudofficeprint.resource.RawResource">RawResource</a></li>
<li><a title="cloudofficeprint.resource.ServerPathResource" href="resource.html#cloudofficeprint.resource.ServerPathResource">ServerPathResource</a></li>
<li><a title="cloudofficeprint.resource.URLResource" href="resource.html#cloudofficeprint.resource.URLResource">URLResource</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="cloudofficeprint.Resource.from_base64"><code class="name flex">
<span>def <span class="ident">from_base64</span></span>(<span>base64string: str, filetype: str) ‑> <a title="cloudofficeprint.resource.Base64Resource" href="resource.html#cloudofficeprint.resource.Base64Resource">Base64Resource</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_base64(base64string: str, filetype: str) -&gt; &#34;Base64Resource&#34;:
    &#34;&#34;&#34;Create a Base64Resource from a base64 string.

    Args:
        base64string (str): the base64 encoded representation of a file.
        filetype (str): the file type (extension).

    Returns:
        Base64Resource: the created Base64Resource.
    &#34;&#34;&#34;
    return Base64Resource(base64string, filetype)</code></pre>
</details>
<div class="desc"><p>Create a Base64Resource from a base64 string.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>base64string</code></strong> :&ensp;<code>str</code></dt>
<dd>the base64 encoded representation of a file.</dd>
<dt><strong><code>filetype</code></strong> :&ensp;<code>str</code></dt>
<dd>the file type (extension).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Base64Resource</code></dt>
<dd>the created Base64Resource.</dd>
</dl></div>
</dd>
<dt id="cloudofficeprint.Resource.from_html"><code class="name flex">
<span>def <span class="ident">from_html</span></span>(<span>htmlstring: str, landscape: bool = False) ‑> <a title="cloudofficeprint.resource.HTMLResource" href="resource.html#cloudofficeprint.resource.HTMLResource">HTMLResource</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_html(htmlstring: str, landscape: bool = False) -&gt; &#34;HTMLResource&#34;:
    &#34;&#34;&#34;Create an HTMLResource with html data in plain text.
    Landscape is not supported for prepend/append sources, only for template resources.

    Args:
        htmlstring (str): the html content.
        landscape (bool, optional): whether or not to use the landscape option. Defaults to False.

    Returns:
        HTMLResource: the created HTMLResource.
    &#34;&#34;&#34;
    return HTMLResource(htmlstring, landscape)</code></pre>
</details>
<div class="desc"><p>Create an HTMLResource with html data in plain text.
Landscape is not supported for prepend/append sources, only for template resources.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>htmlstring</code></strong> :&ensp;<code>str</code></dt>
<dd>the html content.</dd>
<dt><strong><code>landscape</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>whether or not to use the landscape option. Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>HTMLResource</code></dt>
<dd>the created HTMLResource.</dd>
</dl></div>
</dd>
<dt id="cloudofficeprint.Resource.from_local_file"><code class="name flex">
<span>def <span class="ident">from_local_file</span></span>(<span>local_path: str) ‑> <a title="cloudofficeprint.resource.Base64Resource" href="resource.html#cloudofficeprint.resource.Base64Resource">Base64Resource</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_local_file(local_path: str) -&gt; &#34;Base64Resource&#34;:
    &#34;&#34;&#34;Create a Base64Resource with the contents of a local file.
    The filetype is determined by the extension of the file.

    Throws IOError if it can&#39;t read the file.

    Args:
        local_path (str): the path to local file.

    Returns:
        Base64Resource: the created Base64Resource.
    &#34;&#34;&#34;
    return Base64Resource(
        file_utils.read_file_as_base64(local_path),
        type_utils.path_to_extension(local_path),
    )</code></pre>
</details>
<div class="desc"><p>Create a Base64Resource with the contents of a local file.
The filetype is determined by the extension of the file.</p>
<p>Throws IOError if it can't read the file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>local_path</code></strong> :&ensp;<code>str</code></dt>
<dd>the path to local file.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Base64Resource</code></dt>
<dd>the created Base64Resource.</dd>
</dl></div>
</dd>
<dt id="cloudofficeprint.Resource.from_raw"><code class="name flex">
<span>def <span class="ident">from_raw</span></span>(<span>raw_data: bytes, filetype: str) ‑> <a title="cloudofficeprint.resource.RawResource" href="resource.html#cloudofficeprint.resource.RawResource">RawResource</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_raw(raw_data: bytes, filetype: str) -&gt; &#34;RawResource&#34;:
    &#34;&#34;&#34;Create a RawResource from raw file data.

    Args:
        raw_data (bytes): the raw data as a [bytes-like object](https://docs.python.org/3/glossary.html#term-bytes-like-object).
        filetype (str): the file type (extension).

    Returns:
        RawResource: the created RawResource.
    &#34;&#34;&#34;
    return RawResource(raw_data, filetype)</code></pre>
</details>
<div class="desc"><p>Create a RawResource from raw file data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>raw_data</code></strong> :&ensp;<code>bytes</code></dt>
<dd>the raw data as a <a href="https://docs.python.org/3/glossary.html#term-bytes-like-object">bytes-like object</a>.</dd>
<dt><strong><code>filetype</code></strong> :&ensp;<code>str</code></dt>
<dd>the file type (extension).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>RawResource</code></dt>
<dd>the created RawResource.</dd>
</dl></div>
</dd>
<dt id="cloudofficeprint.Resource.from_server_path"><code class="name flex">
<span>def <span class="ident">from_server_path</span></span>(<span>path: str) ‑> <a title="cloudofficeprint.resource.ServerPathResource" href="resource.html#cloudofficeprint.resource.ServerPathResource">ServerPathResource</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_server_path(path: str) -&gt; &#34;ServerPathResource&#34;:
    &#34;&#34;&#34;Create a ServerPathResource targeting a file on the server.
    The filetype is determined by the extension of the file.

    Args:
        path (str): the location of target file on the server.

    Returns:
        ServerPathResource: the created ServerPathResource.
    &#34;&#34;&#34;
    return ServerPathResource(path)</code></pre>
</details>
<div class="desc"><p>Create a ServerPathResource targeting a file on the server.
The filetype is determined by the extension of the file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>the location of target file on the server.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ServerPathResource</code></dt>
<dd>the created ServerPathResource.</dd>
</dl></div>
</dd>
<dt id="cloudofficeprint.Resource.from_url"><code class="name flex">
<span>def <span class="ident">from_url</span></span>(<span>url: str, filetype: str) ‑> <a title="cloudofficeprint.resource.URLResource" href="resource.html#cloudofficeprint.resource.URLResource">URLResource</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_url(url: str, filetype: str) -&gt; &#34;URLResource&#34;:
    &#34;&#34;&#34;Create an URLResource targeting the file at a given URL.

    Args:
        url (str): the file URL.
        filetype (str): the file type (extension).

    Returns:
        URLResource: the created URLResource.
    &#34;&#34;&#34;
    return URLResource(url, filetype)</code></pre>
</details>
<div class="desc"><p>Create an URLResource targeting the file at a given URL.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>str</code></dt>
<dd>the file URL.</dd>
<dt><strong><code>filetype</code></strong> :&ensp;<code>str</code></dt>
<dd>the file type (extension).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>URLResource</code></dt>
<dd>the created URLResource.</dd>
</dl></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="cloudofficeprint.Resource.mimetype"><code class="name">prop <span class="ident">mimetype</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mimetype(self) -&gt; str:
    &#34;&#34;&#34;
    Returns:
        str: the mime type of the Resource
    &#34;&#34;&#34;
    return type_utils.extension_to_mimetype(self.filetype)</code></pre>
</details>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>the mime type of the Resource</dd>
</dl></div>
</dd>
<dt id="cloudofficeprint.Resource.secondary_file_dict"><code class="name">prop <span class="ident">secondary_file_dict</span> : Dict</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@abstractmethod
def secondary_file_dict(self) -&gt; Dict:
    &#34;&#34;&#34;
    Returns:
        Dict: the dictionarty representation of this resource as a secondary file (prepend, append, insert, as subtemplate).
    &#34;&#34;&#34;
    pass</code></pre>
</details>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict</code></dt>
<dd>the dictionarty representation of this resource as a secondary file (prepend, append, insert, as subtemplate).</dd>
</dl></div>
</dd>
<dt id="cloudofficeprint.Resource.secondary_file_json"><code class="name">prop <span class="ident">secondary_file_json</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def secondary_file_json(self) -&gt; str:
    &#34;&#34;&#34;
    Returns:
        str: the JSON representation of this Resource.
    &#34;&#34;&#34;
    return json.dumps(self.secondary_file_dict)</code></pre>
</details>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>the JSON representation of this Resource.</dd>
</dl></div>
</dd>
<dt id="cloudofficeprint.Resource.template_dict"><code class="name">prop <span class="ident">template_dict</span> : Dict</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@abstractmethod
def template_dict(self) -&gt; Dict:
    &#34;&#34;&#34;
    Returns:
        Dict: the dictionary representation of this Resource.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict</code></dt>
<dd>the dictionary representation of this Resource.</dd>
</dl></div>
</dd>
<dt id="cloudofficeprint.Resource.template_json"><code class="name">prop <span class="ident">template_json</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def template_json(self) -&gt; str:
    &#34;&#34;&#34;
    Returns:
        str: the JSON representation of this Resource.
    &#34;&#34;&#34;
    return json.dumps(self.template_dict)</code></pre>
</details>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>the JSON representation of this Resource.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="cloudofficeprint.Response"><code class="flex name class">
<span>class <span class="ident">Response</span></span>
<span>(</span><span>response: requests.models.Response)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Response():
    &#34;&#34;&#34;The Response class serves as a container for and interface with the Cloud Office Print server&#39;s response to a printjob request.

    The Cloud Office Print server can also throw an error, in which case you will be dealing with a cloudofficeprint.exceptions.COPError instead of this class.
    &#34;&#34;&#34;

    def __init__(self, response: requests.Response):
        &#34;&#34;&#34;You should never need to construct a Response manually.

        Args:
            response (requests.Response): Response object from the requests package
        &#34;&#34;&#34;
        self._mimetype = response.headers[&#34;Content-Type&#34;]
        self._bytes = response.content

    @property
    def mimetype(self) -&gt; str:
        &#34;&#34;&#34;Mime type of this response.

        Returns:
            str: mime type of this response
        &#34;&#34;&#34;
        return self._mimetype

    @property
    def filetype(self) -&gt; str:
        &#34;&#34;&#34;File type (extension) of this response. E.g. &#34;docx&#34;.

        Returns:
            str: file type of this response
        &#34;&#34;&#34;
        return type_utils.mimetype_to_extension(self.mimetype)

    @property
    def binary(self) -&gt; bytes:
        &#34;&#34;&#34;Binary representation of the output file.

        Response.to_file can be used to output to a file,
        alternatively, use this property to do something else with the binary data.

        Returns:
            bytes: response file as binary
        &#34;&#34;&#34;
        return self._bytes

    def to_string(self) -&gt; str:
        &#34;&#34;&#34;Return the string representation of this buffer.
        Useful if the server returns a JSON (e.g. for output_type &#39;count_tags&#39;).

        Raises:
            err: raise error is bytes cannot be decoded in utf-8

        Returns:
            str: string representation of this buffer
        &#34;&#34;&#34;
        try:
            return self._bytes.decode(&#39;utf-8&#39;)
        except UnicodeDecodeError as err:
            print(&#34;&#34;&#34;The method &#39;to_string()&#39; cannot be called on this object.
            The server response is probably not a string (e.g. JSON).
            To get the bytes of the response, use the property &#39;binary&#39; instead.&#34;&#34;&#34;)
            raise err

    def to_file(self, path: str):
        &#34;&#34;&#34;Write the response to a file at the given path without extension.

        If the given file path does not contain an extension,
        the correct path is automatically added from the response data.
        That is how this method is intended to be used.
        You should only specify the extension in the path if you have some reason to specify the extension manually.

        Args:
            path (str): path without extension
        &#34;&#34;&#34;

        if not splitext(path)[1]:
            path += &#34;.&#34; + self.filetype

        # open the file in binary (&#34;b&#34;) and write (&#34;w&#34;) mode
        outfile = open(path, &#34;wb&#34;)
        outfile.write(self.binary)
        outfile.close()</code></pre>
</details>
<div class="desc"><p>The Response class serves as a container for and interface with the Cloud Office Print server's response to a printjob request.</p>
<p>The Cloud Office Print server can also throw an error, in which case you will be dealing with a cloudofficeprint.exceptions.COPError instead of this class.</p>
<p>You should never need to construct a Response manually.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>response</code></strong> :&ensp;<code>requests.Response</code></dt>
<dd>Response object from the requests package</dd>
</dl></div>
<h3>Instance variables</h3>
<dl>
<dt id="cloudofficeprint.Response.binary"><code class="name">prop <span class="ident">binary</span> : bytes</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def binary(self) -&gt; bytes:
    &#34;&#34;&#34;Binary representation of the output file.

    Response.to_file can be used to output to a file,
    alternatively, use this property to do something else with the binary data.

    Returns:
        bytes: response file as binary
    &#34;&#34;&#34;
    return self._bytes</code></pre>
</details>
<div class="desc"><p>Binary representation of the output file.</p>
<p>Response.to_file can be used to output to a file,
alternatively, use this property to do something else with the binary data.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bytes</code></dt>
<dd>response file as binary</dd>
</dl></div>
</dd>
<dt id="cloudofficeprint.Response.filetype"><code class="name">prop <span class="ident">filetype</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def filetype(self) -&gt; str:
    &#34;&#34;&#34;File type (extension) of this response. E.g. &#34;docx&#34;.

    Returns:
        str: file type of this response
    &#34;&#34;&#34;
    return type_utils.mimetype_to_extension(self.mimetype)</code></pre>
</details>
<div class="desc"><p>File type (extension) of this response. E.g. "docx".</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>file type of this response</dd>
</dl></div>
</dd>
<dt id="cloudofficeprint.Response.mimetype"><code class="name">prop <span class="ident">mimetype</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mimetype(self) -&gt; str:
    &#34;&#34;&#34;Mime type of this response.

    Returns:
        str: mime type of this response
    &#34;&#34;&#34;
    return self._mimetype</code></pre>
</details>
<div class="desc"><p>Mime type of this response.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>mime type of this response</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="cloudofficeprint.Response.to_file"><code class="name flex">
<span>def <span class="ident">to_file</span></span>(<span>self, path: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_file(self, path: str):
    &#34;&#34;&#34;Write the response to a file at the given path without extension.

    If the given file path does not contain an extension,
    the correct path is automatically added from the response data.
    That is how this method is intended to be used.
    You should only specify the extension in the path if you have some reason to specify the extension manually.

    Args:
        path (str): path without extension
    &#34;&#34;&#34;

    if not splitext(path)[1]:
        path += &#34;.&#34; + self.filetype

    # open the file in binary (&#34;b&#34;) and write (&#34;w&#34;) mode
    outfile = open(path, &#34;wb&#34;)
    outfile.write(self.binary)
    outfile.close()</code></pre>
</details>
<div class="desc"><p>Write the response to a file at the given path without extension.</p>
<p>If the given file path does not contain an extension,
the correct path is automatically added from the response data.
That is how this method is intended to be used.
You should only specify the extension in the path if you have some reason to specify the extension manually.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>path without extension</dd>
</dl></div>
</dd>
<dt id="cloudofficeprint.Response.to_string"><code class="name flex">
<span>def <span class="ident">to_string</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_string(self) -&gt; str:
    &#34;&#34;&#34;Return the string representation of this buffer.
    Useful if the server returns a JSON (e.g. for output_type &#39;count_tags&#39;).

    Raises:
        err: raise error is bytes cannot be decoded in utf-8

    Returns:
        str: string representation of this buffer
    &#34;&#34;&#34;
    try:
        return self._bytes.decode(&#39;utf-8&#39;)
    except UnicodeDecodeError as err:
        print(&#34;&#34;&#34;The method &#39;to_string()&#39; cannot be called on this object.
        The server response is probably not a string (e.g. JSON).
        To get the bytes of the response, use the property &#39;binary&#39; instead.&#34;&#34;&#34;)
        raise err</code></pre>
</details>
<div class="desc"><p>Return the string representation of this buffer.
Useful if the server returns a JSON (e.g. for output_type 'count_tags').</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>err</code></dt>
<dd>raise error is bytes cannot be decoded in utf-8</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>string representation of this buffer</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="cloudofficeprint.Template"><code class="flex name class">
<span>class <span class="ident">Template</span></span>
<span>(</span><span>resource: <a title="cloudofficeprint.resource.Resource" href="resource.html#cloudofficeprint.resource.Resource">Resource</a>,<br>start_delimiter: str = None,<br>end_delimiter: str = None,<br>should_hash: bool = None,<br>template_hash: str = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Template:
    &#34;&#34;&#34;The Template class&#34;&#34;&#34;

    def __init__(
        self,
        resource: Resource,
        start_delimiter: str = None,
        end_delimiter: str = None,
        should_hash: bool = None,
        template_hash: str = None,
    ):
        &#34;&#34;&#34;Create a new Template.

        Args:
            resource (Resource): the resource of this template.
            start_delimiter (str, optional): the starting delimiter used in the template.
            end_delimiter (str, optional): the starting delimiter used in the template.
            should_hash (bool, optional): whether the template should be hashed on the server.
            template_hash (str, optional): the hash of the template.
        &#34;&#34;&#34;
        self.resource = resource
        self.start_delimiter = start_delimiter
        self.end_delimiter = end_delimiter
        self.should_hash = should_hash
        self.template_hash = template_hash

    def update_hash(self, template_hash: str):
        &#34;&#34;&#34;Update the Template to store a hash.
        On the next request to the server, the file data will not be sent, only the hash of the template.

        Args:
            template_hash (str): the hash of the template.
        &#34;&#34;&#34;
        self.template_hash = template_hash
        self.should_hash = False

    def reset_hash(self, should_hash: bool = True):
        &#34;&#34;&#34;Reset the stored hash of the template.

        Args:
            should_hash (bool, optional): whether the template should be hashed on the server. Defaults to True.
        &#34;&#34;&#34;
        self.template_hash = None
        self.should_hash = should_hash

    @property
    def mimetype(self) -&gt; str:
        &#34;&#34;&#34;
        Returns:
            str: the mime type of the Resource
        &#34;&#34;&#34;
        return self.resource.mimetype

    @property
    def template_json(self) -&gt; str:
        &#34;&#34;&#34;
        Returns:
            str: the JSON representation of this Resource.
        &#34;&#34;&#34;
        return json.dumps(self.template_dict)

    @property
    def template_dict(self) -&gt; Dict:
        &#34;&#34;&#34;
        Returns:
            Dict: the dictionary representation of this Resource.
        &#34;&#34;&#34;
        if self.template_hash and not self.should_hash:
            dict = {
                &#34;template_type&#34;: self.resource.filetype,
                &#34;template_hash&#34;: self.template_hash,
            }
            if self.start_delimiter:
                dict[&#34;start_delimiter&#34;] = self.start_delimiter
            if self.end_delimiter:
                dict[&#34;end_delimiter&#34;] = self.end_delimiter
            return dict
        dict = self.resource.template_dict
        if self.start_delimiter:
            dict[&#34;start_delimiter&#34;] = self.start_delimiter
        if self.end_delimiter:
            dict[&#34;end_delimiter&#34;] = self.end_delimiter
        if self.should_hash:
            dict[&#34;should_hash&#34;] = self.should_hash
        if self.template_hash:
            dict[&#34;template_hash&#34;] = self.template_hash
        return dict

    def __str__(self) -&gt; str:
        &#34;&#34;&#34;Override the string representation of this class to return the template-style json.

        Returns:
            str: the JSON representation of this resource as a template.
        &#34;&#34;&#34;
        return self.template_json

    @staticmethod
    def from_raw(
        raw_data: bytes,
        filetype: str,
        start_delimiter: str = None,
        end_delimiter: str = None,
        should_hash: bool = None,
        template_hash: str = None,
    ) -&gt; &#34;Template&#34;:
        &#34;&#34;&#34;Create a Template with a RawResource from raw file data.

        Args:
            raw_data (bytes): the raw data as a [bytes-like object](https://docs.python.org/3/glossary.html#term-bytes-like-object).
            filetype (str): the file type (extension).
            start_delimiter (str, optional): the starting delimiter used in the template.
            end_delimiter (str, optional): the starting delimiter used in the template.
            should_hash (bool, optional): whether the template should be hashed on the server.
            template_hash (str, optional): the hash of the template.

        Returns:
            Template: the created Template.
        &#34;&#34;&#34;
        return Template(
            Resource.from_raw(raw_data, filetype),
            start_delimiter,
            end_delimiter,
            should_hash,
            template_hash,
        )

    @staticmethod
    def from_base64(
        base64string: str,
        filetype: str,
        start_delimiter: str = None,
        end_delimiter: str = None,
        should_hash: bool = None,
        template_hash: str = None,
    ) -&gt; &#34;Template&#34;:
        &#34;&#34;&#34;Create a Template with a Base64Resource from a base64 string.

        Args:
            base64string (str): the base64 encoded representation of a file.
            filetype (str): the file type (extension).
            start_delimiter (str, optional): the starting delimiter used in the template.
            end_delimiter (str, optional): the starting delimiter used in the template.
            should_hash (bool, optional): whether the template should be hashed on the server.
            template_hash (str, optional): the hash of the template.

        Returns:
            Template: the created Template.
        &#34;&#34;&#34;
        return Template(
            Resource.from_base64(base64string, filetype),
            start_delimiter,
            end_delimiter,
            should_hash,
            template_hash,
        )

    @staticmethod
    def from_local_file(
        local_path: str,
        start_delimiter: str = None,
        end_delimiter: str = None,
        should_hash: bool = None,
        template_hash: str = None,
    ) -&gt; &#34;Template&#34;:
        &#34;&#34;&#34;Create a Template with a Base64Resource with the contents of a local file.
        The filetype is determined by the extension of the file.

        Throws IOError if it can&#39;t read the file.

        Args:
            local_path (str): the path to local file.
            start_delimiter (str, optional): the starting delimiter used in the template.
            end_delimiter (str, optional): the starting delimiter used in the template.
            should_hash (bool, optional): whether the template should be hashed on the server.
            template_hash (str, optional): the hash of the template.

        Returns:
            Template: the created Template.
        &#34;&#34;&#34;
        return Template(
            Resource.from_local_file(local_path),
            start_delimiter,
            end_delimiter,
            should_hash,
            template_hash,
        )

    @staticmethod
    def from_server_path(
        path: str,
        start_delimiter: str = None,
        end_delimiter: str = None,
        should_hash: bool = None,
        template_hash: str = None,
    ) -&gt; &#34;Template&#34;:
        &#34;&#34;&#34;Create a Template with a ServerPathResource targeting a file on the server.
        The filetype is determined by the extension of the file.

        Args:
            path (str): the location of target file on the server.
            start_delimiter (str, optional): the starting delimiter used in the template.
            end_delimiter (str, optional): the starting delimiter used in the template.
            should_hash (bool, optional): whether the template should be hashed on the server.
            template_hash (str, optional): the hash of the template.

        Returns:
            Template: the created Template.
        &#34;&#34;&#34;
        return Template(
            Resource.from_server_path(path),
            start_delimiter,
            end_delimiter,
            should_hash,
            template_hash,
        )

    @staticmethod
    def from_url(
        url: str,
        filetype: str,
        start_delimiter: str = None,
        end_delimiter: str = None,
        should_hash: bool = None,
        template_hash: str = None,
    ) -&gt; &#34;Template&#34;:
        &#34;&#34;&#34;Create a Template with a URLResource targeting the file at a given url.

        Args:
            url (str): the file URL.
            filetype (str): the file type (extension).
            start_delimiter (str, optional): the starting delimiter used in the template.
            end_delimiter (str, optional): the starting delimiter used in the template.
            should_hash (bool, optional): whether the template should be hashed on the server.
            template_hash (str, optional): the hash of the template.

        Returns:
            Template: the created Template.
        &#34;&#34;&#34;
        return Template(
            Resource.from_url(url, filetype),
            start_delimiter,
            end_delimiter,
            should_hash,
            template_hash,
        )

    @staticmethod
    def from_html(
        htmlstring: str,
        landscape: bool = False,
        start_delimiter: str = None,
        end_delimiter: str = None,
        should_hash: bool = None,
        template_hash: str = None,
    ) -&gt; &#34;Template&#34;:
        &#34;&#34;&#34;Create a Template with a HTMLResource with html data in plain text.

        Args:
            htmlstring (str): the html content.
            landscape (bool, optional): whether or not to use the landscape option. Defaults to False.
            start_delimiter (str, optional): the starting delimiter used in the template.
            end_delimiter (str, optional): the starting delimiter used in the template.
            should_hash (bool, optional): whether the template should be hashed on the server.
            template_hash (str, optional): the hash of the template.

        Returns:
            Template: the created Template.
        &#34;&#34;&#34;
        return Template(
            Resource.from_html(htmlstring, landscape),
            start_delimiter,
            end_delimiter,
            should_hash,
            template_hash,
        )</code></pre>
</details>
<div class="desc"><p>The Template class</p>
<p>Create a new Template.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource</code></strong> :&ensp;<code><a title="cloudofficeprint.Resource" href="#cloudofficeprint.Resource">Resource</a></code></dt>
<dd>the resource of this template.</dd>
<dt><strong><code>start_delimiter</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>the starting delimiter used in the template.</dd>
<dt><strong><code>end_delimiter</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>the starting delimiter used in the template.</dd>
<dt><strong><code>should_hash</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>whether the template should be hashed on the server.</dd>
<dt><strong><code>template_hash</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>the hash of the template.</dd>
</dl></div>
<h3>Static methods</h3>
<dl>
<dt id="cloudofficeprint.Template.from_base64"><code class="name flex">
<span>def <span class="ident">from_base64</span></span>(<span>base64string: str,<br>filetype: str,<br>start_delimiter: str = None,<br>end_delimiter: str = None,<br>should_hash: bool = None,<br>template_hash: str = None) ‑> <a title="cloudofficeprint.template.Template" href="template.html#cloudofficeprint.template.Template">Template</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_base64(
    base64string: str,
    filetype: str,
    start_delimiter: str = None,
    end_delimiter: str = None,
    should_hash: bool = None,
    template_hash: str = None,
) -&gt; &#34;Template&#34;:
    &#34;&#34;&#34;Create a Template with a Base64Resource from a base64 string.

    Args:
        base64string (str): the base64 encoded representation of a file.
        filetype (str): the file type (extension).
        start_delimiter (str, optional): the starting delimiter used in the template.
        end_delimiter (str, optional): the starting delimiter used in the template.
        should_hash (bool, optional): whether the template should be hashed on the server.
        template_hash (str, optional): the hash of the template.

    Returns:
        Template: the created Template.
    &#34;&#34;&#34;
    return Template(
        Resource.from_base64(base64string, filetype),
        start_delimiter,
        end_delimiter,
        should_hash,
        template_hash,
    )</code></pre>
</details>
<div class="desc"><p>Create a Template with a Base64Resource from a base64 string.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>base64string</code></strong> :&ensp;<code>str</code></dt>
<dd>the base64 encoded representation of a file.</dd>
<dt><strong><code>filetype</code></strong> :&ensp;<code>str</code></dt>
<dd>the file type (extension).</dd>
<dt><strong><code>start_delimiter</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>the starting delimiter used in the template.</dd>
<dt><strong><code>end_delimiter</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>the starting delimiter used in the template.</dd>
<dt><strong><code>should_hash</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>whether the template should be hashed on the server.</dd>
<dt><strong><code>template_hash</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>the hash of the template.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="cloudofficeprint.Template" href="#cloudofficeprint.Template">Template</a></code></dt>
<dd>the created Template.</dd>
</dl></div>
</dd>
<dt id="cloudofficeprint.Template.from_html"><code class="name flex">
<span>def <span class="ident">from_html</span></span>(<span>htmlstring: str,<br>landscape: bool = False,<br>start_delimiter: str = None,<br>end_delimiter: str = None,<br>should_hash: bool = None,<br>template_hash: str = None) ‑> <a title="cloudofficeprint.template.Template" href="template.html#cloudofficeprint.template.Template">Template</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_html(
    htmlstring: str,
    landscape: bool = False,
    start_delimiter: str = None,
    end_delimiter: str = None,
    should_hash: bool = None,
    template_hash: str = None,
) -&gt; &#34;Template&#34;:
    &#34;&#34;&#34;Create a Template with a HTMLResource with html data in plain text.

    Args:
        htmlstring (str): the html content.
        landscape (bool, optional): whether or not to use the landscape option. Defaults to False.
        start_delimiter (str, optional): the starting delimiter used in the template.
        end_delimiter (str, optional): the starting delimiter used in the template.
        should_hash (bool, optional): whether the template should be hashed on the server.
        template_hash (str, optional): the hash of the template.

    Returns:
        Template: the created Template.
    &#34;&#34;&#34;
    return Template(
        Resource.from_html(htmlstring, landscape),
        start_delimiter,
        end_delimiter,
        should_hash,
        template_hash,
    )</code></pre>
</details>
<div class="desc"><p>Create a Template with a HTMLResource with html data in plain text.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>htmlstring</code></strong> :&ensp;<code>str</code></dt>
<dd>the html content.</dd>
<dt><strong><code>landscape</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>whether or not to use the landscape option. Defaults to False.</dd>
<dt><strong><code>start_delimiter</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>the starting delimiter used in the template.</dd>
<dt><strong><code>end_delimiter</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>the starting delimiter used in the template.</dd>
<dt><strong><code>should_hash</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>whether the template should be hashed on the server.</dd>
<dt><strong><code>template_hash</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>the hash of the template.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="cloudofficeprint.Template" href="#cloudofficeprint.Template">Template</a></code></dt>
<dd>the created Template.</dd>
</dl></div>
</dd>
<dt id="cloudofficeprint.Template.from_local_file"><code class="name flex">
<span>def <span class="ident">from_local_file</span></span>(<span>local_path: str,<br>start_delimiter: str = None,<br>end_delimiter: str = None,<br>should_hash: bool = None,<br>template_hash: str = None) ‑> <a title="cloudofficeprint.template.Template" href="template.html#cloudofficeprint.template.Template">Template</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_local_file(
    local_path: str,
    start_delimiter: str = None,
    end_delimiter: str = None,
    should_hash: bool = None,
    template_hash: str = None,
) -&gt; &#34;Template&#34;:
    &#34;&#34;&#34;Create a Template with a Base64Resource with the contents of a local file.
    The filetype is determined by the extension of the file.

    Throws IOError if it can&#39;t read the file.

    Args:
        local_path (str): the path to local file.
        start_delimiter (str, optional): the starting delimiter used in the template.
        end_delimiter (str, optional): the starting delimiter used in the template.
        should_hash (bool, optional): whether the template should be hashed on the server.
        template_hash (str, optional): the hash of the template.

    Returns:
        Template: the created Template.
    &#34;&#34;&#34;
    return Template(
        Resource.from_local_file(local_path),
        start_delimiter,
        end_delimiter,
        should_hash,
        template_hash,
    )</code></pre>
</details>
<div class="desc"><p>Create a Template with a Base64Resource with the contents of a local file.
The filetype is determined by the extension of the file.</p>
<p>Throws IOError if it can't read the file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>local_path</code></strong> :&ensp;<code>str</code></dt>
<dd>the path to local file.</dd>
<dt><strong><code>start_delimiter</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>the starting delimiter used in the template.</dd>
<dt><strong><code>end_delimiter</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>the starting delimiter used in the template.</dd>
<dt><strong><code>should_hash</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>whether the template should be hashed on the server.</dd>
<dt><strong><code>template_hash</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>the hash of the template.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="cloudofficeprint.Template" href="#cloudofficeprint.Template">Template</a></code></dt>
<dd>the created Template.</dd>
</dl></div>
</dd>
<dt id="cloudofficeprint.Template.from_raw"><code class="name flex">
<span>def <span class="ident">from_raw</span></span>(<span>raw_data: bytes,<br>filetype: str,<br>start_delimiter: str = None,<br>end_delimiter: str = None,<br>should_hash: bool = None,<br>template_hash: str = None) ‑> <a title="cloudofficeprint.template.Template" href="template.html#cloudofficeprint.template.Template">Template</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_raw(
    raw_data: bytes,
    filetype: str,
    start_delimiter: str = None,
    end_delimiter: str = None,
    should_hash: bool = None,
    template_hash: str = None,
) -&gt; &#34;Template&#34;:
    &#34;&#34;&#34;Create a Template with a RawResource from raw file data.

    Args:
        raw_data (bytes): the raw data as a [bytes-like object](https://docs.python.org/3/glossary.html#term-bytes-like-object).
        filetype (str): the file type (extension).
        start_delimiter (str, optional): the starting delimiter used in the template.
        end_delimiter (str, optional): the starting delimiter used in the template.
        should_hash (bool, optional): whether the template should be hashed on the server.
        template_hash (str, optional): the hash of the template.

    Returns:
        Template: the created Template.
    &#34;&#34;&#34;
    return Template(
        Resource.from_raw(raw_data, filetype),
        start_delimiter,
        end_delimiter,
        should_hash,
        template_hash,
    )</code></pre>
</details>
<div class="desc"><p>Create a Template with a RawResource from raw file data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>raw_data</code></strong> :&ensp;<code>bytes</code></dt>
<dd>the raw data as a <a href="https://docs.python.org/3/glossary.html#term-bytes-like-object">bytes-like object</a>.</dd>
<dt><strong><code>filetype</code></strong> :&ensp;<code>str</code></dt>
<dd>the file type (extension).</dd>
<dt><strong><code>start_delimiter</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>the starting delimiter used in the template.</dd>
<dt><strong><code>end_delimiter</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>the starting delimiter used in the template.</dd>
<dt><strong><code>should_hash</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>whether the template should be hashed on the server.</dd>
<dt><strong><code>template_hash</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>the hash of the template.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="cloudofficeprint.Template" href="#cloudofficeprint.Template">Template</a></code></dt>
<dd>the created Template.</dd>
</dl></div>
</dd>
<dt id="cloudofficeprint.Template.from_server_path"><code class="name flex">
<span>def <span class="ident">from_server_path</span></span>(<span>path: str,<br>start_delimiter: str = None,<br>end_delimiter: str = None,<br>should_hash: bool = None,<br>template_hash: str = None) ‑> <a title="cloudofficeprint.template.Template" href="template.html#cloudofficeprint.template.Template">Template</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_server_path(
    path: str,
    start_delimiter: str = None,
    end_delimiter: str = None,
    should_hash: bool = None,
    template_hash: str = None,
) -&gt; &#34;Template&#34;:
    &#34;&#34;&#34;Create a Template with a ServerPathResource targeting a file on the server.
    The filetype is determined by the extension of the file.

    Args:
        path (str): the location of target file on the server.
        start_delimiter (str, optional): the starting delimiter used in the template.
        end_delimiter (str, optional): the starting delimiter used in the template.
        should_hash (bool, optional): whether the template should be hashed on the server.
        template_hash (str, optional): the hash of the template.

    Returns:
        Template: the created Template.
    &#34;&#34;&#34;
    return Template(
        Resource.from_server_path(path),
        start_delimiter,
        end_delimiter,
        should_hash,
        template_hash,
    )</code></pre>
</details>
<div class="desc"><p>Create a Template with a ServerPathResource targeting a file on the server.
The filetype is determined by the extension of the file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>the location of target file on the server.</dd>
<dt><strong><code>start_delimiter</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>the starting delimiter used in the template.</dd>
<dt><strong><code>end_delimiter</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>the starting delimiter used in the template.</dd>
<dt><strong><code>should_hash</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>whether the template should be hashed on the server.</dd>
<dt><strong><code>template_hash</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>the hash of the template.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="cloudofficeprint.Template" href="#cloudofficeprint.Template">Template</a></code></dt>
<dd>the created Template.</dd>
</dl></div>
</dd>
<dt id="cloudofficeprint.Template.from_url"><code class="name flex">
<span>def <span class="ident">from_url</span></span>(<span>url: str,<br>filetype: str,<br>start_delimiter: str = None,<br>end_delimiter: str = None,<br>should_hash: bool = None,<br>template_hash: str = None) ‑> <a title="cloudofficeprint.template.Template" href="template.html#cloudofficeprint.template.Template">Template</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_url(
    url: str,
    filetype: str,
    start_delimiter: str = None,
    end_delimiter: str = None,
    should_hash: bool = None,
    template_hash: str = None,
) -&gt; &#34;Template&#34;:
    &#34;&#34;&#34;Create a Template with a URLResource targeting the file at a given url.

    Args:
        url (str): the file URL.
        filetype (str): the file type (extension).
        start_delimiter (str, optional): the starting delimiter used in the template.
        end_delimiter (str, optional): the starting delimiter used in the template.
        should_hash (bool, optional): whether the template should be hashed on the server.
        template_hash (str, optional): the hash of the template.

    Returns:
        Template: the created Template.
    &#34;&#34;&#34;
    return Template(
        Resource.from_url(url, filetype),
        start_delimiter,
        end_delimiter,
        should_hash,
        template_hash,
    )</code></pre>
</details>
<div class="desc"><p>Create a Template with a URLResource targeting the file at a given url.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>str</code></dt>
<dd>the file URL.</dd>
<dt><strong><code>filetype</code></strong> :&ensp;<code>str</code></dt>
<dd>the file type (extension).</dd>
<dt><strong><code>start_delimiter</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>the starting delimiter used in the template.</dd>
<dt><strong><code>end_delimiter</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>the starting delimiter used in the template.</dd>
<dt><strong><code>should_hash</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>whether the template should be hashed on the server.</dd>
<dt><strong><code>template_hash</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>the hash of the template.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="cloudofficeprint.Template" href="#cloudofficeprint.Template">Template</a></code></dt>
<dd>the created Template.</dd>
</dl></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="cloudofficeprint.Template.mimetype"><code class="name">prop <span class="ident">mimetype</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mimetype(self) -&gt; str:
    &#34;&#34;&#34;
    Returns:
        str: the mime type of the Resource
    &#34;&#34;&#34;
    return self.resource.mimetype</code></pre>
</details>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>the mime type of the Resource</dd>
</dl></div>
</dd>
<dt id="cloudofficeprint.Template.template_dict"><code class="name">prop <span class="ident">template_dict</span> : Dict</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def template_dict(self) -&gt; Dict:
    &#34;&#34;&#34;
    Returns:
        Dict: the dictionary representation of this Resource.
    &#34;&#34;&#34;
    if self.template_hash and not self.should_hash:
        dict = {
            &#34;template_type&#34;: self.resource.filetype,
            &#34;template_hash&#34;: self.template_hash,
        }
        if self.start_delimiter:
            dict[&#34;start_delimiter&#34;] = self.start_delimiter
        if self.end_delimiter:
            dict[&#34;end_delimiter&#34;] = self.end_delimiter
        return dict
    dict = self.resource.template_dict
    if self.start_delimiter:
        dict[&#34;start_delimiter&#34;] = self.start_delimiter
    if self.end_delimiter:
        dict[&#34;end_delimiter&#34;] = self.end_delimiter
    if self.should_hash:
        dict[&#34;should_hash&#34;] = self.should_hash
    if self.template_hash:
        dict[&#34;template_hash&#34;] = self.template_hash
    return dict</code></pre>
</details>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict</code></dt>
<dd>the dictionary representation of this Resource.</dd>
</dl></div>
</dd>
<dt id="cloudofficeprint.Template.template_json"><code class="name">prop <span class="ident">template_json</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def template_json(self) -&gt; str:
    &#34;&#34;&#34;
    Returns:
        str: the JSON representation of this Resource.
    &#34;&#34;&#34;
    return json.dumps(self.template_dict)</code></pre>
</details>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>the JSON representation of this Resource.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="cloudofficeprint.Template.reset_hash"><code class="name flex">
<span>def <span class="ident">reset_hash</span></span>(<span>self, should_hash: bool = True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_hash(self, should_hash: bool = True):
    &#34;&#34;&#34;Reset the stored hash of the template.

    Args:
        should_hash (bool, optional): whether the template should be hashed on the server. Defaults to True.
    &#34;&#34;&#34;
    self.template_hash = None
    self.should_hash = should_hash</code></pre>
</details>
<div class="desc"><p>Reset the stored hash of the template.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>should_hash</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>whether the template should be hashed on the server. Defaults to True.</dd>
</dl></div>
</dd>
<dt id="cloudofficeprint.Template.update_hash"><code class="name flex">
<span>def <span class="ident">update_hash</span></span>(<span>self, template_hash: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_hash(self, template_hash: str):
    &#34;&#34;&#34;Update the Template to store a hash.
    On the next request to the server, the file data will not be sent, only the hash of the template.

    Args:
        template_hash (str): the hash of the template.
    &#34;&#34;&#34;
    self.template_hash = template_hash
    self.should_hash = False</code></pre>
</details>
<div class="desc"><p>Update the Template to store a hash.
On the next request to the server, the file data will not be sent, only the hash of the template.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>template_hash</code></strong> :&ensp;<code>str</code></dt>
<dd>the hash of the template.</dd>
</dl></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul>
<li><a href="#usage">Usage</a><ul>
<li><a href="#templates">Templates</a></li>
<li><a href="#render-elements">Render elements</a></li>
<li><a href="#the-server">The server</a></li>
<li><a href="#print-job">Print job</a></li>
<li><a href="#full-json-available">Full JSON available</a></li>
<li><a href="#server-errors">Server errors</a></li>
<li><a href="#further-information">Further information</a></li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="cloudofficeprint.config" href="config/index.html">cloudofficeprint.config</a></code></li>
<li><code><a title="cloudofficeprint.elements" href="elements/index.html">cloudofficeprint.elements</a></code></li>
<li><code><a title="cloudofficeprint.exceptions" href="exceptions.html">cloudofficeprint.exceptions</a></code></li>
<li><code><a title="cloudofficeprint.own_utils" href="own_utils/index.html">cloudofficeprint.own_utils</a></code></li>
<li><code><a title="cloudofficeprint.printjob" href="printjob.html">cloudofficeprint.printjob</a></code></li>
<li><code><a title="cloudofficeprint.resource" href="resource.html">cloudofficeprint.resource</a></code></li>
<li><code><a title="cloudofficeprint.response" href="response.html">cloudofficeprint.response</a></code></li>
<li><code><a title="cloudofficeprint.template" href="template.html">cloudofficeprint.template</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="cloudofficeprint.PrintJob" href="#cloudofficeprint.PrintJob">PrintJob</a></code></h4>
<ul class="">
<li><code><a title="cloudofficeprint.PrintJob.as_dict" href="#cloudofficeprint.PrintJob.as_dict">as_dict</a></code></li>
<li><code><a title="cloudofficeprint.PrintJob.execute" href="#cloudofficeprint.PrintJob.execute">execute</a></code></li>
<li><code><a title="cloudofficeprint.PrintJob.execute_async" href="#cloudofficeprint.PrintJob.execute_async">execute_async</a></code></li>
<li><code><a title="cloudofficeprint.PrintJob.execute_full_json" href="#cloudofficeprint.PrintJob.execute_full_json">execute_full_json</a></code></li>
<li><code><a title="cloudofficeprint.PrintJob.execute_full_json_async" href="#cloudofficeprint.PrintJob.execute_full_json_async">execute_full_json_async</a></code></li>
<li><code><a title="cloudofficeprint.PrintJob.json" href="#cloudofficeprint.PrintJob.json">json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="cloudofficeprint.Resource" href="#cloudofficeprint.Resource">Resource</a></code></h4>
<ul class="two-column">
<li><code><a title="cloudofficeprint.Resource.from_base64" href="#cloudofficeprint.Resource.from_base64">from_base64</a></code></li>
<li><code><a title="cloudofficeprint.Resource.from_html" href="#cloudofficeprint.Resource.from_html">from_html</a></code></li>
<li><code><a title="cloudofficeprint.Resource.from_local_file" href="#cloudofficeprint.Resource.from_local_file">from_local_file</a></code></li>
<li><code><a title="cloudofficeprint.Resource.from_raw" href="#cloudofficeprint.Resource.from_raw">from_raw</a></code></li>
<li><code><a title="cloudofficeprint.Resource.from_server_path" href="#cloudofficeprint.Resource.from_server_path">from_server_path</a></code></li>
<li><code><a title="cloudofficeprint.Resource.from_url" href="#cloudofficeprint.Resource.from_url">from_url</a></code></li>
<li><code><a title="cloudofficeprint.Resource.mimetype" href="#cloudofficeprint.Resource.mimetype">mimetype</a></code></li>
<li><code><a title="cloudofficeprint.Resource.secondary_file_dict" href="#cloudofficeprint.Resource.secondary_file_dict">secondary_file_dict</a></code></li>
<li><code><a title="cloudofficeprint.Resource.secondary_file_json" href="#cloudofficeprint.Resource.secondary_file_json">secondary_file_json</a></code></li>
<li><code><a title="cloudofficeprint.Resource.template_dict" href="#cloudofficeprint.Resource.template_dict">template_dict</a></code></li>
<li><code><a title="cloudofficeprint.Resource.template_json" href="#cloudofficeprint.Resource.template_json">template_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="cloudofficeprint.Response" href="#cloudofficeprint.Response">Response</a></code></h4>
<ul class="">
<li><code><a title="cloudofficeprint.Response.binary" href="#cloudofficeprint.Response.binary">binary</a></code></li>
<li><code><a title="cloudofficeprint.Response.filetype" href="#cloudofficeprint.Response.filetype">filetype</a></code></li>
<li><code><a title="cloudofficeprint.Response.mimetype" href="#cloudofficeprint.Response.mimetype">mimetype</a></code></li>
<li><code><a title="cloudofficeprint.Response.to_file" href="#cloudofficeprint.Response.to_file">to_file</a></code></li>
<li><code><a title="cloudofficeprint.Response.to_string" href="#cloudofficeprint.Response.to_string">to_string</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="cloudofficeprint.Template" href="#cloudofficeprint.Template">Template</a></code></h4>
<ul class="two-column">
<li><code><a title="cloudofficeprint.Template.from_base64" href="#cloudofficeprint.Template.from_base64">from_base64</a></code></li>
<li><code><a title="cloudofficeprint.Template.from_html" href="#cloudofficeprint.Template.from_html">from_html</a></code></li>
<li><code><a title="cloudofficeprint.Template.from_local_file" href="#cloudofficeprint.Template.from_local_file">from_local_file</a></code></li>
<li><code><a title="cloudofficeprint.Template.from_raw" href="#cloudofficeprint.Template.from_raw">from_raw</a></code></li>
<li><code><a title="cloudofficeprint.Template.from_server_path" href="#cloudofficeprint.Template.from_server_path">from_server_path</a></code></li>
<li><code><a title="cloudofficeprint.Template.from_url" href="#cloudofficeprint.Template.from_url">from_url</a></code></li>
<li><code><a title="cloudofficeprint.Template.mimetype" href="#cloudofficeprint.Template.mimetype">mimetype</a></code></li>
<li><code><a title="cloudofficeprint.Template.reset_hash" href="#cloudofficeprint.Template.reset_hash">reset_hash</a></code></li>
<li><code><a title="cloudofficeprint.Template.template_dict" href="#cloudofficeprint.Template.template_dict">template_dict</a></code></li>
<li><code><a title="cloudofficeprint.Template.template_json" href="#cloudofficeprint.Template.template_json">template_json</a></code></li>
<li><code><a title="cloudofficeprint.Template.update_hash" href="#cloudofficeprint.Template.update_hash">update_hash</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.5</a>.</p>
</footer>
</body>
</html>
